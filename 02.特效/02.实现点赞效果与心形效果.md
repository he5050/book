---
title: 实现点赞效果与心形效果
date: 2025-09-25
permalink: /special-effects/like-button
categories:
  - 特效
---

# HTML+CSS 实现点赞效果与心形动画效果

## 简介

点赞效果是一个常见的前端交互效果，广泛应用于社交媒体、内容平台等场景。通过 HTML 和 CSS 实现的点赞效果，包含心形图标、动画效果和庆祝粒子效果，为用户提供直观的视觉反馈。

心形动画效果则是通过 Canvas 技术实现的动态心形粒子效果，利用数学函数绘制心形曲线，并通过粒子系统实现浪漫的动画效果。

## 效果演示

<demo react="react/effects/HeartAnimation/example.tsx" 
:reactFiles="['react/effects/HeartAnimation/example.tsx', 'react/effects/HeartAnimation/index.tsx', 'react/effects/HeartAnimation/index.scss']" 
/>

## 实现原理

### HTML 结构

```html
<div class="heart-container" title="Like">
	<input type="checkbox" class="checkbox" id="Give-It-An-Id" />
	<div class="svg-container">
		<svg viewBox="0 0 24 24" class="svg-outline">
			<!-- 心形轮廓路径 -->
		</svg>
		<svg viewBox="0 0 24 24" class="svg-filled">
			<!-- 填充心形路径 -->
		</svg>
		<svg class="svg-celebrate">
			<!-- 庆祝动画多边形 -->
		</svg>
	</div>
</div>
```

HTML 结构包含以下关键元素：

- `.heart-container`：最外层容器，包含复选框和 SVG 容器
- `.checkbox`：隐藏的复选框，用于触发点赞动画
- `.svg-container`：包裹所有 SVG 图形的容器
- `.svg-outline`：显示心形轮廓的 SVG 图形
- `.svg-filled`：显示填充心形的 SVG 图形
- `.svg-celebrate`：显示庆祝动画的 SVG 图形

### CSS 样式

```css
.heart-container {
	--heart-color: rgb(255, 91, 137);
	position: relative;
	width: 50px;
	height: 50px;
	transition: 0.3s;
}

.heart-container .checkbox {
	position: absolute;
	width: 100%;
	height: 100%;
	opacity: 0;
	z-index: 20;
	cursor: pointer;
}

.heart-container .svg-container {
	width: 100%;
	height: 100%;
	display: flex;
	justify-content: center;
	align-items: center;
}

.heart-container .svg-outline,
.heart-container .svg-filled {
	fill: var(--heart-color);
	position: absolute;
}

.heart-container .svg-filled {
	display: none;
}

.heart-container .svg-filled.animate {
	display: block;
	animation: keyframes-svg-filled 1s;
}

.heart-container .svg-celebrate {
	position: absolute;
	animation-fill-mode: forwards;
	display: none;
	stroke: var(--heart-color);
	fill: var(--heart-color);
	stroke-width: 2px;
}

.heart-container .svg-celebrate.animate {
	display: block;
	animation: keyframes-svg-celebrate 0.5s;
}

@keyframes keyframes-svg-filled {
	0% {
		transform: scale(0);
	}

	25% {
		transform: scale(1.2);
	}

	50% {
		transform: scale(1);
		filter: brightness(1.5);
	}
}

@keyframes keyframes-svg-celebrate {
	0% {
		transform: scale(0);
	}

	50% {
		opacity: 1;
		filter: brightness(1.5);
	}

	100% {
		transform: scale(1.4);
		opacity: 0;
	}
}
```

## 核心技术点

### 1. CSS 变量

通过 CSS 变量定义心形颜色，便于统一管理和修改：

```css
.heart-container {
	--heart-color: rgb(255, 91, 137);
}
```

### 2. 隐藏复选框触发效果

使用隐藏的复选框作为交互触发器，通过 CSS 选择器控制元素显示：

```css
.heart-container .checkbox {
	position: absolute;
	width: 100%;
	height: 100%;
	opacity: 0;
	z-index: 20;
	cursor: pointer;
}
```

### 3. 关键帧动画

定义两个关键帧动画实现点赞效果：

- `keyframes-svg-filled`：填充心形的缩放和亮度变化动画
- `keyframes-svg-celebrate`：庆祝效果的缩放和透明度变化动画

### 4. SVG 图形

使用 SVG 实现心形图标，确保在不同分辨率下都能清晰显示：

```html
<!-- 心形轮廓 -->
<path
	d="M17.5,1.917a6.4,6.4,0,0,0-5.5,3.3,6.4,6.4,0,0,0-5.5-3.3A6.8,6.8,0,0,0,0,8.967c0,4.547,4.786,9.513,8.8,12.88a4.974,4.974,0,0,0,6.4,0C19.214,18.48,24,13.514,24,8.967A6.8,6.8,0,0,0,17.5,1.917Zm-3.585,18.4a2.973,2.973,0,0,1-3.83,0C4.947,16.006,2,11.87,2,8.967a4.8,4.8,0,0,1,4.5-5.05A4.8,4.8,0,0,1,11,8.967a1,1,0,0,0,2,0,4.8,4.8,0,0,1,4.5-5.05A4.8,4.8,0,0,1,22,8.967C22,11.87,19.053,16.006,13.915,20.313Z"
></path>
```

## React 组件实现

### 核心组件

```tsx
import React, { useState } from 'react';
import './index.scss';

interface LikeButtonProps {
	initialLiked?: boolean;
	onToggle?: (liked: boolean) => void;
}

const LikeButton: React.FC<LikeButtonProps> = ({ initialLiked = false, onToggle }) => {
	const [liked, setLiked] = useState(initialLiked);

	const handleToggle = () => {
		const newLiked = !liked;
		setLiked(newLiked);
		onToggle?.(newLiked);
	};

	return (
		<div className="like-button-container">
			<div className="heart-container" title="Like">
				<input
					type="checkbox"
					className="checkbox"
					id="like-checkbox"
					checked={liked}
					onChange={handleToggle}
				/>
				<div className="svg-container">
					{/* 心形轮廓 */}
					<svg viewBox="0 0 24 24" className="svg-outline">
						{/* 路径数据 */}
					</svg>

					{/* 填充的心形 */}
					<svg className={`svg-filled ${liked ? 'animate' : ''}`}>{/* 路径数据 */}</svg>

					{/* 庆祝动画 */}
					<svg className={`svg-celebrate ${liked ? 'animate' : ''}`}>{/* 多边形数据 */}</svg>
				</div>
			</div>
		</div>
	);
};

export default LikeButton;
```

## 心形动画效果实现

除了简单的点赞效果，我们还可以实现更复杂的心形动画效果，通过 Canvas 技术创建动态的粒子系统。

### 核心技术点

1. **心形曲线数学公式**：使用参数方程绘制心形曲线
2. **粒子系统**：管理大量粒子的创建、更新和销毁
3. **动画循环**：使用 requestAnimationFrame 实现流畅动画
4. **响应式设计**：适配不同屏幕尺寸

### 心形曲线公式

心形曲线的数学公式是实现心形动画效果的核心：

```javascript
function pointOnHeart(t) {
	return new Point(
		160 * Math.pow(Math.sin(t), 3),
		130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25
	);
}
```

### 粒子系统实现

```typescript
class Particle {
	position: Point;
	velocity: Point;
	acceleration: Point;
	age: number;

	constructor() {
		this.position = new Point();
		this.velocity = new Point();
		this.acceleration = new Point();
		this.age = 0;
	}

	initialize(x: number, y: number, dx: number, dy: number) {
		this.position.x = x;
		this.position.y = y;
		this.velocity.x = dx;
		this.velocity.y = dy;
		this.acceleration.x = dx * -0.75;
		this.acceleration.y = dy * -0.75;
		this.age = 0;
	}

	update(deltaTime: number) {
		this.position.x += this.velocity.x * deltaTime;
		this.position.y += this.velocity.y * deltaTime;
		this.velocity.x += this.acceleration.x * deltaTime;
		this.velocity.y += this.acceleration.y * deltaTime;
		this.age += deltaTime;
	}
}
```

### 完整的 React 组件实现

```tsx
// 文件路径: /example/components/react/effects/HeartAnimation/index.tsx
import React, { useState, useEffect, useRef } from 'react';
import './index.scss';

interface HeartAnimationProps {
	particleCount?: number;
	duration?: number;
	velocity?: number;
	size?: number;
	color?: string;
	className?: string;
}

const HeartAnimation: React.FC<HeartAnimationProps> = ({
	particleCount = 400,
	duration = 2,
	velocity = 90,
	size = 30,
	color = '#FF416C',
	className = ''
}) => {
	const canvasRef = useRef<HTMLCanvasElement>(null);
	const particlesRef = useRef<any[]>([]);
	const activeParticlesRef = useRef<number>(0);
	const freeParticlesRef = useRef<number>(0);
	const timeRef = useRef<number>(0);
	const particleImageRef = useRef<HTMLImageElement | null>(null);

	// Point class
	class Point {
		x: number;
		y: number;

		constructor(x = 0, y = 0) {
			this.x = x;
			this.y = y;
		}

		clone() {
			return new Point(this.x, this.y);
		}

		length(length?: number) {
			if (length === undefined) {
				return Math.sqrt(this.x * this.x + this.y * this.y);
			}
			this.normalize();
			this.x *= length;
			this.y *= length;
			return this;
		}

		normalize() {
			const length = this.length();
			this.x /= length;
			this.y /= length;
			return this;
		}
	}

	// Particle class
	class Particle {
		position: Point;
		velocity: Point;
		acceleration: Point;
		age: number;

		constructor() {
			this.position = new Point();
			this.velocity = new Point();
			this.acceleration = new Point();
			this.age = 0;
		}

		initialize(x: number, y: number, dx: number, dy: number) {
			this.position.x = x;
			this.position.y = y;
			this.velocity.x = dx;
			this.velocity.y = dy;
			this.acceleration.x = dx * -0.75;
			this.acceleration.y = dy * -0.75;
			this.age = 0;
		}

		update(deltaTime: number) {
			this.position.x += this.velocity.x * deltaTime;
			this.position.y += this.velocity.y * deltaTime;
			this.velocity.x += this.acceleration.x * deltaTime;
			this.velocity.y += this.acceleration.y * deltaTime;
			this.age += deltaTime;
		}

		draw(context: CanvasRenderingContext2D, image: HTMLImageElement) {
			function ease(t: number) {
				return -t * t * t + 1;
			}
			const particleSize = image.width * ease(this.age / duration);
			context.globalAlpha = 1 - this.age / duration;
			context.drawImage(
				image,
				this.position.x - particleSize / 2,
				this.position.y - particleSize / 2,
				particleSize,
				particleSize
			);
		}
	}

	// ParticlePool class
	class ParticlePool {
		particles: Particle[];
		firstActive: number;
		firstFree: number;
		duration: number;

		constructor(length: number) {
			this.particles = new Array(length);
			for (let i = 0; i < this.particles.length; i++) {
				this.particles[i] = new Particle();
			}
			this.firstActive = 0;
			this.firstFree = 0;
			this.duration = duration;
		}

		add(x: number, y: number, dx: number, dy: number) {
			this.particles[this.firstFree].initialize(x, y, dx, dy);
			this.firstFree++;
			if (this.firstFree === this.particles.length) this.firstFree = 0;
			if (this.firstActive === this.firstFree) this.firstActive++;
			if (this.firstActive === this.particles.length) this.firstActive = 0;
		}

		update(deltaTime: number) {
			if (this.firstActive < this.firstFree) {
				for (let i = this.firstActive; i < this.firstFree; i++) {
					this.particles[i].update(deltaTime);
				}
			} else if (this.firstFree < this.firstActive) {
				for (let i = this.firstActive; i < this.particles.length; i++) {
					this.particles[i].update(deltaTime);
				}
				for (let i = 0; i < this.firstFree; i++) {
					this.particles[i].update(deltaTime);
				}
			}
			while (
				this.particles[this.firstActive].age >= this.duration &&
				this.firstActive !== this.firstFree
			) {
				this.firstActive++;
				if (this.firstActive === this.particles.length) this.firstActive = 0;
			}
		}

		draw(context: CanvasRenderingContext2D, image: HTMLImageElement) {
			if (this.firstActive < this.firstFree) {
				for (let i = this.firstActive; i < this.firstFree; i++) {
					this.particles[i].draw(context, image);
				}
			} else if (this.firstFree < this.firstActive) {
				for (let i = this.firstActive; i < this.particles.length; i++) {
					this.particles[i].draw(context, image);
				}
				for (let i = 0; i < this.firstFree; i++) {
					this.particles[i].draw(context, image);
				}
			}
		}
	}

	// Calculate point on heart curve
	const pointOnHeart = (t: number) => {
		return new Point(
			160 * Math.pow(Math.sin(t), 3),
			130 * Math.cos(t) - 50 * Math.cos(2 * t) - 20 * Math.cos(3 * t) - 10 * Math.cos(4 * t) + 25
		);
	};

	// Create particle image
	const createParticleImage = () => {
		const canvas = document.createElement('canvas');
		const context = canvas.getContext('2d');
		if (!context) return;

		canvas.width = size;
		canvas.height = size;

		const to = (t: number) => {
			const point = pointOnHeart(t);
			point.x = size / 2 + (point.x * size) / 350;
			point.y = size / 2 - (point.y * size) / 350;
			return point;
		};

		context.beginPath();
		let t = -Math.PI;
		let point = to(t);
		context.moveTo(point.x, point.y);
		while (t < Math.PI) {
			t += 0.01;
			point = to(t);
			context.lineTo(point.x, point.y);
		}
		context.closePath();
		context.fillStyle = color;
		context.fill();

		const image = new Image();
		image.src = canvas.toDataURL();
		particleImageRef.current = image;
	};

	// Render animation
	const render = () => {
		const canvas = canvasRef.current;
		if (!canvas || !particleImageRef.current) return;

		const context = canvas.getContext('2d');
		if (!context) return;

		const newTime = new Date().getTime() / 1000;
		const deltaTime = newTime - (timeRef.current || newTime);
		timeRef.current = newTime;

		context.clearRect(0, 0, canvas.width, canvas.height);

		const particleRate = particleCount / duration;
		const amount = particleRate * deltaTime;

		for (let i = 0; i < amount; i++) {
			const pos = pointOnHeart(Math.PI - 2 * Math.PI * Math.random());
			const dir = pos.clone().length(velocity);
			const particles = particlesRef.current as any;
			particles.add(canvas.width / 2 + pos.x, canvas.height / 2 - pos.y, dir.x, -dir.y);
		}

		const particles = particlesRef.current as any;
		particles.update(deltaTime);
		particles.draw(context, particleImageRef.current);

		requestAnimationFrame(render);
	};

	// Handle resize
	const onResize = () => {
		const canvas = canvasRef.current;
		if (!canvas) return;

		canvas.width = canvas.clientWidth;
		canvas.height = canvas.clientHeight;
	};

	// Initialize
	useEffect(() => {
		const canvas = canvasRef.current;
		if (!canvas) return;

		particlesRef.current = new ParticlePool(particleCount) as any;
		createParticleImage();

		window.addEventListener('resize', onResize);
		setTimeout(() => {
			onResize();
			render();
		}, 10);

		return () => {
			window.removeEventListener('resize', onResize);
		};
	}, [particleCount, duration, velocity, size, color]);

	return (
		<div className={`heart-animation ${className}`}>
			<canvas ref={canvasRef} className="heart-canvas" />
			<div className="heart-text">
				<span style={{ fontSize: '16px', color }}>X ♥ X</span>
				<span style={{ fontStyle: '12px', fontWeight: 600, color }}>I Love You</span>
			</div>
		</div>
	);
};

export default HeartAnimation;
```

### 样式文件

```scss
// 文件路径: /example/components/react/effects/HeartAnimation/index.scss
.heart-animation {
	position: relative;
	width: 100%;
	height: 100vh;
	overflow: hidden;

	.heart-canvas {
		position: absolute;
		width: 100%;
		height: 100%;
		top: 0;
		left: 0;
	}

	.heart-text {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		margin-top: -20px;
		font-size: 30px;
		color: #ea80b0;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		z-index: 10;
		text-align: center;

		span {
			margin: 5px 0;
		}
	}
}

// Responsive design
@media (max-width: 768px) {
	.heart-animation {
		.heart-text {
			font-size: 24px;

			span:first-child {
				font-size: 14px !important;
			}

			span:last-child {
				font-size: 10px !important;
			}
		}
	}
}

@media (max-width: 480px) {
	.heart-animation {
		.heart-text {
			font-size: 20px;

			span:first-child {
				font-size: 12px !important;
			}

			span:last-child {
				font-size: 8px !important;
			}
		}
	}
}
```

### 使用示例

```tsx
// 文件路径: /example/components/react/effects/HeartAnimation/example.tsx
import React from 'react';
import HeartAnimation from './index';

const HeartAnimationExample: React.FC = () => {
	return (
		<div style={{ height: '100vh' }}>
			<HeartAnimation particleCount={500} duration={2.5} velocity={100} size={35} color="#FF69B4" />
		</div>
	);
};

export default HeartAnimationExample;
```

## 使用说明

### 点赞按钮组件使用

#### 基本使用

```tsx
import LikeButton from './effects/LikeButton';

function App() {
	return <LikeButton />;
}
```

#### 带回调函数使用

```tsx
import { useState } from 'react';
import LikeButton from './effects/LikeButton';

function App() {
	const [likeCount, setLikeCount] = useState(0);

	const handleLikeToggle = (liked: boolean) => {
		setLikeCount(liked ? likeCount + 1 : likeCount - 1);
	};

	return <LikeButton onToggle={handleLikeToggle} />;
}
```

#### 自定义初始状态

```tsx
import LikeButton from './effects/LikeButton';

function App() {
	return <LikeButton initialLiked={true} />;
}
```

### 心形动画组件使用

#### 基本使用

```tsx
import HeartAnimation from './effects/HeartAnimation';

function App() {
	return (
		<div style={{ height: '100vh' }}>
			<HeartAnimation />
		</div>
	);
}
```

#### 自定义参数

```tsx
import HeartAnimation from './effects/HeartAnimation';

function App() {
	return (
		<div style={{ height: '100vh' }}>
			<HeartAnimation particleCount={600} duration={3} velocity={120} size={40} color="#FF1493" />
		</div>
	);
}
```

## 优化建议

### 1. 性能优化

- 使用 CSS3 硬件加速优化动画性能
- 避免频繁的 DOM 操作
- 合理使用 React.memo 优化组件渲染
- 在心形动画中使用 requestAnimationFrame 实现流畅动画

### 2. 可访问性增强

```tsx
<input
	type="checkbox"
	className="checkbox"
	id="like-checkbox"
	checked={liked}
	onChange={handleToggle}
	aria-label="点赞按钮"
/>
```

### 3. 主题定制

通过 CSS 变量支持主题定制：

```css
.heart-container {
	--heart-color: var(--primary-color, rgb(255, 91, 137));
}
```

### 4. 响应式设计

心形动画组件已实现响应式设计，适配不同屏幕尺寸：

```scss
@media (max-width: 768px) {
	.heart-animation {
		.heart-text {
			font-size: 24px;
		}
	}
}
```

## 浏览器兼容性

### 点赞效果组件

- Chrome 36+
- Firefox 16+
- Safari 9+
- Edge 12+
- IE 10+

### 心形动画组件

- Chrome 4+
- Firefox 3.6+
- Safari 5+
- Edge 12+
- IE 9+

## 结语

HTML+CSS 实现的点赞效果通过巧妙的结构设计和动画技术，为用户提供了流畅的交互体验。该效果不仅展示了 CSS 动画的强大功能，也体现了前端开发中细节设计的重要性。

心形动画效果则通过 Canvas 技术和粒子系统，实现了更加浪漫和动态的视觉效果。通过数学公式绘制心形曲线，结合粒子系统和动画循环，创造出令人印象深刻的视觉体验。

通过合理的优化和扩展，这些效果可以应用于各种需要点赞功能或浪漫元素的场景中，为用户带来更好的交互体验。
