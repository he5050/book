---
title: 17.浏览器的API
date: 2025-09-01 22:33:00
permalink: /notes/browser-api
description: 浏览器的API
categories:
  - 笔记
tags:
  - JS
  - 浏览器API
---

## Page Visibility API

Page Visibility API 用于检测页面是否对用户可见，以便网页在用户看不见的时候暂停或减少不必要的操作，从而节省资源。

### 基本用法

```javascript
// 检测页面可见性状态
document.addEventListener('visibilitychange', function () {
	if (document.hidden) {
		console.log('页面不可见，暂停视频播放');
		video.pause();
	} else {
		console.log('页面可见，继续视频播放');
		video.play();
	}
});

// 获取当前页面可见性
console.log(document.visibilityState); // 'visible' 或 'hidden'
```

### 使用场景

1. **暂停媒体播放**：当用户切换到其他标签页或最小化浏览器时，暂停视频或音频播放
2. **暂停动画**：当页面不可见时，暂停不必要的动画效果，减少 CPU 使用
3. **暂停轮询**：当页面不可见时，暂停数据轮询，减少网络请求
4. **统计用户行为**：记录用户查看页面的实际时间

### 音视频播放控制示例

```javascript
// 音乐播放器示例
const audioPlayer = document.getElementById('audio-player');
const playButton = document.getElementById('play-button');
let wasPlaying = false;

// 页面可见性变化时控制音频播放
document.addEventListener('visibilitychange', function () {
	if (document.hidden) {
		// 页面隐藏时，记录当前播放状态并暂停
		wasPlaying = !audioPlayer.paused;
		if (wasPlaying) {
			audioPlayer.pause();
			playButton.textContent = '播放';
		}
	} else {
		// 页面重新可见且之前正在播放，则恢复播放
		if (wasPlaying) {
			audioPlayer
				.play()
				.then(() => {
					playButton.textContent = '暂停';
				})
				.catch(error => {
					console.error('自动恢复播放失败:', error);
					// 可能是由于浏览器策略限制，需要用户交互
				});
		}
	}
});

// 处理用户交互播放/暂停
playButton.addEventListener('click', function () {
	if (audioPlayer.paused) {
		audioPlayer.play();
		playButton.textContent = '暂停';
	} else {
		audioPlayer.pause();
		playButton.textContent = '播放';
	}
});
```

### 实际应用场景

1. **视频网站**：当用户切换标签页时自动暂停视频，节省带宽并保持用户观看进度
2. **音乐流媒体**：当用户离开页面时暂停音乐播放，避免用户返回时错过内容
3. **在线课程平台**：当学习者切换到其他应用时暂停课程视频，并记录实际学习时间
4. **游戏应用**：当页面不可见时自动暂停游戏，保存游戏状态

### 注意事项和兼容性

- 所有现代浏览器都支持此 API
- 在移动设备上，当浏览器最小化或切换到其他应用时，也会触发 visibilitychange 事件
- 不要完全依赖此 API 来实现安全功能，因为它可以被恶意脚本覆盖

## Web Share API

Web Share API 允许网站调用设备的原生分享功能，使用户能够通过设备上安装的应用分享文本、链接和文件。

### 基本用法

```javascript
// 检查浏览器是否支持Web Share API
if (navigator.share) {
	// 分享文本和链接
	document.querySelector('#shareButton').addEventListener('click', async () => {
		try {
			await navigator.share({
				title: '分享标题',
				text: '分享描述文本',
				url: 'https://example.com'
			});
			console.log('分享成功');
		} catch (error) {
			console.log('分享失败:', error);
		}
	});

	// 分享文件
	document.querySelector('#shareFileButton').addEventListener('click', async () => {
		try {
			const fileInput = document.querySelector('#fileInput');
			const files = fileInput.files;

			if (files.length > 0 && navigator.canShare && navigator.canShare({ files })) {
				await navigator.share({
					files: files,
					title: '分享文件',
					text: '这是我分享的文件'
				});
				console.log('文件分享成功');
			} else {
				console.log('文件无法分享');
			}
		} catch (error) {
			console.log('分享失败:', error);
		}
	});
}
```

### 使用场景

1. **社交分享**：让用户轻松分享网页内容到社交媒体
2. **分享生成内容**：分享用户在网页上生成的内容，如图片编辑结果
3. **分享文件**：分享下载的文档、图片等文件
4. **联系人分享**：分享联系人信息到通讯录应用

### 注意事项和兼容性

- 需要在安全上下文（HTTPS）中使用
- 必须由用户手势触发（如点击事件）
- 移动设备支持较好，桌面支持有限
- 文件分享在部分浏览器中可能不支持
- 可分享的文件类型包括：图片、音频、视频、文本文件等
- 使用`navigator.canShare()`方法可以检查特定内容是否可分享

## Wake Lock API

Wake Lock API 允许网页阻止设备进入休眠状态，保持屏幕常亮。

### 基本用法

```javascript
// 声明一个全局变量来存储唤醒锁
let wakeLock = null;

// 请求屏幕唤醒锁
async function requestWakeLock() {
	try {
		// 检查浏览器是否支持Wake Lock API
		if ('wakeLock' in navigator) {
			// 请求屏幕唤醒锁
			wakeLock = await navigator.wakeLock.request('screen');

			console.log('唤醒锁激活');

			// 监听唤醒锁释放事件
			wakeLock.addEventListener('release', () => {
				console.log('唤醒锁已释放');
				wakeLock = null;
			});

			// 当页面可见性变化时重新请求唤醒锁
			document.addEventListener('visibilitychange', async () => {
				if (document.visibilityState === 'visible' && !wakeLock) {
					wakeLock = await navigator.wakeLock.request('screen');
				}
			});
		}
	} catch (error) {
		console.error('请求唤醒锁失败:', error);
	}
}

// 释放唤醒锁
function releaseWakeLock() {
	if (wakeLock) {
		wakeLock.release().then(() => {
			console.log('唤醒锁已手动释放');
			wakeLock = null;
		});
	}
}

// 在用户交互时请求唤醒锁
document.querySelector('#enableWakeLock').addEventListener('click', requestWakeLock);
document.querySelector('#disableWakeLock').addEventListener('click', releaseWakeLock);
```

### 使用场景

1. **长时间阅读**：阅读长文章或电子书时保持屏幕常亮
2. **演示应用**：进行演示或展示时防止屏幕关闭
3. **导航应用**：使用地图导航时保持屏幕常亮
4. **游戏应用**：玩游戏时防止屏幕自动锁定

### 注意事项和兼容性

- 需要在安全上下文（HTTPS）中使用
- 当页面不可见或不活跃时，唤醒锁会自动释放
- 设备电量低时，系统可能会忽略唤醒锁请求
- 目前主要在 Chrome 和基于 Chromium 的浏览器中支持
- 使用时应考虑电池消耗，仅在必要时启用
- 页面可见性变化时需要重新请求唤醒锁

## Broadcast Channel API

Broadcast Channel API 允许同源的不同浏览上下文（如不同标签页、iframe 或 worker）之间进行通信。

### 基本用法

```javascript
// 创建或加入一个广播频道
const channel = new BroadcastChannel('app_channel');

// 发送消息
function sendMessage() {
	const message = document.querySelector('#messageInput').value;
	channel.postMessage({
		type: 'chat',
		data: message,
		sender: 'Tab ' + Math.floor(Math.random() * 1000),
		timestamp: Date.now()
	});
}

// 接收消息
channel.onmessage = event => {
	const message = event.data;
	console.log(`收到消息: ${JSON.stringify(message)}`);

	// 处理接收到的消息
	const messagesList = document.querySelector('#messagesList');
	const messageItem = document.createElement('li');
	messageItem.textContent = `${message.sender}: ${message.data}`;
	messagesList.appendChild(messageItem);
};

// 关闭频道连接
function closeChannel() {
	channel.close();
	console.log('广播频道已关闭');
}

// 在页面卸载时关闭频道
window.addEventListener('unload', closeChannel);

// 绑定发送按钮事件
document.querySelector('#sendButton').addEventListener('click', sendMessage);
```

### 使用场景

1. **多标签页同步**：在多个标签页之间同步用户操作或状态
2. **实时通知**：向所有打开的页面广播通知或更新
3. **共享数据**：在不同标签页之间共享数据，避免重复请求
4. **协同编辑**：实现简单的协同编辑功能
5. **登录状态同步**：一个标签页登录或登出时，同步更新其他标签页

### 注意事项和兼容性

- 仅限于同源页面之间通信（相同的协议、域名和端口）
- 支持传输任何可被结构化克隆算法序列化的数据
- 大多数现代浏览器都支持此 API，但 IE 不支持
- 消息是广播的，所有监听同一频道的上下文都会收到消息
- 当不再需要通信时，应调用`close()`方法释放资源
- 相比于其他通信方式（如 LocalStorage 事件），Broadcast Channel API 更可靠、更高效

## PerformanceObserver API

PerformanceObserver API 允许监测性能度量事件，在浏览器的性能时间轴记录新的 performance entry 时通知开发者。

### 基本用法

```javascript
// 创建性能观察器
const observer = new PerformanceObserver(list => {
	// 获取并处理性能条目
	const entries = list.getEntries();
	entries.forEach(entry => {
		console.log(`性能条目: ${entry.name}`, entry);
	});
});

// 开始观察特定类型的性能条目
observer.observe({ entryTypes: ['mark', 'measure'] });

// 创建性能标记
performance.mark('start_process');

// 模拟一些操作
setTimeout(() => {
	// 创建另一个性能标记
	performance.mark('end_process');

	// 测量两个标记之间的时间
	performance.measure('process_duration', 'start_process', 'end_process');

	// 获取测量结果
	const measure = performance.getEntriesByName('process_duration')[0];
	console.log(`处理耗时: ${measure.duration}ms`);

	// 停止观察
	// observer.disconnect();
}, 1000);

// 观察资源加载性能
const resourceObserver = new PerformanceObserver(list => {
	const resources = list.getEntries();
	resources.forEach(resource => {
		console.log(`资源 ${resource.name} 加载耗时: ${resource.duration}ms`);
	});
});

resourceObserver.observe({ entryTypes: ['resource'] });
```

### 使用场景

1. **性能监控**：监控页面加载、资源加载、JavaScript 执行等性能指标
2. **用户体验分析**：收集真实用户的性能数据，分析用户体验
3. **性能预算监控**：设置性能预算，当性能指标超出预期时发出警告
4. **自定义性能测量**：使用 mark 和 measure 测量特定代码块的执行时间
5. **识别性能瓶颈**：分析长任务和阻塞渲染的操作

### 注意事项和兼容性

- 大多数现代浏览器都支持此 API
- 不同类型的性能条目在不同浏览器中的支持程度可能不同
- 观察某些类型的条目可能需要特定的权限或设置
- 性能数据收集可能会对性能本身产生轻微影响
- 建议在生产环境中谨慎使用，可以考虑采样收集数据
- 可以使用`takeRecords()`方法获取尚未处理的性能条目

## requestIdleCallback API

requestIdleCallback API 允许在浏览器空闲时期调度执行低优先级的任务，而不会影响关键事件如动画和用户交互。

### 基本用法

```javascript
// 定义一个需要在空闲时执行的任务
function doNonEssentialWork(deadline) {
	// 检查是否有剩余时间
	while (deadline.timeRemaining() > 0 || deadline.didTimeout) {
		// 执行一小块工作
		doWorkIfNeeded();

		// 如果还有更多工作要做，但时间不够了，重新调度
		if (thereIsMoreWorkToDo) {
			requestIdleCallback(doNonEssentialWork, { timeout: 1000 });
			break;
		}
	}
}

// 模拟一个工作单元
let workUnits = Array(50)
	.fill()
	.map((_, i) => i);
let currentWorkIndex = 0;
let thereIsMoreWorkToDo = true;

function doWorkIfNeeded() {
	if (currentWorkIndex < workUnits.length) {
		const work = workUnits[currentWorkIndex++];
		console.log(`执行工作单元: ${work}`);

		// 模拟工作完成
		if (currentWorkIndex >= workUnits.length) {
			thereIsMoreWorkToDo = false;
			console.log('所有工作完成');
		}
	}
}

// 调度任务在浏览器空闲时执行
// timeout 选项确保即使浏览器一直很忙，任务也会在1秒后执行
requestIdleCallback(doNonEssentialWork, { timeout: 1000 });

// 取消已调度的回调
const handle = requestIdleCallback(someFunction);
cancelIdleCallback(handle); // 取消调度
```

### 使用场景

1. **数据预取**：在用户不活跃时预取可能需要的数据
2. **延迟加载**：延迟加载非关键资源或组件
3. **后台计算**：执行复杂计算但不阻塞主线程
4. **垃圾回收**：清理不再需要的内存或资源
5. **数据分析和上报**：收集和处理分析数据并发送到服务器

### 注意事项和兼容性

- Chrome、Firefox 和 Edge 支持此 API，但 Safari 不支持
- 回调函数接收一个`IdleDeadline`对象，包含`timeRemaining()`方法和`didTimeout`属性
- `timeRemaining()`返回的时间以毫秒为单位，通常在 0-50ms 之间
- 不要在回调中执行 DOM 操作，因为可能会触发重新渲染
- 对于需要在下一帧之前完成的任务，应使用`requestAnimationFrame`而非`requestIdleCallback`
- 可以使用 polyfill 在不支持的浏览器中模拟此功能
- 设置`timeout`选项可确保任务最终会执行，即使浏览器一直很忙

## scheduler.postTask API

scheduler.postTask API 提供了一种更精细的任务调度机制，允许开发者根据任务的优先级和时间安排来调度任务执行。

### 基本用法

```javascript
// 检查浏览器是否支持scheduler API
if ('scheduler' in window && 'postTask' in window.scheduler) {
	// 调度一个任务
	scheduler
		.postTask(() => {
			console.log('执行标准优先级任务');
			performTask();
		})
		.then(() => {
			console.log('任务已完成');
		})
		.catch(error => {
			console.error('任务执行失败:', error);
		});

	// 调度一个高优先级任务
	scheduler.postTask(
		() => {
			console.log('执行用户阻塞任务');
			handleUserInput();
		},
		{ priority: 'user-blocking' }
	);

	// 调度一个低优先级任务
	scheduler.postTask(
		() => {
			console.log('执行后台任务');
			processDataInBackground();
		},
		{ priority: 'background' }
	);

	// 调度一个延迟任务
	scheduler.postTask(
		() => {
			console.log('执行延迟任务');
		},
		{ delay: 2000 }
	); // 2秒后执行

	// 创建一个可以取消的任务
	const controller = new AbortController();
	const { signal } = controller;

	const taskPromise = scheduler.postTask(
		() => {
			console.log('执行可取消任务');
			processLargeData();
		},
		{ signal }
	);

	// 在某些条件下取消任务
	setTimeout(() => {
		controller.abort();
		console.log('任务已取消');
	}, 1000);
}
```

### 使用场景

1. **用户交互处理**：使用高优先级处理用户输入和交互
2. **数据处理**：在后台低优先级处理大量数据
3. **UI 更新**：根据优先级调度不同部分的 UI 更新
4. **资源加载**：根据重要性调度资源加载任务
5. **定时任务**：替代 setTimeout 实现更可靠的定时任务

### 注意事项和兼容性

- 目前主要在 Chrome 94+和基于 Chromium 的浏览器中支持
- 任务优先级分为三级：`'user-blocking'`（最高）、`'user-visible'`（默认）和`'background'`（最低）
- 返回 Promise 对象，可以使用 then/catch 处理任务完成或失败
- 可以使用 AbortController 取消尚未执行的任务
- delay 参数允许设置任务延迟执行的时间（毫秒）
- 相比于 setTimeout，scheduler.postTask 提供了更精确的任务调度和优先级控制
- 在不支持的浏览器中，可以使用 polyfill 或回退到 setTimeout

## AbortController API

AbortController API 提供了一种标准方式来取消一个或多个异步操作，如 fetch 请求、动画或任何其他可取消的操作。

### 基本用法

```javascript
// 创建一个AbortController实例
const controller = new AbortController();
const signal = controller.signal;

// 使用signal发起fetch请求
fetch('https://api.example.com/data', { signal })
	.then(response => response.json())
	.then(data => console.log('获取的数据:', data))
	.catch(error => {
		if (error.name === 'AbortError') {
			console.log('请求被取消');
		} else {
			console.error('请求失败:', error);
		}
	});

// 在某个条件下取消请求
setTimeout(() => {
	controller.abort();
	console.log('请求已取消');
}, 5000); // 5秒后取消请求

// 取消多个操作
const multiController = new AbortController();
const multiSignal = multiController.signal;

// 多个fetch请求共享同一个signal
const fetchUsers = fetch('/api/users', { signal: multiSignal });
const fetchProducts = fetch('/api/products', { signal: multiSignal });

// 同时取消所有请求
document.querySelector('#cancelButton').addEventListener('click', () => {
	multiController.abort();
});

// 使用AbortSignal.timeout()创建一个会自动超时的信号
if ('timeout' in AbortSignal) {
	const timeoutSignal = AbortSignal.timeout(10000); // 10秒超时

	fetch('/api/data', { signal: timeoutSignal })
		.then(response => response.json())
		.then(data => console.log(data))
		.catch(error => {
			if (error.name === 'AbortError') {
				console.log('请求超时自动取消');
			}
		});
}
```

### 使用场景

1. **取消网络请求**：当用户导航离开页面或取消操作时，终止进行中的 fetch 请求
2. **超时处理**：为长时间运行的请求设置超时限制
3. **取消动画**：停止正在进行的动画或过渡效果
4. **资源清理**：在组件卸载时取消所有相关的异步操作
5. **用户交互响应**：响应用户取消操作的请求

### 注意事项和兼容性

- 所有现代浏览器都支持此 API
- `abort()`方法可以接收一个参数作为取消原因，通过`signal.reason`访问
- 被取消的 Promise 会以 AbortError 拒绝，应在 catch 中处理
- 可以使用`signal.addEventListener('abort', callback)`监听取消事件
- `signal.aborted`属性表示信号是否已被取消
- 对于不支持 AbortController 的旧版浏览器，可以使用 polyfill
- 取消 HTTP 请求时，虽然客户端不再等待响应，但服务器可能仍会完成请求处理

## File System Access API

File System Access API 允许网页应用直接读取、写入和管理用户本地设备上的文件，提供了类似本地应用的文件操作体验。

### 基本用法

```javascript
// 打开文件
async function openFile() {
	try {
		// 显示文件选择器
		const [fileHandle] = await window.showOpenFilePicker({
			multiple: false, // 只选择一个文件
			types: [
				{
					description: '文本文件',
					accept: {
						'text/plain': ['.txt', '.md']
					}
				}
			]
		});

		// 获取文件权限
		const options = {
			writable: true,
			mode: 'readwrite'
		};

		// 请求权限
		if (
			(await fileHandle.queryPermission(options)) !== 'granted' &&
			(await fileHandle.requestPermission(options)) !== 'granted'
		) {
			console.error('未获得文件读写权限');
			return;
		}

		// 获取文件对象
		const file = await fileHandle.getFile();

		// 读取文件内容
		const contents = await file.text();
		console.log('文件内容:', contents);
		document.querySelector('#fileContent').value = contents;

		// 保存文件句柄以便后续使用
		window.currentFileHandle = fileHandle;

		return { fileHandle, contents };
	} catch (error) {
		// 用户取消选择不会显示错误
		if (error.name !== 'AbortError') {
			console.error('打开文件时出错:', error);
		}
	}
}

// 保存文件
async function saveFile(content) {
	try {
		let fileHandle = window.currentFileHandle;

		// 如果没有已打开的文件，则显示保存文件对话框
		if (!fileHandle) {
			fileHandle = await window.showSaveFilePicker({
				types: [
					{
						description: '文本文件',
						accept: { 'text/plain': ['.txt'] }
					}
				]
			});
		}

		// 创建可写流
		const writable = await fileHandle.createWritable();

		// 写入内容
		await writable.write(content);

		// 关闭流
		await writable.close();

		console.log('文件保存成功');
	} catch (error) {
		// 用户取消选择不会显示错误
		if (error.name !== 'AbortError') {
			console.error('保存文件时出错:', error);
		}
	}
}

// 打开目录
async function openDirectory() {
	try {
		// 显示目录选择器
		const dirHandle = await window.showDirectoryPicker();

		// 列出目录中的文件
		const files = [];
		for await (const entry of dirHandle.values()) {
			files.push({
				name: entry.name,
				kind: entry.kind, // 'file' 或 'directory'
				handle: entry
			});
		}

		console.log('目录内容:', files);
		return { dirHandle, files };
	} catch (error) {
		// 用户取消选择不会显示错误
		if (error.name !== 'AbortError') {
			console.error('打开目录时出错:', error);
		}
	}
}

// 绑定按钮事件
document.querySelector('#openFileBtn').addEventListener('click', openFile);
document.querySelector('#saveFileBtn').addEventListener('click', () => {
	const content = document.querySelector('#fileContent').value;
	saveFile(content);
});
document.querySelector('#openDirBtn').addEventListener('click', openDirectory);
```

### 使用场景

1. **文本编辑器**：创建在线文本编辑器，直接读写本地文件
2. **图像编辑器**：编辑本地图片并保存回本地文件系统
3. **开发工具**：创建在线 IDE，可以直接操作本地项目文件
4. **文件管理**：创建文件管理应用，浏览和组织本地文件
5. **离线应用**：构建可以在离线状态下处理本地文件的应用
6. **大文件处理**：处理大型文件，如视频编辑或数据分析

### 注意事项和兼容性

- 需要在安全上下文（HTTPS）中使用
- 目前主要在 Chrome 86+和基于 Chromium 的浏览器（如 Edge）中支持
- Firefox 和 Safari 尚未实现此 API
- 出于安全考虑，用户必须通过交互（如点击）明确授权访问文件
- 权限是临时的，页面刷新后需要重新获取权限
- 可以使用`FileSystemHandle.requestPermission()`方法请求持久权限
- 对于源私有文件系统（OPFS），不需要用户授权，但这些文件对用户不可见
- 文件操作是异步的，需要使用 Promise 或 async/await 处理
