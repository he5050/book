---
title: 17.浏览器的API
date: 2025-09-01 22:33:00
permalink: /notes/browser-api
description: 浏览器的API
categories:
  - 笔记
tags:
  - JS
  - 浏览器API
---

## Page Visibility API

Page Visibility API 用于检测页面是否对用户可见，以便网页在用户看不见的时候暂停或减少不必要的操作，从而节省资源。

### 基本用法

```javascript
// 检测页面可见性状态
document.addEventListener('visibilitychange', function () {
	if (document.hidden) {
		console.log('页面不可见，暂停视频播放');
		video.pause();
	} else {
		console.log('页面可见，继续视频播放');
		video.play();
	}
});

// 获取当前页面可见性
console.log(document.visibilityState); // 'visible' 或 'hidden'
```

### 使用场景

1. **暂停媒体播放**：当用户切换到其他标签页或最小化浏览器时，暂停视频或音频播放
2. **暂停动画**：当页面不可见时，暂停不必要的动画效果，减少 CPU 使用
3. **暂停轮询**：当页面不可见时，暂停数据轮询，减少网络请求
4. **统计用户行为**：记录用户查看页面的实际时间

### 音视频播放控制示例

```javascript
// 音乐播放器示例
const audioPlayer = document.getElementById('audio-player');
const playButton = document.getElementById('play-button');
let wasPlaying = false;

// 页面可见性变化时控制音频播放
document.addEventListener('visibilitychange', function () {
	if (document.hidden) {
		// 页面隐藏时，记录当前播放状态并暂停
		wasPlaying = !audioPlayer.paused;
		if (wasPlaying) {
			audioPlayer.pause();
			playButton.textContent = '播放';
		}
	} else {
		// 页面重新可见且之前正在播放，则恢复播放
		if (wasPlaying) {
			audioPlayer
				.play()
				.then(() => {
					playButton.textContent = '暂停';
				})
				.catch(error => {
					console.error('自动恢复播放失败:', error);
					// 可能是由于浏览器策略限制，需要用户交互
				});
		}
	}
});

// 处理用户交互播放/暂停
playButton.addEventListener('click', function () {
	if (audioPlayer.paused) {
		audioPlayer.play();
		playButton.textContent = '暂停';
	} else {
		audioPlayer.pause();
		playButton.textContent = '播放';
	}
});
```

### 实际应用场景

1. **视频网站**：当用户切换标签页时自动暂停视频，节省带宽并保持用户观看进度
2. **音乐流媒体**：当用户离开页面时暂停音乐播放，避免用户返回时错过内容
3. **在线课程平台**：当学习者切换到其他应用时暂停课程视频，并记录实际学习时间
4. **游戏应用**：当页面不可见时自动暂停游戏，保存游戏状态

### 注意事项和兼容性

- 所有现代浏览器都支持此 API
- 在移动设备上，当浏览器最小化或切换到其他应用时，也会触发 visibilitychange 事件
- 不要完全依赖此 API 来实现安全功能，因为它可以被恶意脚本覆盖

## Web Share API

Web Share API 允许网站调用设备的原生分享功能，使用户能够通过设备上安装的应用分享文本、链接和文件。

### 基本用法

```javascript
// 检查浏览器是否支持Web Share API
if (navigator.share) {
	// 分享文本和链接
	document.querySelector('#shareButton').addEventListener('click', async () => {
		try {
			await navigator.share({
				title: '分享标题',
				text: '分享描述文本',
				url: 'https://example.com'
			});
			console.log('分享成功');
		} catch (error) {
			console.log('分享失败:', error);
		}
	});

	// 分享文件
	document.querySelector('#shareFileButton').addEventListener('click', async () => {
		try {
			const fileInput = document.querySelector('#fileInput');
			const files = fileInput.files;

			if (files.length > 0 && navigator.canShare && navigator.canShare({ files })) {
				await navigator.share({
					files: files,
					title: '分享文件',
					text: '这是我分享的文件'
				});
				console.log('文件分享成功');
			} else {
				console.log('文件无法分享');
			}
		} catch (error) {
			console.log('分享失败:', error);
		}
	});
}
```

### 使用场景

1. **社交分享**：让用户轻松分享网页内容到社交媒体
2. **分享生成内容**：分享用户在网页上生成的内容，如图片编辑结果
3. **分享文件**：分享下载的文档、图片等文件
4. **联系人分享**：分享联系人信息到通讯录应用

### 注意事项和兼容性

- 需要在安全上下文（HTTPS）中使用
- 必须由用户手势触发（如点击事件）
- 移动设备支持较好，桌面支持有限
- 文件分享在部分浏览器中可能不支持
- 可分享的文件类型包括：图片、音频、视频、文本文件等
- 使用`navigator.canShare()`方法可以检查特定内容是否可分享

## Wake Lock API

Wake Lock API 允许网页阻止设备进入休眠状态，保持屏幕常亮。

### 基本用法

```javascript
// 声明一个全局变量来存储唤醒锁
let wakeLock = null;

// 请求屏幕唤醒锁
async function requestWakeLock() {
	try {
		// 检查浏览器是否支持Wake Lock API
		if ('wakeLock' in navigator) {
			// 请求屏幕唤醒锁
			wakeLock = await navigator.wakeLock.request('screen');

			console.log('唤醒锁激活');

			// 监听唤醒锁释放事件
			wakeLock.addEventListener('release', () => {
				console.log('唤醒锁已释放');
				wakeLock = null;
			});

			// 当页面可见性变化时重新请求唤醒锁
			document.addEventListener('visibilitychange', async () => {
				if (document.visibilityState === 'visible' && !wakeLock) {
					wakeLock = await navigator.wakeLock.request('screen');
				}
			});
		}
	} catch (error) {
		console.error('请求唤醒锁失败:', error);
	}
}

// 释放唤醒锁
function releaseWakeLock() {
	if (wakeLock) {
		wakeLock.release().then(() => {
			console.log('唤醒锁已手动释放');
			wakeLock = null;
		});
	}
}

// 在用户交互时请求唤醒锁
document.querySelector('#enableWakeLock').addEventListener('click', requestWakeLock);
document.querySelector('#disableWakeLock').addEventListener('click', releaseWakeLock);
```

### 使用场景

1. **长时间阅读**：阅读长文章或电子书时保持屏幕常亮
2. **演示应用**：进行演示或展示时防止屏幕关闭
3. **导航应用**：使用地图导航时保持屏幕常亮
4. **游戏应用**：玩游戏时防止屏幕自动锁定

### 注意事项和兼容性

- 需要在安全上下文（HTTPS）中使用
- 当页面不可见或不活跃时，唤醒锁会自动释放
- 设备电量低时，系统可能会忽略唤醒锁请求
- 目前主要在 Chrome 和基于 Chromium 的浏览器中支持
- 使用时应考虑电池消耗，仅在必要时启用
- 页面可见性变化时需要重新请求唤醒锁

## Broadcast Channel API

Broadcast Channel API 允许同源的不同浏览上下文（如不同标签页、iframe 或 worker）之间进行通信。

### 基本用法

```javascript
// 创建或加入一个广播频道
const channel = new BroadcastChannel('app_channel');

// 发送消息
function sendMessage() {
	const message = document.querySelector('#messageInput').value;
	channel.postMessage({
		type: 'chat',
		data: message,
		sender: 'Tab ' + Math.floor(Math.random() * 1000),
		timestamp: Date.now()
	});
}

// 接收消息
channel.onmessage = event => {
	const message = event.data;
	console.log(`收到消息: ${JSON.stringify(message)}`);

	// 处理接收到的消息
	const messagesList = document.querySelector('#messagesList');
	const messageItem = document.createElement('li');
	messageItem.textContent = `${message.sender}: ${message.data}`;
	messagesList.appendChild(messageItem);
};

// 关闭频道连接
function closeChannel() {
	channel.close();
	console.log('广播频道已关闭');
}

// 在页面卸载时关闭频道
window.addEventListener('unload', closeChannel);

// 绑定发送按钮事件
document.querySelector('#sendButton').addEventListener('click', sendMessage);
```

### 使用场景

1. **多标签页同步**：在多个标签页之间同步用户操作或状态
2. **实时通知**：向所有打开的页面广播通知或更新
3. **共享数据**：在不同标签页之间共享数据，避免重复请求
4. **协同编辑**：实现简单的协同编辑功能
5. **登录状态同步**：一个标签页登录或登出时，同步更新其他标签页

### 注意事项和兼容性

- 仅限于同源页面之间通信（相同的协议、域名和端口）
- 支持传输任何可被结构化克隆算法序列化的数据
- 大多数现代浏览器都支持此 API，但 IE 不支持
- 消息是广播的，所有监听同一频道的上下文都会收到消息
- 当不再需要通信时，应调用`close()`方法释放资源
- 相比于其他通信方式（如 LocalStorage 事件），Broadcast Channel API 更可靠、更高效

## PerformanceObserver API

PerformanceObserver API 允许监测性能度量事件，在浏览器的性能时间轴记录新的 performance entry 时通知开发者。

### 基本用法

```javascript
// 创建性能观察器
const observer = new PerformanceObserver(list => {
	// 获取并处理性能条目
	const entries = list.getEntries();
	entries.forEach(entry => {
		console.log(`性能条目: ${entry.name}`, entry);
	});
});

// 开始观察特定类型的性能条目
observer.observe({ entryTypes: ['mark', 'measure'] });

// 创建性能标记
performance.mark('start_process');

// 模拟一些操作
setTimeout(() => {
	// 创建另一个性能标记
	performance.mark('end_process');

	// 测量两个标记之间的时间
	performance.measure('process_duration', 'start_process', 'end_process');

	// 获取测量结果
	const measure = performance.getEntriesByName('process_duration')[0];
	console.log(`处理耗时: ${measure.duration}ms`);

	// 停止观察
	// observer.disconnect();
}, 1000);

// 观察资源加载性能
const resourceObserver = new PerformanceObserver(list => {
	const resources = list.getEntries();
	resources.forEach(resource => {
		console.log(`资源 ${resource.name} 加载耗时: ${resource.duration}ms`);
	});
});

resourceObserver.observe({ entryTypes: ['resource'] });
```

### 使用场景

1. **性能监控**：监控页面加载、资源加载、JavaScript 执行等性能指标
2. **用户体验分析**：收集真实用户的性能数据，分析用户体验
3. **性能预算监控**：设置性能预算，当性能指标超出预期时发出警告
4. **自定义性能测量**：使用 mark 和 measure 测量特定代码块的执行时间
5. **识别性能瓶颈**：分析长任务和阻塞渲染的操作

### 注意事项和兼容性

- 大多数现代浏览器都支持此 API
- 不同类型的性能条目在不同浏览器中的支持程度可能不同
- 观察某些类型的条目可能需要特定的权限或设置
- 性能数据收集可能会对性能本身产生轻微影响
- 建议在生产环境中谨慎使用，可以考虑采样收集数据
- 可以使用`takeRecords()`方法获取尚未处理的性能条目

## requestIdleCallback API

requestIdleCallback API 允许在浏览器空闲时期调度执行低优先级的任务，而不会影响关键事件如动画和用户交互。

### 基本用法

```javascript
// 定义一个需要在空闲时执行的任务
function doNonEssentialWork(deadline) {
	// 检查是否有剩余时间
	while (deadline.timeRemaining() > 0 || deadline.didTimeout) {
		// 执行一小块工作
		doWorkIfNeeded();

		// 如果还有更多工作要做，但时间不够了，重新调度
		if (thereIsMoreWorkToDo) {
			requestIdleCallback(doNonEssentialWork, { timeout: 1000 });
			break;
		}
	}
}

// 模拟一个工作单元
let workUnits = Array(50)
	.fill()
	.map((_, i) => i);
let currentWorkIndex = 0;
let thereIsMoreWorkToDo = true;

function doWorkIfNeeded() {
	if (currentWorkIndex < workUnits.length) {
		const work = workUnits[currentWorkIndex++];
		console.log(`执行工作单元: ${work}`);

		// 模拟工作完成
		if (currentWorkIndex >= workUnits.length) {
			thereIsMoreWorkToDo = false;
			console.log('所有工作完成');
		}
	}
}

// 调度任务在浏览器空闲时执行
// timeout 选项确保即使浏览器一直很忙，任务也会在1秒后执行
requestIdleCallback(doNonEssentialWork, { timeout: 1000 });

// 取消已调度的回调
const handle = requestIdleCallback(someFunction);
cancelIdleCallback(handle); // 取消调度
```

### 使用场景

1. **数据预取**：在用户不活跃时预取可能需要的数据
2. **延迟加载**：延迟加载非关键资源或组件
3. **后台计算**：执行复杂计算但不阻塞主线程
4. **垃圾回收**：清理不再需要的内存或资源
5. **数据分析和上报**：收集和处理分析数据并发送到服务器

### 注意事项和兼容性

- Chrome、Firefox 和 Edge 支持此 API，但 Safari 不支持
- 回调函数接收一个`IdleDeadline`对象，包含`timeRemaining()`方法和`didTimeout`属性
- `timeRemaining()`返回的时间以毫秒为单位，通常在 0-50ms 之间
- 不要在回调中执行 DOM 操作，因为可能会触发重新渲染
- 对于需要在下一帧之前完成的任务，应使用`requestAnimationFrame`而非`requestIdleCallback`
- 可以使用 polyfill 在不支持的浏览器中模拟此功能
- 设置`timeout`选项可确保任务最终会执行，即使浏览器一直很忙

## scheduler.postTask API

scheduler.postTask API 提供了一种更精细的任务调度机制，允许开发者根据任务的优先级和时间安排来调度任务执行。

### 基本用法

```javascript
// 检查浏览器是否支持scheduler API
if ('scheduler' in window && 'postTask' in window.scheduler) {
	// 调度一个任务
	scheduler
		.postTask(() => {
			console.log('执行标准优先级任务');
			performTask();
		})
		.then(() => {
			console.log('任务已完成');
		})
		.catch(error => {
			console.error('任务执行失败:', error);
		});

	// 调度一个高优先级任务
	scheduler.postTask(
		() => {
			console.log('执行用户阻塞任务');
			handleUserInput();
		},
		{ priority: 'user-blocking' }
	);

	// 调度一个低优先级任务
	scheduler.postTask(
		() => {
			console.log('执行后台任务');
			processDataInBackground();
		},
		{ priority: 'background' }
	);

	// 调度一个延迟任务
	scheduler.postTask(
		() => {
			console.log('执行延迟任务');
		},
		{ delay: 2000 }
	); // 2秒后执行

	// 创建一个可以取消的任务
	const controller = new AbortController();
	const { signal } = controller;

	const taskPromise = scheduler.postTask(
		() => {
			console.log('执行可取消任务');
			processLargeData();
		},
		{ signal }
	);

	// 在某些条件下取消任务
	setTimeout(() => {
		controller.abort();
		console.log('任务已取消');
	}, 1000);
}
```

### 使用场景

1. **用户交互处理**：使用高优先级处理用户输入和交互
2. **数据处理**：在后台低优先级处理大量数据
3. **UI 更新**：根据优先级调度不同部分的 UI 更新
4. **资源加载**：根据重要性调度资源加载任务
5. **定时任务**：替代 setTimeout 实现更可靠的定时任务

### 注意事项和兼容性

- 目前主要在 Chrome 94+和基于 Chromium 的浏览器中支持
- 任务优先级分为三级：`'user-blocking'`（最高）、`'user-visible'`（默认）和`'background'`（最低）
- 返回 Promise 对象，可以使用 then/catch 处理任务完成或失败
- 可以使用 AbortController 取消尚未执行的任务
- delay 参数允许设置任务延迟执行的时间（毫秒）
- 相比于 setTimeout，scheduler.postTask 提供了更精确的任务调度和优先级控制
- 在不支持的浏览器中，可以使用 polyfill 或回退到 setTimeout

## AbortController API

AbortController API 提供了一种标准方式来取消一个或多个异步操作，如 fetch 请求、动画或任何其他可取消的操作。

### 基本用法

```javascript
// 创建一个AbortController实例
const controller = new AbortController();
const signal = controller.signal;

// 使用signal发起fetch请求
fetch('https://api.example.com/data', { signal })
	.then(response => response.json())
	.then(data => console.log('获取的数据:', data))
	.catch(error => {
		if (error.name === 'AbortError') {
			console.log('请求被取消');
		} else {
			console.error('请求失败:', error);
		}
	});

// 在某个条件下取消请求
setTimeout(() => {
	controller.abort();
	console.log('请求已取消');
}, 5000); // 5秒后取消请求

// 取消多个操作
const multiController = new AbortController();
const multiSignal = multiController.signal;

// 多个fetch请求共享同一个signal
const fetchUsers = fetch('/api/users', { signal: multiSignal });
const fetchProducts = fetch('/api/products', { signal: multiSignal });

// 同时取消所有请求
document.querySelector('#cancelButton').addEventListener('click', () => {
	multiController.abort();
});

// 使用AbortSignal.timeout()创建一个会自动超时的信号
if ('timeout' in AbortSignal) {
	const timeoutSignal = AbortSignal.timeout(10000); // 10秒超时

	fetch('/api/data', { signal: timeoutSignal })
		.then(response => response.json())
		.then(data => console.log(data))
		.catch(error => {
			if (error.name === 'AbortError') {
				console.log('请求超时自动取消');
			}
		});
}
```

### 使用场景

1. **取消网络请求**：当用户导航离开页面或取消操作时，终止进行中的 fetch 请求
2. **超时处理**：为长时间运行的请求设置超时限制
3. **取消动画**：停止正在进行的动画或过渡效果
4. **资源清理**：在组件卸载时取消所有相关的异步操作
5. **用户交互响应**：响应用户取消操作的请求

### 注意事项和兼容性

- 所有现代浏览器都支持此 API
- `abort()`方法可以接收一个参数作为取消原因，通过`signal.reason`访问
- 被取消的 Promise 会以 AbortError 拒绝，应在 catch 中处理
- 可以使用`signal.addEventListener('abort', callback)`监听取消事件
- `signal.aborted`属性表示信号是否已被取消
- 对于不支持 AbortController 的旧版浏览器，可以使用 polyfill
- 取消 HTTP 请求时，虽然客户端不再等待响应，但服务器可能仍会完成请求处理

## File System Access API

File System Access API 允许网页应用直接读取、写入和管理用户本地设备上的文件，提供了类似本地应用的文件操作体验。

### 基本用法

```javascript
// 打开文件
async function openFile() {
	try {
		// 显示文件选择器
		const [fileHandle] = await window.showOpenFilePicker({
			multiple: false, // 只选择一个文件
			types: [
				{
					description: '文本文件',
					accept: {
						'text/plain': ['.txt', '.md']
					}
				}
			]
		});

		// 获取文件权限
		const options = {
			writable: true,
			mode: 'readwrite'
		};

		// 请求权限
		if (
			(await fileHandle.queryPermission(options)) !== 'granted' &&
			(await fileHandle.requestPermission(options)) !== 'granted'
		) {
			console.error('未获得文件读写权限');
			return;
		}

		// 获取文件对象
		const file = await fileHandle.getFile();

		// 读取文件内容
		const contents = await file.text();
		console.log('文件内容:', contents);
		document.querySelector('#fileContent').value = contents;

		// 保存文件句柄以便后续使用
		window.currentFileHandle = fileHandle;

		return { fileHandle, contents };
	} catch (error) {
		// 用户取消选择不会显示错误
		if (error.name !== 'AbortError') {
			console.error('打开文件时出错:', error);
		}
	}
}

// 保存文件
async function saveFile(content) {
	try {
		let fileHandle = window.currentFileHandle;

		// 如果没有已打开的文件，则显示保存文件对话框
		if (!fileHandle) {
			fileHandle = await window.showSaveFilePicker({
				types: [
					{
						description: '文本文件',
						accept: { 'text/plain': ['.txt'] }
					}
				]
			});
		}

		// 创建可写流
		const writable = await fileHandle.createWritable();

		// 写入内容
		await writable.write(content);

		// 关闭流
		await writable.close();

		console.log('文件保存成功');
	} catch (error) {
		// 用户取消选择不会显示错误
		if (error.name !== 'AbortError') {
			console.error('保存文件时出错:', error);
		}
	}
}

// 打开目录
async function openDirectory() {
	try {
		// 显示目录选择器
		const dirHandle = await window.showDirectoryPicker();

		// 列出目录中的文件
		const files = [];
		for await (const entry of dirHandle.values()) {
			files.push({
				name: entry.name,
				kind: entry.kind, // 'file' 或 'directory'
				handle: entry
			});
		}

		console.log('目录内容:', files);
		return { dirHandle, files };
	} catch (error) {
		// 用户取消选择不会显示错误
		if (error.name !== 'AbortError') {
			console.error('打开目录时出错:', error);
		}
	}
}

// 绑定按钮事件
document.querySelector('#openFileBtn').addEventListener('click', openFile);
document.querySelector('#saveFileBtn').addEventListener('click', () => {
	const content = document.querySelector('#fileContent').value;
	saveFile(content);
});
document.querySelector('#openDirBtn').addEventListener('click', openDirectory);
```

### 使用场景

1. **文本编辑器**：创建在线文本编辑器，直接读写本地文件
2. **图像编辑器**：编辑本地图片并保存回本地文件系统
3. **开发工具**：创建在线 IDE，可以直接操作本地项目文件
4. **文件管理**：创建文件管理应用，浏览和组织本地文件
5. **离线应用**：构建可以在离线状态下处理本地文件的应用
6. **大文件处理**：处理大型文件，如视频编辑或数据分析

### 注意事项和兼容性

- 需要在安全上下文（HTTPS）中使用
- 目前主要在 Chrome 86+和基于 Chromium 的浏览器（如 Edge）中支持
- Firefox 和 Safari 尚未实现此 API
- 出于安全考虑，用户必须通过交互（如点击）明确授权访问文件
- 权限是临时的，页面刷新后需要重新获取权限
- 可以使用`FileSystemHandle.requestPermission()`方法请求持久权限
- 对于源私有文件系统（OPFS），不需要用户授权，但这些文件对用户不可见
- 文件操作是异步的，需要使用 Promise 或 async/await 处理
```

## WebCodecs API

WebCodecs API 提供了对浏览器内置编解码器的底层访问，允许开发者直接处理视频帧、音频数据块和编解码器，适用于需要精细控制媒体处理的应用场景。

### 基本用法

```javascript
// 视频解码示例
async function decodeVideoChunk(videoChunk) {
  // 创建视频解码器
  const videoDecoder = new VideoDecoder({
    output: processDecodedFrame, // 处理解码后的帧的回调
    error: (error) => console.error("解码错误:", error)
  });
  
  // 配置解码器
  const config = {
    codec: "vp8", // 视频编解码器
    codedWidth: 640,
    codedHeight: 480
  };
  
  // 初始化解码器
  videoDecoder.configure(config);
  
  // 解码视频块
  videoDecoder.decode(videoChunk);
  
  // 处理解码后的帧
  function processDecodedFrame(frame) {
    // 获取帧数据
    console.log(`接收到帧 ${frame.timestamp}，分辨率: ${frame.codedWidth}x${frame.codedHeight}`);
    
    // 在Canvas上渲染帧
    const canvas = document.getElementById('videoCanvas');
    const ctx = canvas.getContext('2d');
    ctx.drawImage(frame, 0, 0);
    
    // 释放帧资源
    frame.close();
  }
}

// 音频解码示例
async function decodeAudioChunk(audioChunk) {
  // 创建音频解码器
  const audioDecoder = new AudioDecoder({
    output: processDecodedAudio, // 处理解码后的音频数据的回调
    error: (error) => console.error("解码错误:", error)
  });
  
  // 配置解码器
  const config = {
    codec: "opus", // 音频编解码器
    sampleRate: 48000,
    numberOfChannels: 2
  };
  
  // 初始化解码器
  audioDecoder.configure(config);
  
  // 解码音频块
  audioDecoder.decode(audioChunk);
  
  // 处理解码后的音频数据
  function processDecodedAudio(audioData) {
    console.log(`接收到音频数据 ${audioData.timestamp}, 时长: ${audioData.duration}`);
    
    // 处理音频数据
    const numChannels = audioData.numberOfChannels;
    const numSamples = audioData.numberOfFrames;
    
    // 获取音频样本
    const audioBuffer = new Float32Array(numSamples);
    audioData.copyTo(audioBuffer);
    
    // 释放音频数据资源
    audioData.close();
  }
}

// 视频编码示例
async function encodeVideoFrame(frame) {
  // 创建视频编码器
  const videoEncoder = new VideoEncoder({
    output: processEncodedChunk, // 处理编码后的块的回调
    error: (error) => console.error("编码错误:", error)
  });
  
  // 配置编码器
  const config = {
    codec: "vp8",
    width: 640,
    height: 480,
    bitrate: 2_000_000, // 2 Mbps
    framerate: 30
  };
  
  // 初始化编码器
  videoEncoder.configure(config);
  
  // 编码视频帧
  videoEncoder.encode(frame, { keyFrame: true });
  
  // 处理编码后的块
  function processEncodedChunk(chunk) {
    console.log(`接收到编码块 ${chunk.timestamp}, 类型: ${chunk.type}`);
    
    // 处理编码后的数据
    // 例如，将其存储或通过WebRTC发送
  }
}
```

### 使用场景

1. **视频会议和直播**：低延迟处理视频和音频流
2. **云游戏**：高效处理视频流和用户输入
3. **视频编辑**：在浏览器中进行视频剪辑和处理
4. **媒体转码**：在客户端转换媒体格式
5. **增强现实**：实时处理摄像头输入并添加效果
6. **机器学习**：将视频帧输入到ML模型进行分析

### 注意事项和兼容性

- 目前在Chrome 94+和基于Chromium的浏览器中支持
- Firefox和Safari尚未完全实现此API
- 处理媒体数据需要大量计算资源，应注意性能影响
- 视频和音频帧需要手动释放（调用`close()`方法）以避免内存泄漏
- 编解码器支持因浏览器而异，应检查`isConfigSupported()`方法
- 适合需要精细控制媒体处理的高级应用场景
- 对于简单的媒体播放，MediaElement API（如`<video>`和`<audio>`）更为合适
- 可以与Canvas、WebGL和WebRTC等技术结合使用

## EyeDropper API

EyeDropper API 允许网页应用提供拾色器功能，使用户能够从屏幕上的任何位置选择颜色。

### 基本用法

```javascript
// 检查浏览器是否支持EyeDropper API
if ('EyeDropper' in window) {
  // 创建拾色器按钮
  const button = document.createElement('button');
  button.textContent = '从屏幕选择颜色';
  document.body.appendChild(button);
  
  // 创建显示选中颜色的元素
  const colorDisplay = document.createElement('div');
  colorDisplay.style.marginTop = '20px';
  colorDisplay.style.display = 'flex';
  colorDisplay.style.alignItems = 'center';
  document.body.appendChild(colorDisplay);
  
  // 颜色预览框
  const colorPreview = document.createElement('div');
  colorPreview.style.width = '50px';
  colorPreview.style.height = '50px';
  colorPreview.style.border = '1px solid #ccc';
  colorPreview.style.marginRight = '10px';
  colorDisplay.appendChild(colorPreview);
  
  // 颜色值文本
  const colorValue = document.createElement('span');
  colorDisplay.appendChild(colorValue);
  
  // 绑定点击事件
  button.addEventListener('click', async () => {
    try {
      // 创建EyeDropper实例
      const eyeDropper = new EyeDropper();
      
      // 打开拾色器并等待用户选择颜色
      const result = await eyeDropper.open();
      
      // 获取选中的颜色
      const selectedColor = result.sRGBHex;
      
      // 显示选中的颜色
      colorPreview.style.backgroundColor = selectedColor;
      colorValue.textContent = selectedColor;
      
      // 可以将颜色值应用到其他元素或保存
      console.log('选中的颜色:', selectedColor);
    } catch (error) {
      // 用户取消选择或发生错误
      if (error.name !== 'AbortError') {
        console.error('选择颜色时出错:', error);
      } else {
        console.log('用户取消了颜色选择');
      }
    }
  });
  
  // 使用AbortController取消拾色器示例
  const abortButton = document.createElement('button');
  abortButton.textContent = '取消选择';
  abortButton.style.marginLeft = '10px';
  document.body.insertBefore(abortButton, colorDisplay);
  
  abortButton.addEventListener('click', () => {
    if (window.currentEyeDropperController) {
      window.currentEyeDropperController.abort();
      console.log('已取消颜色选择');
    }
  });
  
  button.addEventListener('click', async () => {
    try {
      // 创建AbortController
      const controller = new AbortController();
      window.currentEyeDropperController = controller;
      
      const eyeDropper = new EyeDropper();
      const result = await eyeDropper.open({ signal: controller.signal });
      
      // 清除当前控制器引用
      window.currentEyeDropperController = null;
      
      // 处理选中的颜色
      colorPreview.style.backgroundColor = result.sRGBHex;
      colorValue.textContent = result.sRGBHex;
    } catch (error) {
      window.currentEyeDropperController = null;
      
      if (error.name !== 'AbortError') {
        console.error('选择颜色时出错:', error);
      } else {
        console.log('颜色选择已取消');
      }
    }
  });
} else {
  console.log('此浏览器不支持EyeDropper API');
}
```

### 使用场景

1. **设计工具**：允许用户从参考图像或界面中选择颜色
2. **主题定制**：让用户从现有内容中选择颜色来自定义应用主题
3. **图像编辑器**：提供拾色器工具来选择和匹配颜色
4. **绘图应用**：让用户从现实世界或其他图像中采样颜色
5. **辅助功能工具**：分析屏幕上的颜色以检查对比度和可访问性

### 注意事项和兼容性

- 目前在Chrome 95+、Edge 95+和其他基于Chromium的浏览器中支持
- Firefox和Safari尚未实现此API
- 出于安全和隐私考虑，拾色器必须由用户交互触发（如点击按钮）
- 用户可以按ESC键取消颜色选择
- 可以使用AbortController取消正在进行的颜色选择
- 返回的颜色格式为sRGB十六进制值（如"#34c0eb"）
- 拾色器激活时会显示明显的UI指示器，让用户知道拾色模式已激活
- 在不支持的浏览器中，应提供备选的颜色选择方式（如颜色输入框）

## Intl.NumberFormat API

Intl.NumberFormat API 提供了强大的数字格式化功能，支持各种语言和地区的数字表示方式，包括货币、百分比、单位和其他自定义格式。

### 基本用法

```javascript
// 基本数字格式化
const number = 1234567.89;

// 使用浏览器默认语言环境格式化
const formatter = new Intl.NumberFormat();
console.log(formatter.format(number)); // 例如在中文环境: 1,234,567.89

// 指定语言环境
const formatterUS = new Intl.NumberFormat('en-US');
console.log(formatterUS.format(number)); // 1,234,567.89

const formatterDE = new Intl.NumberFormat('de-DE');
console.log(formatterDE.format(number)); // 1.234.567,89

const formatterCN = new Intl.NumberFormat('zh-CN');
console.log(formatterCN.format(number)); // 1,234,567.89

// 货币格式化
const price = 123.45;

const usdFormatter = new Intl.NumberFormat('en-US', {
  style: 'currency',
  currency: 'USD'
});
console.log(usdFormatter.format(price)); // $123.45

const eurFormatter = new Intl.NumberFormat('de-DE', {
  style: 'currency',
  currency: 'EUR'
});
console.log(eurFormatter.format(price)); // 123,45 €

const cnyFormatter = new Intl.NumberFormat('zh-CN', {
  style: 'currency',
  currency: 'CNY'
});
console.log(cnyFormatter.format(price)); // ¥123.45

// 百分比格式化
const percentage = 0.2345;

const percentFormatter = new Intl.NumberFormat('zh-CN', {
  style: 'percent',
  minimumFractionDigits: 1,
  maximumFractionDigits: 2
});
console.log(percentFormatter.format(percentage)); // 23.5%

// 单位格式化
if (Intl.NumberFormat.prototype.formatToParts) {
  const distance = 5000;
  
  const meterFormatter = new Intl.NumberFormat('zh-CN', {
    style: 'unit',
    unit: 'meter',
    unitDisplay: 'long'
  });
  console.log(meterFormatter.format(distance)); // 5,000米
  
  const kilometerFormatter = new Intl.NumberFormat('zh-CN', {
    style: 'unit',
    unit: 'kilometer',
    unitDisplay: 'long',
    maximumFractionDigits: 1
  });
  console.log(kilometerFormatter.format(distance / 1000)); // 5千米
}

// 数字表示法
const largeNumber = 1234567.89;

// 科学计数法
const scientificFormatter = new Intl.NumberFormat('zh-CN', {
  notation: 'scientific'
});
console.log(scientificFormatter.format(largeNumber)); // 1.235E6

// 工程计数法
const engineeringFormatter = new Intl.NumberFormat('zh-CN', {
  notation: 'engineering'
});
console.log(engineeringFormatter.format(largeNumber)); // 1.235E6

// 紧凑表示法
const compactFormatter = new Intl.NumberFormat('zh-CN', {
  notation: 'compact',
  compactDisplay: 'short'
});
console.log(compactFormatter.format(largeNumber)); // 123万
console.log(compactFormatter.format(1234567890)); // 12亿

// 格式化为部分
if (Intl.NumberFormat.prototype.formatToParts) {
  const formatter = new Intl.NumberFormat('zh-CN', {
    style: 'currency',
    currency: 'CNY'
  });
  
  const parts = formatter.formatToParts(number);
  console.log(parts);
  // 输出类似: [
  //   { type: 'currency', value: '¥' },
  //   { type: 'integer', value: '1' },
  //   { type: 'group', value: ',' },
  //   { type: 'integer', value: '234' },
  //   ...
  // ]
}

// 格式化范围
if (Intl.NumberFormat.prototype.formatRange) {
  const rangeFormatter = new Intl.NumberFormat('zh-CN', {
    style: 'currency',
    currency: 'CNY'
  });
  
  console.log(rangeFormatter.formatRange(3, 5)); // ¥3.00–¥5.00
}
```

### 使用场景

1. **电子商务**：格式化不同货币的价格和折扣
2. **数据可视化**：以本地化格式显示数值数据
3. **金融应用**：格式化货币、百分比和大数字
4. **国际化应用**：根据用户区域设置格式化数字
5. **科学和技术应用**：格式化带单位的测量值
6. **社交媒体**：以紧凑形式显示大数字（如点赞数、关注者数）

### 注意事项和兼容性

- 所有现代浏览器都支持基本的Intl.NumberFormat功能
- 更高级的功能（如单位格式化、紧凑表示法）在较新的浏览器中支持
- 格式化结果取决于用户的浏览器语言设置和指定的locale
- 对于不支持某些功能的浏览器，应提供回退方案
- 货币格式化不会执行货币转换，只是格式化显示
- 使用`formatToParts()`方法可以获取格式化结果的各个部分，便于自定义显示
- 使用`resolvedOptions()`方法可以查看实际使用的格式化选项
- 对于需要精确数值计算的场景（如金融计算），应使用专门的库来处理浮点数精度问题

## structuredClone API

structuredClone API 提供了一种深度克隆 JavaScript 对象的标准方法，可以正确处理循环引用和大多数内置类型，比传统的 JSON 序列化和反序列化方法更强大。

### 基本用法

```javascript
// 基本对象克隆
const originalObject = {
  name: "张三",
  age: 30,
  hobbies: ["阅读", "编程", "旅行"],
  address: {
    city: "北京",
    district: "海淀区"
  }
};

// 使用structuredClone深度克隆对象
const clonedObject = structuredClone(originalObject);

// 修改克隆对象不会影响原始对象
clonedObject.name = "李四";
clonedObject.hobbies.push("游泳");
clonedObject.address.city = "上海";

console.log("原始对象:", originalObject);
// 输出: { name: "张三", age: 30, hobbies: ["阅读", "编程", "旅行"], address: { city: "北京", district: "海淀区" } }

console.log("克隆对象:", clonedObject);
// 输出: { name: "李四", age: 30, hobbies: ["阅读", "编程", "旅行", "游泳"], address: { city: "上海", district: "海淀区" } }

// 处理循环引用
const circularObject = {
  name: "循环引用对象",
  self: null
};

// 创建循环引用
circularObject.self = circularObject;

// 使用structuredClone可以正确克隆循环引用
const clonedCircular = structuredClone(circularObject);

console.log(clonedCircular.self === clonedCircular); // true，保留了循环引用结构
console.log(clonedCircular !== circularObject); // true，是一个新对象

// 克隆包含特殊类型的对象
const complexObject = {
  date: new Date(),
  regex: /pattern/g,
  map: new Map([["key1", "value1"], ["key2", "value2"]]),
  set: new Set([1, 2, 3]),
  typedArray: new Uint8Array([1, 2, 3, 4]),
  arrayBuffer: new ArrayBuffer(8),
  dataView: new DataView(new ArrayBuffer(16)),
  blob: new Blob(["content"], { type: "text/plain" }),
  imageData: null // 在Canvas上下文中可以获取ImageData
};

// 克隆复杂对象
const clonedComplex = structuredClone(complexObject);

console.log("原始日期:", complexObject.date);
console.log("克隆日期:", clonedComplex.date);
console.log("日期是否相同对象:", complexObject.date === clonedComplex.date); // false

// 使用转移功能（仅适用于可转移对象如ArrayBuffer）
const bufferSource = new ArrayBuffer(16);
const int32View = new Int32Array(bufferSource);
int32View[0] = 42;

const sourceObject = {
  buffer: bufferSource,
  message: "包含可转移对象的对象"
};

// 使用转移选项克隆对象
const clonedWithTransfer = structuredClone(sourceObject, {
  transfer: [bufferSource]
});

console.log("转移后的克隆对象:", clonedWithTransfer);
// 原始bufferSource现在已被清空，不能再使用
console.log("原始buffer长度:", bufferSource.byteLength); // 0，已被转移
console.log("克隆buffer长度:", clonedWithTransfer.buffer.byteLength); // 16
```

### 使用场景

1. **状态管理**：在不可变状态管理中创建对象的深拷贝
2. **缓存数据**：在存储数据到缓存前创建深拷贝
3. **Web Workers通信**：在主线程和工作线程之间传递复杂数据结构
4. **撤销/重做功能**：保存对象状态的快照用于历史记录
5. **避免副作用**：在修改对象前创建副本以避免意外修改原始数据
6. **大型数据处理**：使用转移选项高效传递大型二进制数据

### 注意事项和兼容性

- 所有现代浏览器（Chrome 98+、Firefox 94+、Safari 15.4+、Edge 98+）都支持此API
- 不能克隆函数、DOM节点、类实例的方法和原型链
- 可以克隆的内置类型包括：Array、ArrayBuffer、Boolean、DataView、Date、Error类型、Map、Object、RegExp、Set、String、TypedArray
- 对于不支持的浏览器，可以使用polyfill或回退到其他深拷贝方法
- 相比JSON.parse(JSON.stringify())方法，structuredClone可以处理循环引用、日期、正则表达式等特殊对象
- 使用transfer选项可以高效传输大型ArrayBuffer，但会使源对象中的相应缓冲区变为不可用
- 对于需要保留原型链或函数的场景，structuredClone不适用，需要考虑其他序列化方案
- 克隆大型复杂对象可能会影响性能，应谨慎使用

## URLSearchParams API

URLSearchParams API 提供了一种简单的方式来处理URL的查询字符串部分，支持解析、操作和序列化URL参数。

### 基本用法

```javascript
// 从字符串创建URLSearchParams
const searchParams = new URLSearchParams("name=张三&age=30&hobby=阅读&hobby=编程");

// 从URL获取查询参数
const url = new URL("https://example.com/search?category=books&sort=price&instock=true");
const urlParams = url.searchParams;

// 从对象创建URLSearchParams
const paramsFromObject = new URLSearchParams({
  name: "李四",
  age: 25,
  city: "上海"
});

// 获取参数值
console.log(searchParams.get("name")); // "张三"
console.log(searchParams.get("age")); // "30"

// 获取所有同名参数值
console.log(searchParams.getAll("hobby")); // ["阅读", "编程"]

// 检查参数是否存在
console.log(searchParams.has("name")); // true
console.log(searchParams.has("email")); // false

// 设置参数值（添加新参数或更新现有参数）
searchParams.set("age", "31");
searchParams.set("email", "zhangsan@example.com");

// 添加参数（不覆盖现有值）
searchParams.append("hobby", "旅行");
console.log(searchParams.getAll("hobby")); // ["阅读", "编程", "旅行"]

// 删除参数
searchParams.delete("age");
console.log(searchParams.has("age")); // false

// 遍历所有参数
for (const [key, value] of searchParams.entries()) {
  console.log(`${key}: ${value}`);
}

// 获取所有键
for (const key of searchParams.keys()) {
  console.log(key);
}

// 获取所有值
for (const value of searchParams.values()) {
  console.log(value);
}

// 将参数转换为查询字符串
const queryString = searchParams.toString();
console.log(queryString); // "name=张三&hobby=阅读&hobby=编程&email=zhangsan%40example.com&hobby=旅行"

// 排序参数（按键名排序）
searchParams.sort();
console.log(searchParams.toString());

// 与URL对象结合使用
const baseUrl = "https://example.com/search";
const finalUrl = `${baseUrl}?${searchParams.toString()}`;
console.log(finalUrl);

// 或者使用URL对象
const urlObject = new URL("https://example.com/search");
urlObject.search = searchParams.toString();
console.log(urlObject.href);

// 更简洁的方式
const urlObject2 = new URL("https://example.com/search");
urlObject2.searchParams.set("name", "张三");
urlObject2.searchParams.append("hobby", "阅读");
urlObject2.searchParams.append("hobby", "编程");
console.log(urlObject2.href);
```

### 使用场景

1. **表单处理**：将表单数据转换为URL查询参数
2. **API请求构建**：构建包含多个参数的API请求URL
3. **URL解析**：解析和提取URL中的查询参数
4. **过滤和排序**：处理包含过滤和排序参数的URL
5. **分页导航**：管理分页参数（如页码、每页项目数）
6. **状态保存**：将应用状态编码到URL中以支持书签和共享

### 注意事项和兼容性

- 所有现代浏览器都支持此API
- 参数值会自动进行URL编码，无需手动调用encodeURIComponent()
- 参数名区分大小写
- 可以有多个同名参数（使用append方法添加）
- 参数值始终以字符串形式存储，即使设置的是数字或布尔值
- 使用toString()方法获取的查询字符串不包含前导问号（?）
- 与URL对象结合使用时特别有用
- 对于不支持的旧浏览器，可以使用polyfill
- 排序方法按键名的Unicode码点排序，而不是按字母顺序
- 空值参数会被保留（如"param="），但undefined值会被忽略

## Clipboard API

Clipboard API 提供了一种安全的方式来访问和修改系统剪贴板的内容，支持文本、图像和其他数据类型。

### 基本用法

```javascript
// 检查浏览器是否支持Clipboard API
if (navigator.clipboard) {
  // 写入文本到剪贴板
  async function copyTextToClipboard(text) {
    try {
      await navigator.clipboard.writeText(text);
      console.log('文本已成功复制到剪贴板');
    } catch (err) {
      console.error('复制文本失败:', err);
    }
  }
  
  // 从剪贴板读取文本
  async function readTextFromClipboard() {
    try {
      const text = await navigator.clipboard.readText();
      console.log('从剪贴板读取的文本:', text);
      return text;
    } catch (err) {
      console.error('读取剪贴板文本失败:', err);
    }
  }
  
  // 写入复杂数据到剪贴板
  async function copyComplexDataToClipboard() {
    try {
      // 创建一个包含文本和图像的剪贴板项目
      const textBlob = new Blob(['这是一些文本数据'], { type: 'text/plain' });
      
      // 创建一个Canvas并绘制一些内容
      const canvas = document.createElement('canvas');
      canvas.width = 100;
      canvas.height = 100;
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'red';
      ctx.fillRect(0, 0, 50, 50);
      ctx.fillStyle = 'blue';
      ctx.fillRect(50, 50, 50, 50);
      
      // 将Canvas转换为Blob
      const imageBlob = await new Promise(resolve => {
        canvas.toBlob(resolve, 'image/png');
      });
      
      // 创建ClipboardItem对象
      const clipboardItem = new ClipboardItem({
        'text/plain': textBlob,
        'image/png': imageBlob
      });
      
      // 写入剪贴板
      await navigator.clipboard.write([clipboardItem]);
      console.log('复杂数据已成功复制到剪贴板');
    } catch (err) {
      console.error('复制复杂数据失败:', err);
    }
  }
  
  // 从剪贴板读取复杂数据
  async function readComplexDataFromClipboard() {
    try {
      const clipboardItems = await navigator.clipboard.read();
      
      for (const clipboardItem of clipboardItems) {
        // 获取可用的MIME类型
        const types = clipboardItem.types;
        console.log('剪贴板项目包含的数据类型:', types);
        
        // 处理文本数据
        if (types.includes('text/plain')) {
          const textBlob = await clipboardItem.getType('text/plain');
          const text = await textBlob.text();
          console.log('剪贴板中的文本数据:', text);
        }
        
        // 处理图像数据
        if (types.includes('image/png')) {
          const imageBlob = await clipboardItem.getType('image/png');
          const imageUrl = URL.createObjectURL(imageBlob);
          
          // 显示图像
          const img = document.createElement('img');
          img.src = imageUrl;
          document.body.appendChild(img);
          console.log('剪贴板中的图像已显示');
        }
      }
    } catch (err) {
      console.error('读取剪贴板数据失败:', err);
    }
  }
  
  // 监听剪贴板事件
  document.addEventListener('copy', (e) => {
    // 阻止默认复制行为
    e.preventDefault();
    
    // 获取选中的文本
    const selection = document.getSelection().toString();
    
    // 修改要复制的内容
    const modifiedText = `${selection} [来源: 我的网站]`;
    
    // 将修改后的文本写入剪贴板
    e.clipboardData.setData('text/plain', modifiedText);
    
    console.log('已修改复制的内容');
  });
  
  document.addEventListener('paste', (e) => {
    console.log('检测到粘贴事件');
    
    // 获取剪贴板数据（不阻止默认行为）
    const pastedText = e.clipboardData.getData('text/plain');
    console.log('粘贴的文本:', pastedText);
  });
  
  // 创建复制按钮
  const copyButton = document.createElement('button');
  copyButton.textContent = '复制文本到剪贴板';
  copyButton.addEventListener('click', () => {
    copyTextToClipboard('这是通过Clipboard API复制的文本');
  });
  document.body.appendChild(copyButton);
  
  // 创建粘贴按钮
  const pasteButton = document.createElement('button');
  pasteButton.textContent = '从剪贴板粘贴文本';
  pasteButton.addEventListener('click', async () => {
    const text = await readTextFromClipboard();
    alert(`从剪贴板读取的文本: ${text}`);
  });
  document.body.appendChild(pasteButton);
} else {
  console.log('此浏览器不支持Clipboard API');
}
```

### 使用场景

1. **复制到剪贴板按钮**：提供一键复制功能，如复制代码、链接或引用
2. **富文本编辑器**：支持复杂的复制粘贴操作，包括格式化文本和图像
3. **截图和图像处理**：复制和粘贴图像数据
4. **数据传输**：在不同应用或标签页之间传输数据
5. **增强粘贴体验**：处理和转换粘贴的内容，如自动格式化代码或清理文本
6. **自定义复制行为**：添加引用信息或版权声明到复制的内容

### 注意事项和兼容性

- 现代浏览器（Chrome 66+、Firefox 63+、Safari 13.1+、Edge 79+）支持基本的文本操作
- 复杂数据操作（如ClipboardItem）在较新的浏览器版本中支持
- 出于安全考虑，读取剪贴板内容通常需要用户权限或用户手势（如点击）
- 在安全上下文（HTTPS）中使用时功能最完整
- 写入操作通常不需要特殊权限，但读取操作可能需要用户明确授权
- 对于不支持的浏览器，可以回退到document.execCommand('copy'/'paste')方法
- 剪贴板事件（copy、cut、paste）可以用于监听和修改剪贴板操作
- 处理大型数据（如高分辨率图像）时要注意性能影响
- 不同浏览器对支持的MIME类型有不同限制
- 在移动设备上的支持可能有限
