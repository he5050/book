---
title: 14.Observer-API介绍
date: 2025-08-04 23:18:00
permalink: /notes/all-observer-api-demo
description: Observer-API介绍
categories:
  - 笔记
  - Observer
tags:
  - JS
---

# Observer API 完整指南

Observer API 是现代 Web 开发中的重要工具，提供了一种高效、异步的方式来监控 DOM 变化、元素可见性、尺寸变化和性能指标。本文将详细介绍五种主要的 Observer API 及其实际应用。

## 1. IntersectionObserver

**IntersectionObserver** 用于异步监听目标元素与其祖先元素或顶级文档视窗（viewport）的交集变化。简单来说，它可以检测一个元素是否进入或离开了可视区域。

### 主要特性

- **异步执行**：不会阻塞主线程
- **高性能**：避免了频繁的 DOM 查询
- **灵活配置**：支持多种阈值和根元素设置

### 使用场景

- **图片懒加载**：当图片进入视口时才开始加载
- **无限滚动**：检测滚动到底部时加载更多内容
- **广告曝光统计**：统计广告元素的可见性
- **动画触发**：元素进入视口时触发动画效果
- **虚拟滚动**：优化长列表的渲染性能

### 核心 API

```javascript
const observer = new IntersectionObserver(callback, options);
observer.observe(target);
```

### 配置选项详解

#### `root`（根元素）

- **类型**: `Element | null`
- **默认值**: `null`（浏览器视窗）
- **说明**: 指定用作边界框的元素，目标元素的可见性将相对于此元素计算
- **示例**:

  ```javascript
  // 使用特定容器作为根元素
  {
  	root: document.querySelector('#scrollContainer');
  }
  ```

#### `rootMargin`（根边距）

- **类型**: `string`
- **默认值**: `"0px"`
- **说明**: 扩展或收缩根元素边界框的边距，语法类似 CSS margin
- **示例**:
  ```javascript
  // 在根元素边界外 50px 就开始触发
  {
  	rootMargin: '50px';
  }
  // 上下 10px，左右 20px
  {
  	rootMargin: '10px 20px';
  }
  // 上右下左分别设置
  {
  	rootMargin: '10px 20px 30px 40px';
  }
  ```

#### `threshold`（阈值）

- **类型**: `number | number[]`
- **默认值**: `0`
- **说明**: 触发回调的可见性阈值，可以是单个数字或数字数组
- **取值范围**: 0.0 到 1.0
- **示例**:
  ```javascript
  // 任何像素可见时触发
  {
  	threshold: 0;
  }
  // 完全可见时触发
  {
  	threshold: 1.0;
  }
  // 多个阈值，分别在 25%、50%、75%、100% 可见时触发
  {
  	threshold: [0.25, 0.5, 0.75, 1.0];
  }
  ```

### 浏览器支持

- Chrome 51+, Firefox 55+, Safari 12.1+
- 对于不支持的浏览器，可以使用 [polyfill](https://github.com/w3c/IntersectionObserver/tree/main/polyfill)

<demo react="react/Observer/components/IntersectionObserverDemo.tsx" 
:reactFiles="['react/Observer/components/IntersectionObserverDemo.tsx']" 
/>

## 2. MutationObserver

**MutationObserver** 提供了监视 DOM 树变化的能力，可以监听节点的添加、删除、属性变化和文本内容变化。

### 主要特性

- **全面监控**：支持多种类型的 DOM 变化
- **批量处理**：将多个变化合并为一次回调
- **详细信息**：提供变化前后的详细对比

### 使用场景

- **表单验证**：监控表单字段的实时变化
- **富文本编辑器**：监控内容编辑区域的变化
- **第三方脚本监控**：监控外部脚本对 DOM 的修改
- **UI 组件库**：监控组件内部状态变化
- **调试工具**：开发工具中的 DOM 变化追踪

### 核心 API

```javascript
const observer = new MutationObserver(callback);
observer.observe(target, config);
```

### 配置选项详解

#### `childList`（子节点变化）

- **类型**: `boolean`
- **默认值**: `false`
- **说明**: 是否监听目标节点的子节点的添加和删除
- **示例**:
  ```javascript
  // 监听子节点变化
  {
  	childList: true;
  }
  ```

#### `attributes`（属性变化）

- **类型**: `boolean`
- **默认值**: `false`
- **说明**: 是否监听目标节点的属性变化
- **示例**:
  ```javascript
  // 监听所有属性变化
  {
  	attributes: true;
  }
  ```

#### `characterData`（文本内容变化）

- **类型**: `boolean`
- **默认值**: `false`
- **说明**: 是否监听目标节点的文本内容变化
- **示例**:
  ```javascript
  // 监听文本内容变化
  {
  	characterData: true;
  }
  ```

#### `subtree`（后代节点）

- **类型**: `boolean`
- **默认值**: `false`
- **说明**: 是否监听目标节点的所有后代节点的变化
- **示例**:
  ```javascript
  // 监听整个子树的变化
  { childList: true, subtree: true }
  ```

#### `attributeOldValue`（属性旧值）

- **类型**: `boolean`
- **默认值**: `false`
- **说明**: 是否记录属性的旧值（需要同时设置 `attributes: true`）
- **示例**:
  ```javascript
  // 记录属性变化的旧值
  { attributes: true, attributeOldValue: true }
  ```

#### `characterDataOldValue`（文本旧值）

- **类型**: `boolean`
- **默认值**: `false`
- **说明**: 是否记录文本内容的旧值（需要同时设置 `characterData: true`）
- **示例**:
  ```javascript
  // 记录文本变化的旧值
  { characterData: true, characterDataOldValue: true }
  ```

#### `attributeFilter`（属性过滤器）

- **类型**: `string[]`
- **默认值**: `undefined`（监听所有属性）
- **说明**: 指定要监听的属性名数组，只有这些属性的变化会触发回调
- **示例**:
  ```javascript
  // 只监听 class 和 style 属性的变化
  { attributes: true, attributeFilter: ['class', 'style'] }
  ```

### 浏览器支持

- 所有现代浏览器都支持，IE 11+

<demo react="react/Observer/components/MutationObserverDemo.tsx" 
:reactFiles="['react/Observer/components/MutationObserverDemo.tsx']" 
/>

## 3. ResizeObserver

**ResizeObserver** 用于监听元素尺寸的变化，提供了一种高效的方式来响应元素大小的改变。

### 主要特性

- **精确监控**：监听元素内容区域、边框区域的尺寸变化
- **高性能**：避免了使用 `window.resize` 事件的性能问题
- **多元素支持**：可以同时监听多个元素

### 使用场景

- **响应式组件**：根据容器大小调整组件布局
- **图表库**：图表根据容器尺寸自动重绘
- **虚拟滚动**：计算可视区域大小优化渲染
- **文本截断**：根据容器宽度动态截断文本
- **网格布局**：根据容器大小调整网格列数
- **容器查询**：实现基于容器而非视口的响应式设计

### 核心 API

```javascript
const observer = new ResizeObserver(callback);
observer.observe(target);
```

### 回调参数详解

#### `contentRect`（内容区域）

- **类型**: `DOMRectReadOnly`
- **说明**: 元素的内容区域尺寸，不包括 padding、border、scrollbar
- **属性**:
  - `width`: 内容区域宽度
  - `height`: 内容区域高度
  - `top`: 相对于元素顶部的偏移
  - `left`: 相对于元素左侧的偏移
- **示例**:
  ```javascript
  observer = new ResizeObserver(entries => {
  	entries.forEach(entry => {
  		const { width, height } = entry.contentRect;
  		console.log(`内容区域: ${width} × ${height}`);
  	});
  });
  ```

#### `contentBoxSize`（内容盒子）

- **类型**: `ResizeObserverSize[]`
- **说明**: 内容盒子的尺寸信息，提供更精确的尺寸数据
- **属性**:
  - `inlineSize`: 内联方向的尺寸（通常是宽度）
  - `blockSize`: 块方向的尺寸（通常是高度）
- **示例**:
  ```javascript
  const contentBox = entry.contentBoxSize[0];
  console.log(`内容盒子: ${contentBox.inlineSize} × ${contentBox.blockSize}`);
  ```

#### `borderBoxSize`（边框盒子）

- **类型**: `ResizeObserverSize[]`
- **说明**: 边框盒子的尺寸信息，包括 padding 和 border
- **属性**:
  - `inlineSize`: 包含 padding 和 border 的内联尺寸
  - `blockSize`: 包含 padding 和 border 的块尺寸
- **示例**:
  ```javascript
  const borderBox = entry.borderBoxSize[0];
  console.log(`边框盒子: ${borderBox.inlineSize} × ${borderBox.blockSize}`);
  ```

### 浏览器支持

- Chrome 64+, Firefox 69+, Safari 13.1+
- 对于不支持的浏览器，可以使用 [polyfill](https://github.com/que-etc/resize-observer-polyfill)

<demo react="react/Observer/components/ResizeObserverDemo.tsx" 
:reactFiles="['react/Observer/components/ResizeObserverDemo.tsx']" 
/>

## 4. PerformanceObserver

**PerformanceObserver** 是 Web Performance API 的一部分，提供了异步、高效地收集浏览器性能指标的方式。

### 主要特性

- **实时监控**：异步获取性能数据
- **多种指标**：支持导航、资源、渲染等多种性能指标
- **Core Web Vitals**：支持 FCP、LCP、CLS 等关键指标

### 使用场景

- **性能监控**：实时收集页面性能数据
- **用户体验优化**：监控 Core Web Vitals 指标
- **资源优化**：识别加载缓慢的资源
- **性能预算**：设置性能阈值进行告警
- **A/B 测试**：对比不同版本的性能表现
- **问题诊断**：识别长任务和性能瓶颈

### 核心 API

```javascript
const observer = new PerformanceObserver(callback);
observer.observe({ entryTypes: ['navigation', 'paint', 'resource'] });
```

### 配置选项详解

#### `entryTypes`（条目类型）

- **类型**: `string[]`
- **说明**: 指定要观察的性能条目类型数组
- **支持的类型**:

##### `navigation`（导航性能）

- **说明**: 页面导航和加载的各个阶段时间
- **数据**: DNS 查询、TCP 连接、请求响应、DOM 解析等时间
- **示例**:
  ```javascript
  observer.observe({ entryTypes: ['navigation'], buffered: true });
  ```

##### `resource`（资源性能）

- **说明**: 页面资源（图片、CSS、JS、XHR 等）的加载时间
- **数据**: 资源加载耗时、大小、类型等信息
- **示例**:
  ```javascript
  observer.observe({ entryTypes: ['resource'] });
  ```

##### `paint`（渲染性能）

- **说明**: 页面渲染的关键时刻
- **包含**: FCP（首次内容绘制）、LCP（最大内容绘制）
- **示例**:
  ```javascript
  observer.observe({ entryTypes: ['paint'], buffered: true });
  ```

##### `longtask`（长任务）

- **说明**: 主线程上运行时间超过 50ms 的任务
- **用途**: 识别阻塞主线程的代码，影响用户交互
- **示例**:
  ```javascript
  observer.observe({ entryTypes: ['longtask'] });
  ```

##### `layout-shift`（布局偏移）

- **说明**: 页面内容的意外移动
- **用途**: 计算 CLS（累积布局偏移）指标
- **示例**:
  ```javascript
  observer.observe({ entryTypes: ['layout-shift'], buffered: true });
  ```

##### `element`（元素性能）

- **说明**: 特定元素的渲染时间
- **要求**: 元素需要添加 `elementtiming` 属性
- **示例**:
  ```javascript
  // HTML: <img elementtiming="hero-image" src="hero.jpg">
  observer.observe({ entryTypes: ['element'], buffered: true });
  ```

##### `mark` 和 `measure`（自定义标记）

- **说明**: 通过 `performance.mark()` 和 `performance.measure()` 创建的自定义性能标记
- **示例**:

  ```javascript
  // 创建标记
  performance.mark('start-task');
  // ... 执行任务
  performance.mark('end-task');
  performance.measure('task-duration', 'start-task', 'end-task');

  // 观察标记
  observer.observe({ entryTypes: ['mark', 'measure'] });
  ```

#### `buffered`（缓冲选项）

- **类型**: `boolean`
- **默认值**: `false`
- **说明**: 是否获取在 Observer 创建之前就已经发生的性能事件
- **重要性**: 对于 `navigation` 和 `paint` 类型特别重要
- **示例**:
  ```javascript
  // 获取页面加载时的历史性能数据
  observer.observe({
  	entryTypes: ['navigation', 'paint'],
  	buffered: true
  });
  ```

### 重要提示

使用 `buffered: true` 选项可以获取在 Observer 创建之前就已经发生的性能事件，这对于 `navigation` 和 `paint` 类型特别重要。

### 浏览器支持

- Chrome 52+, Firefox 57+, Safari 11+
- 不同的 `entryTypes` 支持程度可能不同

<demo react="react/Observer/components/PerformanceObserverDemo.tsx" 
:reactFiles="['react/Observer/components/PerformanceObserverDemo.tsx']" 
/>

## 5. ReportingObserver

**ReportingObserver** 用于监听浏览器生成的各种报告，包括弃用警告、浏览器干预、CSP 违规等。

### 主要特性

- **多种报告类型**：支持弃用、干预、违规等多种报告
- **实时通知**：异步接收浏览器报告
- **详细信息**：提供报告的详细上下文

### 使用场景

- **代码质量监控**：监控弃用 API 的使用
- **安全监控**：监控 CSP 违规行为
- **性能监控**：监控浏览器性能干预
- **合规检查**：监控功能策略违规
- **错误收集**：收集浏览器报告发送到监控平台
- **开发调试**：在开发阶段发现潜在问题

### 核心 API

```javascript
const observer = new ReportingObserver(callback, options);
observer.observe();
```

### 配置选项详解

#### `buffered`（缓冲选项）

- **类型**: `boolean`
- **默认值**: `false`
- **说明**: 是否获取在 Observer 创建之前就已经发生的报告
- **示例**:

  ```javascript
  const observer = new ReportingObserver(callback, { buffered: true });
  ```

### 报告类型详解

#### `deprecation`（弃用警告）

- **说明**: 当使用已弃用的 Web API 时触发
- **用途**: 帮助开发者识别需要更新的代码
- **示例场景**: 使用 `document.webkitHidden` 等已弃用属性
- **报告内容**:
  ```javascript
  {
    type: 'deprecation',
    url: 'https://example.com/page',
    body: {
      id: 'WebkitHidden',
      message: 'document.webkitHidden is deprecated...',
      anticipatedRemoval: '2024-01-01'
    }
  }
  ```

#### `intervention`（浏览器干预）

- **说明**: 浏览器为了用户体验而阻止或修改某些操作时触发
- **用途**: 了解浏览器的性能优化干预
- **示例场景**: 阻止过多的定时器、限制自动播放等
- **报告内容**:
  ```javascript
  {
    type: 'intervention',
    url: 'https://example.com/page',
    body: {
      id: 'TimerThrottling',
      message: 'Timer was throttled due to...',
      sourceFile: 'script.js',
      lineNumber: 42
    }
  }
  ```

#### `csp-violation`（CSP 违规）

- **说明**: 违反内容安全策略时触发
- **用途**: 监控安全策略违规，发现潜在的安全问题
- **前提**: 需要在服务器设置 CSP 头
- **示例场景**: 执行内联脚本、加载不允许的资源等
- **报告内容**:
  ```javascript
  {
    type: 'csp-violation',
    url: 'https://example.com/page',
    body: {
      blockedURI: 'https://malicious.com/script.js',
      violatedDirective: 'script-src',
      originalPolicy: "script-src 'self'"
    }
  }
  ```

#### `feature-policy-violation`（功能策略违规）

- **说明**: 违反功能策略（现在称为权限策略）时触发
- **用途**: 监控功能使用权限违规
- **示例场景**: 在不允许的上下文中使用地理位置、摄像头等
- **报告内容**:

  ```javascript
  {
    type: 'feature-policy-violation',
    url: 'https://example.com/page',
    body: {
      featureId: 'geolocation',
      message: 'Geolocation access denied by feature policy',
      sourceFile: 'app.js',
      lineNumber: 123
    }
  }
  ```

### 浏览器支持

ReportingObserver 是相对较新的 API，浏览器支持有限：

- Chrome 69+（完整支持）
- Firefox 70+（部分支持）
- Safari：暂不支持

### 注意事项

- 某些报告类型需要特定的服务器配置才能触发（如 CSP 违规需要设置 CSP 头）
- 在生产环境中，建议将报告发送到监控服务进行分析
- 可以通过 `typeof ReportingObserver !== 'undefined'` 检查浏览器支持

<demo react="react/Observer/components/ReportingObserverDemo.tsx" 
:reactFiles="['react/Observer/components/ReportingObserverDemo.tsx']" 
/>

## 总结

Observer API 为现代 Web 开发提供了强大的监控能力：

### 性能优势

- **异步执行**：不阻塞主线程
- **批量处理**：减少回调频率
- **精确监控**：避免不必要的计算

### 开发效率

- **声明式 API**：简洁的使用方式
- **丰富的配置**：灵活的监控选项
- **标准化**：跨浏览器的一致性

### 实际应用

- **用户体验优化**：懒加载、无限滚动、响应式布局
- **性能监控**：实时收集和分析性能数据
- **质量保证**：监控代码质量和安全问题

通过合理使用这些 Observer API，可以构建更高性能、更用户友好的 Web 应用程序。

## 最佳实践

### 1. 性能考虑

- **及时断开连接**：在组件卸载时调用 `observer.disconnect()` 避免内存泄漏
- **合理设置阈值**：IntersectionObserver 的 threshold 设置要根据实际需求，避免过于频繁的回调
- **批量处理**：利用 Observer 的批量处理特性，避免在回调中进行昂贵的操作

### 2. 错误处理

- **浏览器兼容性检查**：使用前检查 API 是否存在
- **降级方案**：为不支持的浏览器提供 polyfill 或替代方案
- **异常捕获**：在回调函数中添加适当的错误处理

### 3. 代码组织

- **使用 React Hooks**：将 Observer 逻辑封装成可复用的自定义 Hook
- **类型安全**：在 TypeScript 项目中添加适当的类型定义
- **配置抽象**：将常用的配置选项抽象成可复用的配置对象

### 4. 调试技巧

- **开发环境日志**：在开发环境中添加详细的日志输出
- **性能监控**：使用 PerformanceObserver 监控 Observer 本身的性能影响
- **可视化工具**：使用浏览器开发者工具的相关面板进行调试

在实际项目中，建议根据具体需求选择合适的 Observer，并注意浏览器兼容性和性能影响。
