---
title: æ‹–åŠ¨æ•ˆæœ
date: 2025-07-17 16:16:00
permalink: /notes/drag-animation
description: åŸç”Ÿå®ç°æ‹–åŠ¨åŠ¨ç”»æ•ˆæœ
categories:
  - ç¬”è®°
tags:
  - JS
  - æ‹–åŠ¨åŠ¨ç”»
  - äº¤äº’è®¾è®¡
---

# æ‹–åŠ¨åŠ¨ç”»å®ç°ä¸ä½¿ç”¨

æ‹–åŠ¨æ•ˆæœæ˜¯ç°ä»£ Web åº”ç”¨ä¸­ä¸å¯æˆ–ç¼ºçš„äº¤äº’æ–¹å¼ï¼Œèƒ½å¤Ÿæä¾›ç›´è§‚çš„ç”¨æˆ·ä½“éªŒã€‚æœ¬æ–‡å°†è¯¦ç»†ä»‹ç»å¦‚ä½•å®ç°å„ç§æ‹–åŠ¨æ•ˆæœï¼ŒåŒ…æ‹¬åŸºç¡€æ‹–æ‹½ã€ç½‘æ ¼æ‹–æ‹½ã€åˆ—è¡¨æ’åºç­‰åŠŸèƒ½ã€‚

## ğŸ¯ æ‹–åŠ¨æ•ˆæœç±»å‹

### åŸºç¡€æ‹–åŠ¨ç±»å‹

- **è‡ªç”±æ‹–åŠ¨**: å…ƒç´ å¯åœ¨å®¹å™¨å†…ä»»æ„ä½ç½®æ‹–åŠ¨
- **çº¦æŸæ‹–åŠ¨**: é™åˆ¶åœ¨ç‰¹å®šè½´å‘æˆ–åŒºåŸŸå†…æ‹–åŠ¨
- **ç½‘æ ¼æ‹–åŠ¨**: æŒ‰ç½‘æ ¼å¯¹é½çš„æ‹–åŠ¨æ•ˆæœ
- **ç£æ€§å¸é™„**: æ‹–åŠ¨æ—¶è‡ªåŠ¨å¸é™„åˆ°ç‰¹å®šä½ç½®
- **åˆ—è¡¨æ’åº**: åˆ—è¡¨é¡¹çš„æ‹–æ‹½æ’åºåŠŸèƒ½

### é«˜çº§äº¤äº’ç‰¹æ€§

- **æ‹–æ‹½é¢„è§ˆ**: æ‹–åŠ¨æ—¶æ˜¾ç¤ºåŠé€æ˜é¢„è§ˆ
- **ç¢°æ’æ£€æµ‹**: æ£€æµ‹ä¸å…¶ä»–å…ƒç´ çš„ç¢°æ’
- **è¾¹ç•Œçº¦æŸ**: é™åˆ¶æ‹–åŠ¨èŒƒå›´
- **æƒ¯æ€§æ»‘åŠ¨**: é‡Šæ”¾åçš„æƒ¯æ€§è¿åŠ¨æ•ˆæœ

## ğŸ’» å®ç°æ¼”ç¤º

### React æ‹–åŠ¨ç»„ä»¶

<demo react="react/Animate/Drag/index.tsx" 
:reactFiles="['react/Animate/Drag/index.tsx','react/Animate/Drag/index.scss']" 
/>

### Vue ç½‘æ ¼æ‹–æ‹½ç³»ç»Ÿ

<demo vue="vue/DragGrid/index.vue"
:vueFiles="['vue/DragGrid/index.vue','vue/DragGrid/DialogBox.vue','vue/DragGrid/GridCell.vue','vue/DragGrid/GridSystem.vue','vue/DragGrid/SideBar.vue','vue/DragGrid/gridUtils.ts','vue/DragGrid/useDragDrop.ts','vue/DragGrid/useGridLayout.ts']"
/>

## ğŸ› ï¸ æ ¸å¿ƒå®ç°åŸç†

### 1. åŸºç¡€æ‹–åŠ¨å®ç°

```typescript
interface DragState {
	isDragging: boolean;
	startX: number;
	startY: number;
	currentX: number;
	currentY: number;
	offsetX: number;
	offsetY: number;
}

class DragHandler {
	private element: HTMLElement;
	private state: DragState;
	private onDragStart?: (e: MouseEvent) => void;
	private onDragMove?: (e: MouseEvent) => void;
	private onDragEnd?: (e: MouseEvent) => void;

	constructor(element: HTMLElement, options: DragOptions = {}) {
		this.element = element;
		this.state = {
			isDragging: false,
			startX: 0,
			startY: 0,
			currentX: 0,
			currentY: 0,
			offsetX: 0,
			offsetY: 0
		};

		this.onDragStart = options.onDragStart;
		this.onDragMove = options.onDragMove;
		this.onDragEnd = options.onDragEnd;

		this.bindEvents();
	}

	private bindEvents() {
		this.element.addEventListener('mousedown', this.handleMouseDown);
		document.addEventListener('mousemove', this.handleMouseMove);
		document.addEventListener('mouseup', this.handleMouseUp);

		// é˜²æ­¢é»˜è®¤çš„æ‹–æ‹½è¡Œä¸º
		this.element.addEventListener('dragstart', e => e.preventDefault());
	}

	private handleMouseDown = (e: MouseEvent) => {
		e.preventDefault();

		const rect = this.element.getBoundingClientRect();
		this.state = {
			isDragging: true,
			startX: e.clientX,
			startY: e.clientY,
			currentX: e.clientX,
			currentY: e.clientY,
			offsetX: e.clientX - rect.left,
			offsetY: e.clientY - rect.top
		};

		this.element.style.cursor = 'grabbing';
		this.element.classList.add('dragging');

		this.onDragStart?.(e);
	};

	private handleMouseMove = (e: MouseEvent) => {
		if (!this.state.isDragging) return;

		e.preventDefault();

		this.state.currentX = e.clientX;
		this.state.currentY = e.clientY;

		const deltaX = this.state.currentX - this.state.startX;
		const deltaY = this.state.currentY - this.state.startY;

		this.element.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

		this.onDragMove?.(e);
	};

	private handleMouseUp = (e: MouseEvent) => {
		if (!this.state.isDragging) return;

		this.state.isDragging = false;
		this.element.style.cursor = '';
		this.element.classList.remove('dragging');

		this.onDragEnd?.(e);
	};

	destroy() {
		this.element.removeEventListener('mousedown', this.handleMouseDown);
		document.removeEventListener('mousemove', this.handleMouseMove);
		document.removeEventListener('mouseup', this.handleMouseUp);
	}
}
```

### 2. React Hook å®ç°

```typescript
interface UseDragOptions {
	onDragStart?: (e: MouseEvent) => void;
	onDragMove?: (position: { x: number; y: number }) => void;
	onDragEnd?: (position: { x: number; y: number }) => void;
	constraint?: 'x' | 'y' | 'none';
	bounds?: { left: number; top: number; right: number; bottom: number };
}

const useDrag = (options: UseDragOptions = {}) => {
	const elementRef = useRef<HTMLElement>(null);
	const [isDragging, setIsDragging] = useState(false);
	const [position, setPosition] = useState({ x: 0, y: 0 });
	const dragState = useRef({
		startX: 0,
		startY: 0,
		initialX: 0,
		initialY: 0
	});

	const handleMouseDown = useCallback(
		(e: React.MouseEvent) => {
			if (!elementRef.current) return;

			e.preventDefault();
			setIsDragging(true);

			const rect = elementRef.current.getBoundingClientRect();
			dragState.current = {
				startX: e.clientX,
				startY: e.clientY,
				initialX: position.x,
				initialY: position.y
			};

			options.onDragStart?.(e.nativeEvent);
		},
		[position, options.onDragStart]
	);

	const handleMouseMove = useCallback(
		(e: MouseEvent) => {
			if (!isDragging) return;

			const deltaX = e.clientX - dragState.current.startX;
			const deltaY = e.clientY - dragState.current.startY;

			let newX = dragState.current.initialX + deltaX;
			let newY = dragState.current.initialY + deltaY;

			// åº”ç”¨çº¦æŸ
			if (options.constraint === 'x') {
				newY = dragState.current.initialY;
			} else if (options.constraint === 'y') {
				newX = dragState.current.initialX;
			}

			// åº”ç”¨è¾¹ç•Œé™åˆ¶
			if (options.bounds) {
				newX = Math.max(options.bounds.left, Math.min(options.bounds.right, newX));
				newY = Math.max(options.bounds.top, Math.min(options.bounds.bottom, newY));
			}

			const newPosition = { x: newX, y: newY };
			setPosition(newPosition);
			options.onDragMove?.(newPosition);
		},
		[isDragging, options.constraint, options.bounds, options.onDragMove]
	);

	const handleMouseUp = useCallback(
		(e: MouseEvent) => {
			if (!isDragging) return;

			setIsDragging(false);
			options.onDragEnd?.(position);
		},
		[isDragging, position, options.onDragEnd]
	);

	useEffect(() => {
		if (isDragging) {
			document.addEventListener('mousemove', handleMouseMove);
			document.addEventListener('mouseup', handleMouseUp);

			return () => {
				document.removeEventListener('mousemove', handleMouseMove);
				document.removeEventListener('mouseup', handleMouseUp);
			};
		}
	}, [isDragging, handleMouseMove, handleMouseUp]);

	return {
		elementRef,
		isDragging,
		position,
		dragHandlers: {
			onMouseDown: handleMouseDown
		},
		setPosition
	};
};
```

### 3. ç½‘æ ¼æ‹–æ‹½å®ç°

```typescript
interface GridDragOptions {
	gridSize: number;
	snapToGrid: boolean;
	onGridChange?: (oldIndex: number, newIndex: number) => void;
}

class GridDragSystem {
	private container: HTMLElement;
	private items: HTMLElement[] = [];
	private gridSize: number;
	private snapToGrid: boolean;
	private draggedItem: HTMLElement | null = null;
	private placeholder: HTMLElement | null = null;

	constructor(container: HTMLElement, options: GridDragOptions) {
		this.container = container;
		this.gridSize = options.gridSize;
		this.snapToGrid = options.snapToGrid;
		this.init();
	}

	private init() {
		this.items = Array.from(this.container.children) as HTMLElement[];
		this.items.forEach((item, index) => {
			item.setAttribute('data-index', index.toString());
			this.makeDraggable(item);
		});
	}

	private makeDraggable(item: HTMLElement) {
		item.addEventListener('mousedown', e => this.startDrag(e, item));
	}

	private startDrag(e: MouseEvent, item: HTMLElement) {
		e.preventDefault();

		this.draggedItem = item;
		this.createPlaceholder();

		// è®¾ç½®æ‹–æ‹½æ ·å¼
		item.style.position = 'fixed';
		item.style.zIndex = '1000';
		item.style.pointerEvents = 'none';
		item.classList.add('dragging');

		document.addEventListener('mousemove', this.handleDragMove);
		document.addEventListener('mouseup', this.handleDragEnd);
	}

	private createPlaceholder() {
		if (!this.draggedItem) return;

		this.placeholder = this.draggedItem.cloneNode(true) as HTMLElement;
		this.placeholder.style.opacity = '0.5';
		this.placeholder.style.pointerEvents = 'none';
		this.placeholder.classList.add('placeholder');

		this.draggedItem.parentNode?.insertBefore(this.placeholder, this.draggedItem);
	}

	private handleDragMove = (e: MouseEvent) => {
		if (!this.draggedItem) return;

		// æ›´æ–°æ‹–æ‹½å…ƒç´ ä½ç½®
		this.draggedItem.style.left = e.clientX - this.draggedItem.offsetWidth / 2 + 'px';
		this.draggedItem.style.top = e.clientY - this.draggedItem.offsetHeight / 2 + 'px';

		// æ£€æµ‹æ’å…¥ä½ç½®
		const insertPosition = this.getInsertPosition(e.clientX, e.clientY);
		if (insertPosition && this.placeholder) {
			this.updatePlaceholderPosition(insertPosition);
		}
	};

	private getInsertPosition(x: number, y: number): HTMLElement | null {
		const elements = this.items.filter(item => item !== this.draggedItem);

		for (const element of elements) {
			const rect = element.getBoundingClientRect();
			if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
				return element;
			}
		}

		return null;
	}

	private updatePlaceholderPosition(targetElement: HTMLElement) {
		if (!this.placeholder) return;

		const targetRect = targetElement.getBoundingClientRect();
		const placeholderRect = this.placeholder.getBoundingClientRect();

		if (targetRect.top < placeholderRect.top) {
			targetElement.parentNode?.insertBefore(this.placeholder, targetElement);
		} else {
			targetElement.parentNode?.insertBefore(this.placeholder, targetElement.nextSibling);
		}
	}

	private handleDragEnd = () => {
		if (!this.draggedItem || !this.placeholder) return;

		// æ¢å¤æ‹–æ‹½å…ƒç´ æ ·å¼
		this.draggedItem.style.position = '';
		this.draggedItem.style.zIndex = '';
		this.draggedItem.style.pointerEvents = '';
		this.draggedItem.classList.remove('dragging');

		// å°†æ‹–æ‹½å…ƒç´ æ”¾ç½®åˆ°å ä½ç¬¦ä½ç½®
		this.placeholder.parentNode?.insertBefore(this.draggedItem, this.placeholder);
		this.placeholder.remove();

		// æ¸…ç†çŠ¶æ€
		this.draggedItem = null;
		this.placeholder = null;

		document.removeEventListener('mousemove', this.handleDragMove);
		document.removeEventListener('mouseup', this.handleDragEnd);
	};
}
```

## ğŸ¨ é«˜çº§åŠŸèƒ½

### 1. æƒ¯æ€§æ»‘åŠ¨æ•ˆæœ

```typescript
class InertialDrag {
	private velocity = { x: 0, y: 0 };
	private lastPosition = { x: 0, y: 0 };
	private lastTime = 0;
	private friction = 0.95;
	private animationId: number = 0;

	updateVelocity(currentX: number, currentY: number) {
		const currentTime = Date.now();
		const deltaTime = currentTime - this.lastTime;

		if (deltaTime > 0) {
			this.velocity.x = ((currentX - this.lastPosition.x) / deltaTime) * 16;
			this.velocity.y = ((currentY - this.lastPosition.y) / deltaTime) * 16;
		}

		this.lastPosition = { x: currentX, y: currentY };
		this.lastTime = currentTime;
	}

	startInertia(element: HTMLElement, currentPosition: { x: number; y: number }) {
		const animate = () => {
			// åº”ç”¨æ‘©æ“¦åŠ›
			this.velocity.x *= this.friction;
			this.velocity.y *= this.friction;

			// æ›´æ–°ä½ç½®
			currentPosition.x += this.velocity.x;
			currentPosition.y += this.velocity.y;

			element.style.transform = `translate(${currentPosition.x}px, ${currentPosition.y}px)`;

			// ç»§ç»­åŠ¨ç”»æˆ–åœæ­¢
			if (Math.abs(this.velocity.x) > 0.1 || Math.abs(this.velocity.y) > 0.1) {
				this.animationId = requestAnimationFrame(animate);
			}
		};

		animate();
	}

	stop() {
		if (this.animationId) {
			cancelAnimationFrame(this.animationId);
		}
	}
}
```

### 2. ç¢°æ’æ£€æµ‹

```typescript
class CollisionDetector {
	static isColliding(rect1: DOMRect, rect2: DOMRect): boolean {
		return !(
			rect1.right < rect2.left ||
			rect1.left > rect2.right ||
			rect1.bottom < rect2.top ||
			rect1.top > rect2.bottom
		);
	}

	static getCollisions(element: HTMLElement, targets: HTMLElement[]): HTMLElement[] {
		const elementRect = element.getBoundingClientRect();

		return targets.filter(target => {
			if (target === element) return false;
			const targetRect = target.getBoundingClientRect();
			return this.isColliding(elementRect, targetRect);
		});
	}

	static resolveCollision(
		draggedElement: HTMLElement,
		targetElement: HTMLElement,
		direction: 'horizontal' | 'vertical' = 'horizontal'
	) {
		const draggedRect = draggedElement.getBoundingClientRect();
		const targetRect = targetElement.getBoundingClientRect();

		if (direction === 'horizontal') {
			if (draggedRect.left < targetRect.left) {
				// æ¨åˆ°å·¦è¾¹
				draggedElement.style.transform = `translateX(${targetRect.left - draggedRect.width}px)`;
			} else {
				// æ¨åˆ°å³è¾¹
				draggedElement.style.transform = `translateX(${targetRect.right}px)`;
			}
		} else {
			if (draggedRect.top < targetRect.top) {
				// æ¨åˆ°ä¸Šè¾¹
				draggedElement.style.transform = `translateY(${targetRect.top - draggedRect.height}px)`;
			} else {
				// æ¨åˆ°ä¸‹è¾¹
				draggedElement.style.transform = `translateY(${targetRect.bottom}px)`;
			}
		}
	}
}
```

### 3. ç£æ€§å¸é™„

```typescript
class MagneticSnap {
	private snapDistance: number;
	private snapTargets: HTMLElement[];

	constructor(snapDistance = 20, snapTargets: HTMLElement[] = []) {
		this.snapDistance = snapDistance;
		this.snapTargets = snapTargets;
	}

	findSnapTarget(
		x: number,
		y: number
	): { element: HTMLElement; snapX: number; snapY: number } | null {
		let closestTarget: HTMLElement | null = null;
		let minDistance = this.snapDistance;
		let snapPosition = { x, y };

		for (const target of this.snapTargets) {
			const rect = target.getBoundingClientRect();
			const centerX = rect.left + rect.width / 2;
			const centerY = rect.top + rect.height / 2;

			const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));

			if (distance < minDistance) {
				minDistance = distance;
				closestTarget = target;
				snapPosition = { x: centerX, y: centerY };
			}
		}

		return closestTarget
			? {
					element: closestTarget,
					snapX: snapPosition.x,
					snapY: snapPosition.y
			  }
			: null;
	}

	animateToSnap(element: HTMLElement, targetX: number, targetY: number, duration = 300) {
		const startX = element.offsetLeft;
		const startY = element.offsetTop;
		const deltaX = targetX - startX;
		const deltaY = targetY - startY;
		const startTime = Date.now();

		const animate = () => {
			const elapsed = Date.now() - startTime;
			const progress = Math.min(elapsed / duration, 1);

			// ä½¿ç”¨ç¼“åŠ¨å‡½æ•°
			const easeProgress = this.easeOutCubic(progress);

			const currentX = startX + deltaX * easeProgress;
			const currentY = startY + deltaY * easeProgress;

			element.style.transform = `translate(${currentX}px, ${currentY}px)`;

			if (progress < 1) {
				requestAnimationFrame(animate);
			}
		};

		animate();
	}

	private easeOutCubic(t: number): number {
		return 1 - Math.pow(1 - t, 3);
	}
}
```

## ğŸ“± ç§»åŠ¨ç«¯æ”¯æŒ

### è§¦æ‘¸äº‹ä»¶å¤„ç†

```typescript
class TouchDragHandler {
	private element: HTMLElement;
	private isDragging = false;
	private startTouch = { x: 0, y: 0 };
	private currentPosition = { x: 0, y: 0 };

	constructor(element: HTMLElement) {
		this.element = element;
		this.bindTouchEvents();
	}

	private bindTouchEvents() {
		this.element.addEventListener('touchstart', this.handleTouchStart, { passive: false });
		this.element.addEventListener('touchmove', this.handleTouchMove, { passive: false });
		this.element.addEventListener('touchend', this.handleTouchEnd);
	}

	private handleTouchStart = (e: TouchEvent) => {
		e.preventDefault();

		const touch = e.touches[0];
		this.isDragging = true;
		this.startTouch = { x: touch.clientX, y: touch.clientY };

		this.element.classList.add('dragging');
	};

	private handleTouchMove = (e: TouchEvent) => {
		if (!this.isDragging) return;

		e.preventDefault();

		const touch = e.touches[0];
		const deltaX = touch.clientX - this.startTouch.x;
		const deltaY = touch.clientY - this.startTouch.y;

		this.currentPosition = {
			x: deltaX,
			y: deltaY
		};

		this.element.style.transform = `translate(${deltaX}px, ${deltaY}px)`;
	};

	private handleTouchEnd = () => {
		this.isDragging = false;
		this.element.classList.remove('dragging');
	};
}
```

### å¤šç‚¹è§¦æ§æ”¯æŒ

```typescript
class MultiTouchHandler {
	private touches: Map<number, Touch> = new Map();
	private initialDistance = 0;
	private initialScale = 1;

	handleTouchStart(e: TouchEvent) {
		Array.from(e.touches).forEach(touch => {
			this.touches.set(touch.identifier, touch);
		});

		if (e.touches.length === 2) {
			this.initialDistance = this.getDistance(e.touches[0], e.touches[1]);
		}
	}

	handleTouchMove(e: TouchEvent) {
		e.preventDefault();

		if (e.touches.length === 1) {
			// å•ç‚¹æ‹–æ‹½
			this.handleSingleTouchMove(e.touches[0]);
		} else if (e.touches.length === 2) {
			// åŒç‚¹ç¼©æ”¾
			this.handlePinchZoom(e.touches[0], e.touches[1]);
		}
	}

	private getDistance(touch1: Touch, touch2: Touch): number {
		const dx = touch1.clientX - touch2.clientX;
		const dy = touch1.clientY - touch2.clientY;
		return Math.sqrt(dx * dx + dy * dy);
	}

	private handlePinchZoom(touch1: Touch, touch2: Touch) {
		const currentDistance = this.getDistance(touch1, touch2);
		const scale = (currentDistance / this.initialDistance) * this.initialScale;

		// åº”ç”¨ç¼©æ”¾
		this.element.style.transform = `scale(${scale})`;
	}
}
```

## âš¡ æ€§èƒ½ä¼˜åŒ–

### 1. è™šæ‹ŸåŒ–æ‹–æ‹½

```typescript
class VirtualizedDragList {
	private visibleItems: HTMLElement[] = [];
	private itemHeight: number;
	private containerHeight: number;
	private scrollTop = 0;

	constructor(private container: HTMLElement, private items: any[], itemHeight: number) {
		this.itemHeight = itemHeight;
		this.containerHeight = container.clientHeight;
		this.updateVisibleItems();
	}

	private updateVisibleItems() {
		const startIndex = Math.floor(this.scrollTop / this.itemHeight);
		const endIndex = Math.min(
			startIndex + Math.ceil(this.containerHeight / this.itemHeight) + 1,
			this.items.length
		);

		// åªæ¸²æŸ“å¯è§çš„é¡¹ç›®
		this.renderVisibleItems(startIndex, endIndex);
	}

	private renderVisibleItems(startIndex: number, endIndex: number) {
		// æ¸…ç©ºç°æœ‰é¡¹ç›®
		this.container.innerHTML = '';

		for (let i = startIndex; i < endIndex; i++) {
			const item = this.createItemElement(this.items[i], i);
			item.style.position = 'absolute';
			item.style.top = `${i * this.itemHeight}px`;
			this.container.appendChild(item);
		}
	}

	private createItemElement(data: any, index: number): HTMLElement {
		const element = document.createElement('div');
		element.className = 'drag-item';
		element.textContent = data.text;

		// æ·»åŠ æ‹–æ‹½åŠŸèƒ½
		new DragHandler(element, {
			onDragEnd: () => this.handleItemDrop(index)
		});

		return element;
	}
}
```

### 2. é˜²æŠ–å’ŒèŠ‚æµ

```typescript
class OptimizedDragHandler {
	private throttledMove: (e: MouseEvent) => void;
	private debouncedEnd: (e: MouseEvent) => void;

	constructor(element: HTMLElement) {
		this.throttledMove = this.throttle(this.handleMove.bind(this), 16); // 60fps
		this.debouncedEnd = this.debounce(this.handleEnd.bind(this), 100);

		element.addEventListener('mousemove', this.throttledMove);
		element.addEventListener('mouseup', this.debouncedEnd);
	}

	private throttle<T extends (...args: any[]) => void>(func: T, delay: number): T {
		let lastCall = 0;
		return ((...args: Parameters<T>) => {
			const now = Date.now();
			if (now - lastCall >= delay) {
				lastCall = now;
				func(...args);
			}
		}) as T;
	}

	private debounce<T extends (...args: any[]) => void>(func: T, delay: number): T {
		let timeoutId: number;
		return ((...args: Parameters<T>) => {
			clearTimeout(timeoutId);
			timeoutId = setTimeout(() => func(...args), delay);
		}) as T;
	}

	private handleMove(e: MouseEvent) {
		// å¤„ç†ç§»åŠ¨é€»è¾‘
	}

	private handleEnd(e: MouseEvent) {
		// å¤„ç†ç»“æŸé€»è¾‘
	}
}
```

## ğŸ¯ åº”ç”¨åœºæ™¯

### 1. çœ‹æ¿ç³»ç»Ÿ

```typescript
const KanbanBoard = () => {
	const [columns, setColumns] = useState([
		{ id: 'todo', title: 'å¾…åŠ', items: [] },
		{ id: 'doing', title: 'è¿›è¡Œä¸­', items: [] },
		{ id: 'done', title: 'å·²å®Œæˆ', items: [] }
	]);

	const handleItemDrop = (itemId: string, targetColumnId: string) => {
		setColumns(prev => {
			// ç§»åŠ¨é¡¹ç›®åˆ°ç›®æ ‡åˆ—
			return moveItemBetweenColumns(prev, itemId, targetColumnId);
		});
	};

	return (
		<div className="kanban-board">
			{columns.map(column => (
				<KanbanColumn key={column.id} column={column} onItemDrop={handleItemDrop} />
			))}
		</div>
	);
};
```

### 2. æ–‡ä»¶ç®¡ç†å™¨

```typescript
const FileManager = () => {
	const [files, setFiles] = useState([]);
	const [selectedFiles, setSelectedFiles] = useState([]);

	const handleFileDrop = (fileIds: string[], targetFolderId: string) => {
		// ç§»åŠ¨æ–‡ä»¶åˆ°ç›®æ ‡æ–‡ä»¶å¤¹
		moveFilesToFolder(fileIds, targetFolderId);
	};

	return (
		<div className="file-manager">
			<FileGrid
				files={files}
				selectedFiles={selectedFiles}
				onFileDrop={handleFileDrop}
				onFileSelect={setSelectedFiles}
			/>
		</div>
	);
};
```

### 3. å›¾ç‰‡ç¼–è¾‘å™¨

```typescript
const ImageEditor = () => {
	const [layers, setLayers] = useState([]);

	const handleLayerDrag = (layerId: string, newPosition: { x: number; y: number }) => {
		setLayers(prev =>
			prev.map(layer => (layer.id === layerId ? { ...layer, position: newPosition } : layer))
		);
	};

	return (
		<div className="image-editor">
			<Canvas>
				{layers.map(layer => (
					<DraggableLayer key={layer.id} layer={layer} onDrag={handleLayerDrag} />
				))}
			</Canvas>
		</div>
	);
};
```

## ğŸ”§ æœ€ä½³å®è·µ

### è®¾è®¡åŸåˆ™

1. **ç›´è§‚åé¦ˆ**: æä¾›æ¸…æ™°çš„è§†è§‰åé¦ˆè¡¨æ˜å¯æ‹–æ‹½çŠ¶æ€
2. **æ€§èƒ½ä¼˜å…ˆ**: ä½¿ç”¨ transform è€Œéæ”¹å˜ position å±æ€§
3. **å¯è®¿é—®æ€§**: æä¾›é”®ç›˜æ“ä½œçš„æ›¿ä»£æ–¹æ¡ˆ
4. **é”™è¯¯å¤„ç†**: ä¼˜é›…å¤„ç†æ‹–æ‹½å¤±è´¥çš„æƒ…å†µ

### å®æ–½å»ºè®®

1. **æ¸è¿›å¢å¼º**: ç¡®ä¿åŸºç¡€åŠŸèƒ½åœ¨ç¦ç”¨ JavaScript æ—¶ä»å¯ç”¨
2. **ç”¨æˆ·æµ‹è¯•**: åœ¨ä¸åŒè®¾å¤‡ä¸Šæµ‹è¯•æ‹–æ‹½ä½“éªŒ
3. **æ€§èƒ½ç›‘æ§**: ç›‘æ§æ‹–æ‹½æ“ä½œå¯¹æ€§èƒ½çš„å½±å“
4. **å…¼å®¹æ€§**: ç¡®ä¿åœ¨ä¸åŒæµè§ˆå™¨ä¸­çš„ä¸€è‡´æ€§

---

_æ‹–åŠ¨æ•ˆæœæ˜¯æå‡ç”¨æˆ·ä½“éªŒçš„é‡è¦äº¤äº’æ–¹å¼ï¼Œåˆç†å®ç°å¯ä»¥è®©åº”ç”¨æ›´åŠ ç›´è§‚å’Œæ˜“ç”¨ã€‚_ ğŸ¯
