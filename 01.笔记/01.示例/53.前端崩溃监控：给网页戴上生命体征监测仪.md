---
title: å‰ç«¯å´©æºƒç›‘æ§ï¼šç»™ç½‘é¡µæˆ´ä¸Šç”Ÿå‘½ä½“å¾ç›‘æµ‹ä»ª
date: 2025-01-27 11:00:00
permalink: /frontend/crash-monitoring
description: å‰ç«¯å´©æºƒç›‘æ§å®Œæ•´è§£å†³æ–¹æ¡ˆï¼ŒåŒ…å«å››å±‚ç›‘æ§ä½“ç³»ã€å¤šç»´åº¦å¼‚å¸¸æ•æ‰ã€æ™ºèƒ½ä¸ŠæŠ¥åˆ†æç­‰æ ¸å¿ƒåŠŸèƒ½
categories:
  - å‰ç«¯æŠ€æœ¯
  - ç›‘æ§ç³»ç»Ÿ
tags:
  - å‰ç«¯ç›‘æ§
  - å´©æºƒç›‘æ§
  - æ€§èƒ½ç›‘æ§
  - é”™è¯¯å¤„ç†
  - Service Worker
---

# å‰ç«¯å´©æºƒç›‘æ§ï¼šç»™ç½‘é¡µæˆ´ä¸Šç”Ÿå‘½ä½“å¾ç›‘æµ‹ä»ª

## ç®€ä»‹

åœ¨ç°ä»£å‰ç«¯å¼€å‘ä¸­ï¼Œé¡µé¢å´©æºƒæ˜¯å½±å“ç”¨æˆ·ä½“éªŒçš„ä¸¥é‡é—®é¢˜ã€‚ä¼ ç»Ÿçš„é”™è¯¯ç›‘æ§åªèƒ½æ•è· JavaScript æ‰§è¡Œé”™è¯¯ï¼Œä½†å¯¹äºå†…å­˜æ³„æ¼ã€æ­»å¾ªç¯ã€æ¸²æŸ“å±‚å´©æºƒç­‰è‡´å‘½é—®é¢˜å´æ— èƒ½ä¸ºåŠ›ã€‚æœ¬æ–‡ä»‹ç»ä¸€å¥—å®Œæ•´çš„å‰ç«¯å´©æºƒç›‘æ§è§£å†³æ–¹æ¡ˆï¼Œé€šè¿‡å››å±‚ç›‘æ§ä½“ç³»å®ç°å…¨æ–¹ä½çš„é¡µé¢å¥åº·ç›‘æµ‹ã€‚

## æŠ€æœ¯ç‰¹ç‚¹

### æ ¸å¿ƒåŠŸèƒ½ç‰¹æ€§

- **å››å±‚ç›‘æ§ä½“ç³»**: ä»å¿ƒè·³ç›‘æµ‹åˆ°æ™ºèƒ½ä¸ŠæŠ¥çš„å®Œæ•´é“¾è·¯
- **å¤šç»´åº¦å¼‚å¸¸æ•æ‰**: å†…å­˜ã€äº‹ä»¶å¾ªç¯ã€æ¸²æŸ“æ€§èƒ½å…¨é¢ç›‘æ§
- **æ™ºèƒ½å´©æºƒæ£€æµ‹**: åŸºäºå¤šç§æŒ‡æ ‡çš„å´©æºƒåˆ¤æ–­ç®—æ³•
- **æ— æ„Ÿç›‘æ§**: ç›‘æ§æœ¬èº«ä¸å½±å“é¡µé¢æ€§èƒ½
- **å®æ—¶ä¸ŠæŠ¥**: å¤šç§ä¸ŠæŠ¥ç­–ç•¥ç¡®ä¿æ•°æ®åŠæ—¶é€è¾¾

### æŠ€æœ¯ä¼˜åŠ¿

- **é«˜è¦†ç›–ç‡**: è¦†ç›–ä¼ ç»Ÿç›‘æ§æ— æ³•æ£€æµ‹çš„å´©æºƒåœºæ™¯
- **ä½ä¾µå…¥æ€§**: æœ€å°åŒ–å¯¹ä¸šåŠ¡ä»£ç çš„å½±å“
- **æ™ºèƒ½åˆ†æ**: è‡ªåŠ¨åˆ†æå´©æºƒåŸå› å’Œå½±å“èŒƒå›´
- **æ˜“äºé›†æˆ**: æä¾›æ ‡å‡†åŒ–çš„ API å’Œé…ç½®é€‰é¡¹

## ç³»ç»Ÿæ¶æ„

## æ•ˆæœæ¼”ç¤º

<demo react="react/CrashMonitoring/Demo.tsx" 
:reactFiles="['react/CrashMonitoring/index.tsx','react/CrashMonitoring/index.scss','react/CrashMonitoring/Demo.tsx']" 
/>

### å››å±‚ç›‘æ§ä½“ç³»æ¶æ„å›¾

### å››å±‚ç›‘æ§ä½“ç³»æ¶æ„å›¾

```mermaid
graph TB
    subgraph "ç›‘æ§ä½“ç³»æ¶æ„"
        A[ç¬¬ä¸€å±‚: å®æ—¶å¿ƒè·³ç›‘æµ‹] --> B[ç¬¬äºŒå±‚: å¤šç»´åº¦å¼‚å¸¸æ•æ‰]
        B --> C[ç¬¬ä¸‰å±‚: å´©æºƒç°åœºå¿«ç…§]
        C --> D[ç¬¬å››å±‚: æ™ºèƒ½ä¸ŠæŠ¥åˆ†æ]
    end

    subgraph "æŠ€æœ¯å®ç°å±‚"
        E[Service Worker<br/>ç‹¬ç«‹å¿ƒè·³] --> F[LocalStorage<br/>å¿ƒè·³å¤‡ä»½]
        F --> G[Performance API<br/>æ€§èƒ½ç›‘æ§]
        G --> H[Error Boundaries<br/>é”™è¯¯è¾¹ç•Œ]
    end

    A -.-> E
    B -.-> G
    B -.-> H
    C -.-> F
    D -.-> E
```

### ç›‘æ§æµç¨‹å›¾

```mermaid
flowchart TD
    A[é¡µé¢åŠ è½½] --> B[åˆå§‹åŒ–ç›‘æ§ç³»ç»Ÿ]
    B --> C[å¯åŠ¨å¿ƒè·³ç›‘æµ‹]
    C --> D[å¯åŠ¨æ€§èƒ½ç›‘æ§]
    D --> E[å¯åŠ¨å¼‚å¸¸æ•è·]
    E --> F{é¡µé¢æ­£å¸¸è¿è¡Œ?}

    F -->|æ˜¯| G[å®šæœŸæ”¶é›†æŒ‡æ ‡]
    G --> H[åˆ†æå¥åº·çŠ¶æ€]
    H --> I{å‘ç°å¼‚å¸¸?}

    I -->|å¦| F
    I -->|æ˜¯| J[è®°å½•å¼‚å¸¸ä¿¡æ¯]
    J --> K[ç”Ÿæˆå´©æºƒæŠ¥å‘Š]
    K --> L[æ™ºèƒ½ä¸ŠæŠ¥]
    L --> M[æœåŠ¡ç«¯åˆ†æ]

    F -->|å¦| N[æ£€æµ‹åˆ°å´©æºƒ]
    N --> O[æ”¶é›†ç°åœºè¯æ®]
    O --> K
```

## æ ¸å¿ƒå®ç°åŸç†

### åŸºç¡€å®ç°æ–¹æ¡ˆ

**æ ¸å¿ƒæ€è·¯**ï¼š

- **å¤šå±‚é˜²æŠ¤**: Service Worker + LocalStorage åŒé‡å¿ƒè·³ä¿éšœ
- **å¤šç»´åº¦ç›‘æ§**: å†…å­˜ã€äº‹ä»¶å¾ªç¯ã€æ¸²æŸ“æ€§èƒ½å…¨é¢è¦†ç›–
- **æ™ºèƒ½åˆ¤æ–­**: åŸºäºå¤šç§æŒ‡æ ‡ç»¼åˆåˆ¤æ–­å´©æºƒçŠ¶æ€
- **æ— æ„Ÿä¸ŠæŠ¥**: ä¸å½±å“ç”¨æˆ·ä½“éªŒçš„æ•°æ®ä¸ŠæŠ¥æœºåˆ¶

**ä¼˜ç‚¹**ï¼š

- è¦†ç›–ä¼ ç»Ÿç›‘æ§ç›²åŒº
- é«˜å¯é æ€§ï¼Œå¤šé‡ä¿éšœ
- ä½æ€§èƒ½å¼€é”€
- æ˜“äºæ‰©å±•å’Œç»´æŠ¤

**é€‚ç”¨åœºæ™¯**ï¼š

- ä¼ä¸šçº§ Web åº”ç”¨
- ç”µå•†å¹³å°
- åœ¨çº¿æ•™è‚²å¹³å°
- é‡‘èäº¤æ˜“ç³»ç»Ÿ

### å¿ƒè·³ç›‘æµ‹å®ç°

```typescript
class HeartbeatMonitor {
	private heartbeatInterval = 5000; // 5ç§’ä¸€æ¬¡å¿ƒè·³
	private crashThreshold = 15000; // 15ç§’æ— å¿ƒè·³ç®—"ä¼‘å…‹"
	private sessionId: string;
	private lastHeartbeatTime: number;

	constructor() {
		this.sessionId = this.generateSessionId();
		this.lastHeartbeatTime = Date.now();
	}

	start() {
		// æ³¨å†ŒService Worker
		if ('serviceWorker' in navigator) {
			navigator.serviceWorker
				.register('/sw-heartbeat.js')
				.then(() => {
					console.log('ğŸ¥ Service Workerå¿ƒè·³ç›‘æµ‹å·²å¯åŠ¨');
					this.startHeartbeat();
				})
				.catch(err => {
					console.warn('Service Workeræ³¨å†Œå¤±è´¥:', err);
					this.fallbackToLocalStorage();
				});
		} else {
			this.fallbackToLocalStorage();
		}
	}

	private startHeartbeat() {
		setInterval(() => {
			this.sendHeartbeat();
		}, this.heartbeatInterval);
	}

	private sendHeartbeat() {
		const vitalSigns = {
			type: 'HEARTBEAT',
			timestamp: Date.now(),
			sessionId: this.sessionId,
			memoryPressure: this.getMemoryPressure(),
			eventLoopHealth: this.getEventLoopHealth(),
			url: window.location.href
		};

		// å‘é€åˆ°Service Worker
		navigator.serviceWorker.controller?.postMessage(vitalSigns);

		// åŒæ—¶å¤‡ä»½åˆ°LocalStorage
		this.backupToLocalStorage(vitalSigns);

		this.lastHeartbeatTime = Date.now();
	}

	private fallbackToLocalStorage() {
		// é™çº§æ–¹æ¡ˆï¼šä»…ä½¿ç”¨LocalStorage
		setInterval(() => {
			localStorage.setItem(
				'heartbeat_backup',
				JSON.stringify({
					timestamp: Date.now(),
					sessionId: this.sessionId,
					url: window.location.href
				})
			);
		}, 3000);
	}

	private getMemoryPressure(): number {
		if (performance.memory) {
			return (performance.memory.usedJSHeapSize / performance.memory.totalJSHeapSize) * 100;
		}
		return 0;
	}

	private getEventLoopHealth(): number {
		const start = performance.now();
		setTimeout(() => {
			const duration = performance.now() - start;
			return duration;
		}, 0);
		return 0;
	}
}
```

### å¤šç»´åº¦å¼‚å¸¸æ•æ‰

```typescript
class MultiDimensionalMonitor {
	private memoryThreshold = 90; // å†…å­˜ä½¿ç”¨ç‡é˜ˆå€¼
	private eventLoopThreshold = 100; // äº‹ä»¶å¾ªç¯å»¶è¿Ÿé˜ˆå€¼
	private layoutShiftThreshold = 0.1; // å¸ƒå±€åç§»é˜ˆå€¼

	constructor() {
		this.setupMemoryMonitoring();
		this.setupEventLoopMonitoring();
		this.setupRenderMonitoring();
	}

	// å†…å­˜ç›‘æ§
	private setupMemoryMonitoring() {
		if (!performance.memory) return;

		setInterval(() => {
			const memoryUsage =
				(performance.memory.usedJSHeapSize / performance.memory.totalJSHeapSize) * 100;

			if (memoryUsage > this.memoryThreshold) {
				this.reportAnomaly({
					type: 'MEMORY_PRESSURE',
					severity: memoryUsage > 95 ? 'CRITICAL' : 'WARNING',
					value: memoryUsage,
					timestamp: Date.now()
				});
			}
		}, 10000);
	}

	// äº‹ä»¶å¾ªç¯ç›‘æ§
	private setupEventLoopMonitoring() {
		let lastFrameTime = performance.now();

		const checkFrame = () => {
			const currentTime = performance.now();
			const frameTime = currentTime - lastFrameTime;

			if (frameTime > this.eventLoopThreshold) {
				this.reportAnomaly({
					type: 'EVENT_LOOP_BLOCKED',
					severity: frameTime > 500 ? 'CRITICAL' : 'WARNING',
					value: frameTime,
					timestamp: currentTime
				});
			}

			lastFrameTime = currentTime;
			requestAnimationFrame(checkFrame);
		};

		requestAnimationFrame(checkFrame);
	}

	// æ¸²æŸ“æ€§èƒ½ç›‘æ§
	private setupRenderMonitoring() {
		// å¸ƒå±€åç§»ç›‘æ§
		if ('PerformanceObserver' in window) {
			const layoutShiftObserver = new PerformanceObserver(list => {
				list.getEntries().forEach(entry => {
					if (entry.value > this.layoutShiftThreshold && !entry.hadRecentInput) {
						this.reportAnomaly({
							type: 'LAYOUT_SHIFT',
							severity: entry.value > 0.25 ? 'CRITICAL' : 'WARNING',
							value: entry.value,
							timestamp: entry.startTime
						});
					}
				});
			});

			layoutShiftObserver.observe({ entryTypes: ['layout-shift'] });

			// é•¿ä»»åŠ¡ç›‘æ§
			const longTaskObserver = new PerformanceObserver(list => {
				list.getEntries().forEach(entry => {
					if (entry.duration > 50) {
						this.reportAnomaly({
							type: 'LONG_TASK',
							severity: entry.duration > 200 ? 'CRITICAL' : 'WARNING',
							value: entry.duration,
							timestamp: entry.startTime
						});
					}
				});
			});

			longTaskObserver.observe({ entryTypes: ['longtask'] });
		}
	}

	private reportAnomaly(anomaly: any) {
		// å¼‚å¸¸ä¸ŠæŠ¥é€»è¾‘
		console.warn('æ£€æµ‹åˆ°å¼‚å¸¸:', anomaly);

		// è§¦å‘å´©æºƒæ£€æµ‹
		this.checkForCrash(anomaly);
	}
}
```

## å®ç°æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ                    | ä¼˜ç‚¹               | ç¼ºç‚¹                       | é€‚ç”¨åœºæ™¯     | æ€§èƒ½å½±å“ |
| ----------------------- | ------------------ | -------------------------- | ------------ | -------- |
| **ä¼ ç»Ÿé”™è¯¯ç›‘æ§**        | ç®€å•æ˜“ç”¨ï¼Œå…¼å®¹æ€§å¥½ | æ— æ³•æ£€æµ‹å†…å­˜æ³„æ¼ã€æ­»å¾ªç¯ç­‰ | åŸºç¡€é”™è¯¯æ•è· | æä½     |
| **Service Worker å¿ƒè·³** | ç‹¬ç«‹è¿è¡Œï¼Œå¯é æ€§é«˜ | éœ€è¦ HTTPS ç¯å¢ƒ            | é«˜å¯é æ€§ç›‘æ§ | ä½       |
| **LocalStorage å¤‡ä»½**   | å…¼å®¹æ€§å¥½ï¼Œå®ç°ç®€å• | ä¾èµ–é¡µé¢åˆ·æ–°æ£€æµ‹           | é™çº§æ–¹æ¡ˆ     | æä½     |
| **å››å±‚ç›‘æ§ä½“ç³»**        | å…¨é¢è¦†ç›–ï¼Œé«˜å¯é æ€§ | å®ç°å¤æ‚åº¦è¾ƒé«˜             | ä¼ä¸šçº§åº”ç”¨   | ä¸­ç­‰     |

## é«˜çº§åŠŸèƒ½

### åŠŸèƒ½ 1ï¼šæ™ºèƒ½å´©æºƒæ£€æµ‹

```typescript
class SmartCrashDetector {
	private anomalyHistory: any[] = [];
	private crashScore = 0;
	private crashThreshold = 100;

	constructor() {
		this.startMonitoring();
	}

	private startMonitoring() {
		// å®šæœŸè¯„ä¼°å´©æºƒé£é™©
		setInterval(() => {
			this.evaluateCrashRisk();
		}, 5000);
	}

	private evaluateCrashRisk() {
		// åŸºäºå†å²å¼‚å¸¸è®¡ç®—å´©æºƒåˆ†æ•°
		const recentAnomalies = this.anomalyHistory.filter(
			anomaly => Date.now() - anomaly.timestamp < 60000
		);

		let score = 0;

		// æ ¹æ®å¼‚å¸¸ç±»å‹å’Œä¸¥é‡ç¨‹åº¦è®¡ç®—åˆ†æ•°
		recentAnomalies.forEach(anomaly => {
			switch (anomaly.type) {
				case 'MEMORY_PRESSURE':
					score += anomaly.severity === 'CRITICAL' ? 40 : 20;
					break;
				case 'EVENT_LOOP_BLOCKED':
					score += anomaly.severity === 'CRITICAL' ? 50 : 25;
					break;
				case 'LONG_TASK':
					score += anomaly.severity === 'CRITICAL' ? 30 : 15;
					break;
				case 'LAYOUT_SHIFT':
					score += anomaly.severity === 'CRITICAL' ? 10 : 5;
					break;
			}
		});

		this.crashScore = score;

		// åˆ¤æ–­æ˜¯å¦å‘ç”Ÿå´©æºƒ
		if (score >= this.crashThreshold) {
			this.handleCrashDetected();
		}
	}

	private handleCrashDetected() {
		const crashReport = {
			type: 'CRASH_DETECTED',
			timestamp: Date.now(),
			crashScore: this.crashScore,
			anomalyHistory: this.anomalyHistory.slice(-10),
			pageInfo: this.getPageInfo(),
			userAgent: navigator.userAgent
		};

		// ä¸ŠæŠ¥å´©æºƒ
		this.reportCrash(crashReport);

		// é‡ç½®çŠ¶æ€
		this.crashScore = 0;
		this.anomalyHistory = [];
	}

	private getPageInfo() {
		return {
			url: window.location.href,
			title: document.title,
			viewport: `${window.innerWidth}x${window.innerHeight}`,
			scrollPosition: { x: window.scrollX, y: window.scrollY },
			memory: performance.memory
				? {
						used: performance.memory.usedJSHeapSize,
						total: performance.memory.totalJSHeapSize
				  }
				: null
		};
	}
}
```

### åŠŸèƒ½ 2ï¼šå´©æºƒç°åœºå¿«ç…§

```typescript
class CrashSnapshot {
	private userActions: any[] = [];
	private domSnapshot: any;

	constructor() {
		this.setupUserActionTracking();
	}

	private setupUserActionTracking() {
		// è·Ÿè¸ªç”¨æˆ·æ“ä½œ
		['click', 'keydown', 'scroll', 'resize'].forEach(eventType => {
			document.addEventListener(
				eventType,
				e => {
					this.recordUserAction({
						type: eventType,
						target: e.target,
						timestamp: Date.now(),
						coordinates: this.getEventCoordinates(e),
						pageX: (e as any).pageX,
						pageY: (e as any).pageY
					});
				},
				{ passive: true }
			);
		});
	}

	private recordUserAction(action: any) {
		this.userActions.push(action);

		// åªä¿ç•™æœ€è¿‘çš„æ“ä½œè®°å½•
		if (this.userActions.length > 20) {
			this.userActions.shift();
		}
	}

	private getEventCoordinates(e: Event): { x: number; y: number } {
		if ('pageX' in e && 'pageY' in e) {
			return { x: (e as any).pageX, y: (e as any).pageY };
		}
		return { x: 0, y: 0 };
	}

	captureSnapshot(): any {
		return {
			timestamp: Date.now(),
			userActions: this.userActions.slice(-10),
			domStructure: this.captureDOMStructure(),
			memorySnapshot: this.captureMemorySnapshot(),
			performanceMetrics: this.capturePerformanceMetrics(),
			networkStatus: this.captureNetworkStatus()
		};
	}

	private captureDOMStructure() {
		// ç®€åŒ–çš„DOMç»“æ„æ•è·
		const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT, null, false);

		const elements: any[] = [];
		let node;
		let count = 0;

		while ((node = walker.nextNode()) && count < 100) {
			elements.push({
				tagName: node.nodeName,
				className: (node as Element).className,
				id: (node as Element).id,
				textContent: (node as Element).textContent?.slice(0, 100)
			});
			count++;
		}

		return elements;
	}

	private captureMemorySnapshot() {
		if (performance.memory) {
			return {
				usedJSHeapSize: performance.memory.usedJSHeapSize,
				totalJSHeapSize: performance.memory.totalJSHeapSize,
				jsHeapSizeLimit: performance.memory.jsHeapSizeLimit
			};
		}
		return null;
	}

	private capturePerformanceMetrics() {
		return {
			navigation: performance.getEntriesByType('navigation')[0],
			resource: performance.getEntriesByType('resource').slice(0, 10),
			paint: performance.getEntriesByType('paint'),
			firstPaint: performance.getEntriesByName('first-paint')[0],
			firstContentfulPaint: performance.getEntriesByName('first-contentful-paint')[0]
		};
	}

	private captureNetworkStatus() {
		return {
			effectiveType: (navigator as any).connection?.effectiveType,
			downlink: (navigator as any).connection?.downlink,
			rtt: (navigator as any).connection?.rtt,
			saveData: (navigator as any).connection?.saveData
		};
	}
}
```

### åŠŸèƒ½ 3ï¼šæ™ºèƒ½ä¸ŠæŠ¥ç³»ç»Ÿ

```typescript
class SmartReporter {
	private reportQueue: any[] = [];
	private batchSize = 10;
	private flushInterval = 30000;

	constructor() {
		this.startPeriodicFlush();
	}

	report(data: any, severity: 'EMERGENCY' | 'NORMAL' | 'DEBUG' = 'NORMAL') {
		const report = {
			id: this.generateReportId(),
			timestamp: Date.now(),
			severity,
			data,
			userAgent: navigator.userAgent,
			sessionId: this.getSessionId()
		};

		if (severity === 'EMERGENCY') {
			this.emergencyReport(report);
		} else {
			this.queueReport(report);
		}
	}

	private emergencyReport(report: any) {
		// ä½¿ç”¨sendBeaconç¡®ä¿ç´§æ€¥æŠ¥å‘Šé€è¾¾
		const url = '/api/emergency-reports';
		const blob = new Blob([JSON.stringify(report)], {
			type: 'application/json'
		});

		if (navigator.sendBeacon) {
			navigator.sendBeacon(url, blob);
		} else {
			// é™çº§æ–¹æ¡ˆ
			fetch(url, {
				method: 'POST',
				body: blob,
				keepalive: true
			}).catch(console.error);
		}
	}

	private queueReport(report: any) {
		this.reportQueue.push(report);

		if (this.reportQueue.length >= this.batchSize) {
			this.flushQueue();
		}
	}

	private flushQueue() {
		if (this.reportQueue.length === 0) return;

		const batch = this.reportQueue.splice(0, this.batchSize);
		const url = '/api/batch-reports';

		fetch(url, {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(batch)
		}).catch(error => {
			console.error('æ‰¹é‡ä¸ŠæŠ¥å¤±è´¥ï¼Œå°†é‡è¯•:', error);
			// å¤±è´¥æ—¶é‡æ–°åŠ å…¥é˜Ÿåˆ—
			this.reportQueue.unshift(...batch);
		});
	}

	private startPeriodicFlush() {
		setInterval(() => {
			if (this.reportQueue.length > 0) {
				this.flushQueue();
			}
		}, this.flushInterval);
	}

	private generateReportId(): string {
		return `report_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
	}

	private getSessionId(): string {
		let sessionId = sessionStorage.getItem('session_id');
		if (!sessionId) {
			sessionId = `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
			sessionStorage.setItem('session_id', sessionId);
		}
		return sessionId;
	}
}
```

## æŠ€æœ¯è¦ç‚¹

### 1. Service Worker æœ€ä½³å®è·µ

```typescript
// Service Worker å®ç°
const heartbeatSW = `
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'HEARTBEAT') {
    // è®°å½•å¿ƒè·³
    self.clients.matchAll().then(clients => {
      clients.forEach(client => {
        // å¯ä»¥å‘ä¸»é¡µé¢å‘é€ç¡®è®¤æ¶ˆæ¯
        client.postMessage({
          type: 'HEARTBEAT_ACK',
          timestamp: Date.now()
        });
      });
    });
    
    // æ£€æŸ¥æ˜¯å¦é•¿æ—¶é—´æœªæ”¶åˆ°å¿ƒè·³
    checkForCrash(event.data);
  }
});

function checkForCrash(heartbeatData) {
  const lastHeartbeat = localStorage.getItem('last_heartbeat');
  if (lastHeartbeat) {
    const timeSinceLast = Date.now() - parseInt(lastHeartbeat);
    if (timeSinceLast > 15000) { // 15ç§’
      // å¯èƒ½å‘ç”Ÿå´©æºƒ
      reportCrash({
        type: 'POSSIBLE_CRASH',
        lastHeartbeat: parseInt(lastHeartbeat),
        currentHeartbeat: heartbeatData.timestamp,
        sessionId: heartbeatData.sessionId
      });
    }
  }
  
  // æ›´æ–°æœ€åå¿ƒè·³æ—¶é—´
  localStorage.setItem('last_heartbeat', heartbeatData.timestamp.toString());
}

function reportCrash(crashData) {
  // ä½¿ç”¨IndexedDBå­˜å‚¨å´©æºƒä¿¡æ¯
  // ç­‰å¾…é¡µé¢æ¢å¤åè¯»å–
}
`;

// æ³¨å†ŒService Worker
const registerServiceWorker = async () => {
	const blob = new Blob([heartbeatSW], { type: 'application/javascript' });
	const url = URL.createObjectURL(blob);

	try {
		const registration = await navigator.serviceWorker.register(url);
		console.log('Service Workeræ³¨å†ŒæˆåŠŸ');
		return registration;
	} catch (error) {
		console.error('Service Workeræ³¨å†Œå¤±è´¥:', error);
		throw error;
	}
};
```

### 2. é”™è¯¯è¾¹ç•Œå®ç°

```typescript
import React from 'react';

class ErrorBoundary extends React.Component<
	{
		children: React.ReactNode;
		fallback?: React.ComponentType<any>;
	},
	{
		hasError: boolean;
		error?: Error;
		errorInfo?: React.ErrorInfo;
	}
> {
	constructor(props: any) {
		super(props);
		this.state = { hasError: false };
	}

	static getDerivedStateFromError(error: Error) {
		// æ›´æ–°çŠ¶æ€ä»¥æ˜¾ç¤ºé™çº§UI
		return { hasError: true, error };
	}

	componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
		// è®°å½•é”™è¯¯ä¿¡æ¯
		this.setState({ errorInfo });

		// ä¸ŠæŠ¥é”™è¯¯
		this.reportError(error, errorInfo);
	}

	private reportError(error: Error, errorInfo: React.ErrorInfo) {
		const errorReport = {
			type: 'REACT_ERROR_BOUNDARY',
			error: {
				name: error.name,
				message: error.message,
				stack: error.stack
			},
			errorInfo: {
				componentStack: errorInfo.componentStack
			},
			timestamp: Date.now(),
			userAgent: navigator.userAgent,
			url: window.location.href
		};

		// ä¸ŠæŠ¥åˆ°ç›‘æ§ç³»ç»Ÿ
		this.sendToMonitoring(errorReport);
	}

	private sendToMonitoring(report: any) {
		// å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
		if (window.__CRASH_MONITOR__) {
			window.__CRASH_MONITOR__.report(report, 'EMERGENCY');
		}
	}

	render() {
		if (this.state.hasError) {
			const FallbackComponent = this.props.fallback || DefaultErrorFallback;
			return <FallbackComponent error={this.state.error} errorInfo={this.state.errorInfo} />;
		}

		return this.props.children;
	}
}

const DefaultErrorFallback: React.FC<{ error?: Error; errorInfo?: React.ErrorInfo }> = ({
	error,
	errorInfo
}) => (
	<div className="error-fallback">
		<h2>é¡µé¢å‡ºç°é”™è¯¯</h2>
		<p>è¯·åˆ·æ–°é¡µé¢é‡è¯•</p>
		{process.env.NODE_ENV === 'development' && (
			<details>
				<summary>é”™è¯¯è¯¦æƒ…</summary>
				<pre>{error?.stack}</pre>
			</details>
		)}
	</div>
);
```

### 3. æ€§èƒ½ç›‘æ§æœ€ä½³å®è·µ

```typescript
class PerformanceMonitor {
	private metrics: Map<string, number[]> = new Map();
	private thresholds = {
		firstContentfulPaint: 1500,
		largestContentfulPaint: 2500,
		cumulativeLayoutShift: 0.1,
		firstInputDelay: 100
	};

	constructor() {
		this.startPerformanceMonitoring();
	}

	private startPerformanceMonitoring() {
		// ç›‘æ§Core Web Vitals
		this.monitorFirstContentfulPaint();
		this.monitorLargestContentfulPaint();
		this.monitorCumulativeLayoutShift();
		this.monitorFirstInputDelay();

		// ç›‘æ§è‡ªå®šä¹‰æŒ‡æ ‡
		this.monitorCustomMetrics();
	}

	private monitorFirstContentfulPaint() {
		new PerformanceObserver(list => {
			list.getEntries().forEach(entry => {
				this.recordMetric('firstContentfulPaint', entry.startTime);

				if (entry.startTime > this.thresholds.firstContentfulPaint) {
					this.reportPerformanceIssue('firstContentfulPaint', entry.startTime);
				}
			});
		}).observe({ entryTypes: ['paint'] });
	}

	private monitorLargestContentfulPaint() {
		new PerformanceObserver(list => {
			const entries = list.getEntries();
			const lastEntry = entries[entries.length - 1];

			this.recordMetric('largestContentfulPaint', lastEntry.startTime);

			if (lastEntry.startTime > this.thresholds.largestContentfulPaint) {
				this.reportPerformanceIssue('largestContentfulPaint', lastEntry.startTime);
			}
		}).observe({ entryTypes: ['largest-contentful-paint'] });
	}

	private monitorCumulativeLayoutShift() {
		let clsValue = 0;

		new PerformanceObserver(list => {
			list.getEntries().forEach(entry => {
				if (!(entry as any).hadRecentInput) {
					clsValue += (entry as any).value;
					this.recordMetric('cumulativeLayoutShift', clsValue);

					if (clsValue > this.thresholds.cumulativeLayoutShift) {
						this.reportPerformanceIssue('cumulativeLayoutShift', clsValue);
					}
				}
			});
		}).observe({ entryTypes: ['layout-shift'] });
	}

	private monitorFirstInputDelay() {
		new PerformanceObserver(list => {
			list.getEntries().forEach(entry => {
				this.recordMetric('firstInputDelay', (entry as any).processingStart - entry.startTime);

				if ((entry as any).processingStart - entry.startTime > this.thresholds.firstInputDelay) {
					this.reportPerformanceIssue(
						'firstInputDelay',
						(entry as any).processingStart - entry.startTime
					);
				}
			});
		}).observe({ entryTypes: ['first-input'] });
	}

	private monitorCustomMetrics() {
		// ç›‘æ§è‡ªå®šä¹‰ä¸šåŠ¡æŒ‡æ ‡
		this.monitorPageLoadTime();
		this.monitorApiResponseTime();
		this.monitorUserInteractionTime();
	}

	private recordMetric(name: string, value: number) {
		if (!this.metrics.has(name)) {
			this.metrics.set(name, []);
		}

		const values = this.metrics.get(name)!;
		values.push(value);

		// åªä¿ç•™æœ€è¿‘100ä¸ªå€¼
		if (values.length > 100) {
			values.shift();
		}
	}

	private reportPerformanceIssue(metric: string, value: number) {
		const report = {
			type: 'PERFORMANCE_ISSUE',
			metric,
			value,
			threshold: this.thresholds[metric as keyof typeof this.thresholds],
			timestamp: Date.now(),
			url: window.location.href
		};

		// ä¸ŠæŠ¥æ€§èƒ½é—®é¢˜
		this.sendReport(report);
	}
}
```

## å“åº”å¼è®¾è®¡

### ç§»åŠ¨ç«¯ä¼˜åŒ–

```typescript
class MobileOptimizedMonitor {
	private isMobile: boolean;
	private performanceBudget: any;

	constructor() {
		this.isMobile = this.detectMobile();
		this.performanceBudget = this.getPerformanceBudget();
		this.setupMobileOptimizations();
	}

	private detectMobile(): boolean {
		return (
			window.innerWidth <= 768 ||
			/Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
		);
	}

	private getPerformanceBudget() {
		if (this.isMobile) {
			return {
				memoryThreshold: 70, // ç§»åŠ¨ç«¯æ›´ä¸¥æ ¼çš„å†…å­˜é˜ˆå€¼
				eventLoopThreshold: 150,
				monitoringInterval: 15000, // é™ä½ç›‘æ§é¢‘ç‡
				reportInterval: 60000
			};
		}
		return {
			memoryThreshold: 90,
			eventLoopThreshold: 100,
			monitoringInterval: 10000,
			reportInterval: 30000
		};
	}

	private setupMobileOptimizations() {
		// ç§»åŠ¨ç«¯ç‰¹æ®Šå¤„ç†
		if (this.isMobile) {
			// é™ä½ç›‘æ§é¢‘ç‡
			this.adjustMonitoringFrequency();

			// ä¼˜åŒ–å†…å­˜ä½¿ç”¨
			this.optimizeMemoryUsage();

			// ç½‘ç»œä¼˜åŒ–
			this.optimizeNetworkUsage();
		}
	}

	private adjustMonitoringFrequency() {
		// åŠ¨æ€è°ƒæ•´ç›‘æ§é—´éš”
		const visibilityChangeHandler = () => {
			if (document.hidden) {
				// é¡µé¢éšè—æ—¶é™ä½ç›‘æ§é¢‘ç‡
				this.setMonitoringInterval(this.performanceBudget.monitoringInterval * 2);
			} else {
				// é¡µé¢å¯è§æ—¶æ¢å¤æ­£å¸¸é¢‘ç‡
				this.setMonitoringInterval(this.performanceBudget.monitoringInterval);
			}
		};

		document.addEventListener('visibilitychange', visibilityChangeHandler);
	}

	private optimizeMemoryUsage() {
		// ç§»åŠ¨ç«¯å†…å­˜ä¼˜åŒ–
		const cleanupHandler = () => {
			// æ¸…ç†å†å²æ•°æ®
			this.cleanupHistoricalData();

			// å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¦‚æœå¯ç”¨ï¼‰
			if (window.gc) {
				window.gc();
			}
		};

		// å®šæœŸæ¸…ç†
		setInterval(cleanupHandler, 300000); // 5åˆ†é’Ÿ

		// å†…å­˜å‹åŠ›æ—¶ç«‹å³æ¸…ç†
		window.addEventListener('memorypressure', cleanupHandler);
	}

	private optimizeNetworkUsage() {
		// ç§»åŠ¨ç«¯ç½‘ç»œä¼˜åŒ–
		const connection = (navigator as any).connection;

		if (connection) {
			const updateNetworkOptimization = () => {
				if (connection.effectiveType === 'slow-2g' || connection.effectiveType === '2g') {
					// æ…¢ç½‘ç»œä¸‹å‡å°‘ä¸ŠæŠ¥é¢‘ç‡
					this.setReportInterval(this.performanceBudget.reportInterval * 3);
				} else if (connection.effectiveType === '4g') {
					// 4Gç½‘ç»œä¸‹å¯ä»¥æ›´é¢‘ç¹ä¸ŠæŠ¥
					this.setReportInterval(this.performanceBudget.reportInterval / 2);
				}
			};

			connection.addEventListener('change', updateNetworkOptimization);
			updateNetworkOptimization();
		}
	}
}
```

## æ€§èƒ½ä¼˜åŒ–

### 1. å†…å­˜ç®¡ç†ä¼˜åŒ–

```typescript
class MemoryOptimizer {
	private objectPool: Map<string, any[]> = new Map();
	private cleanupInterval: number;

	constructor() {
		this.startMemoryOptimization();
	}

	private startMemoryOptimization() {
		// å®šæœŸå†…å­˜æ¸…ç†
		this.cleanupInterval = window.setInterval(() => {
			this.performCleanup();
		}, 60000); // æ¯åˆ†é’Ÿæ¸…ç†ä¸€æ¬¡

		// é¡µé¢å¸è½½æ—¶æ¸…ç†
		window.addEventListener('beforeunload', () => {
			this.cleanupAll();
		});

		// é¡µé¢éšè—æ—¶æ¸…ç†
		document.addEventListener('visibilitychange', () => {
			if (document.hidden) {
				this.performLightCleanup();
			}
		});
	}

	private performCleanup() {
		// æ¸…ç†å¯¹è±¡æ± 
		this.cleanupObjectPools();

		// æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
		this.cleanupEventListeners();

		// æ¸…ç†å®šæ—¶å™¨
		this.cleanupTimers();

		// å¼ºåˆ¶åƒåœ¾å›æ”¶ï¼ˆå¼€å‘ç¯å¢ƒï¼‰
		if (process.env.NODE_ENV === 'development' && window.gc) {
			window.gc();
		}
	}

	private cleanupObjectPools() {
		this.objectPool.forEach(pool => {
			pool.length = 0; // æ¸…ç©ºæ•°ç»„ä½†ä¿æŒå¼•ç”¨
		});
	}

	private cleanupEventListeners() {
		// æ¸…ç†æœªä½¿ç”¨çš„äº‹ä»¶ç›‘å¬å™¨
		const events = ['click', 'scroll', 'resize', 'keydown'];
		events.forEach(eventType => {
			// é‡æ–°ç»‘å®šå…³é”®äº‹ä»¶
			document.addEventListener(eventType, () => {}, { passive: true });
		});
	}

	private cleanupTimers() {
		// æ¸…ç†æœªä½¿ç”¨çš„å®šæ—¶å™¨
		// æ³¨æ„ï¼šè¿™é‡Œéœ€è¦ç»´æŠ¤å®šæ—¶å™¨IDçš„æ˜ å°„è¡¨
	}

	private performLightCleanup() {
		// è½»é‡çº§æ¸…ç†ï¼Œç”¨äºé¡µé¢éšè—æ—¶
		this.cleanupObjectPools();
	}

	private cleanupAll() {
		clearInterval(this.cleanupInterval);
		this.objectPool.clear();
	}
}
```

### 2. ç›‘æ§æ€§èƒ½ä¼˜åŒ–

```typescript
class MonitorPerformanceOptimizer {
	private monitoringOverhead = 0;
	private maxOverhead = 5; // æœ€å¤§å…è®¸å¼€é”€5%

	constructor() {
		this.startOverheadMonitoring();
	}

	private startOverheadMonitoring() {
		setInterval(() => {
			this.measureMonitoringOverhead();
			this.adjustMonitoringIntensity();
		}, 10000); // æ¯10ç§’æ£€æŸ¥ä¸€æ¬¡
	}

	private measureMonitoringOverhead() {
		const start = performance.now();

		// æ¨¡æ‹Ÿç›‘æ§æ“ä½œ
		this.simulateMonitoringOperations();

		const duration = performance.now() - start;
		this.monitoringOverhead = duration;
	}

	private simulateMonitoringOperations() {
		// æ¨¡æ‹Ÿå„ç§ç›‘æ§æ“ä½œçš„å¼€é”€
		if (performance.memory) {
			performance.memory.usedJSHeapSize;
		}

		// æ¨¡æ‹ŸDOMæŸ¥è¯¢
		document.querySelectorAll('*').length;

		// æ¨¡æ‹Ÿäº‹ä»¶ç›‘å¬
		const handler = () => {};
		document.addEventListener('test', handler);
		document.removeEventListener('test', handler);
	}

	private adjustMonitoringIntensity() {
		if (this.monitoringOverhead > this.maxOverhead) {
			// ç›‘æ§å¼€é”€è¿‡å¤§ï¼Œé™ä½ç›‘æ§å¼ºåº¦
			this.reduceMonitoringIntensity();
		} else if (this.monitoringOverhead < this.maxOverhead * 0.5) {
			// ç›‘æ§å¼€é”€è¾ƒå°ï¼Œå¯ä»¥å¢å¼ºç›‘æ§
			this.increaseMonitoringIntensity();
		}
	}

	private reduceMonitoringIntensity() {
		// é™ä½ç›‘æ§é¢‘ç‡
		this.adjustMonitoringFrequency(1.5);

		// å‡å°‘ç›‘æ§æŒ‡æ ‡
		this.reduceMonitoringMetrics();

		console.warn('ç›‘æ§å¼€é”€è¿‡å¤§ï¼Œå·²é™ä½ç›‘æ§å¼ºåº¦');
	}

	private increaseMonitoringIntensity() {
		// æ¢å¤æ­£å¸¸ç›‘æ§å¼ºåº¦
		this.adjustMonitoringFrequency(1);

		console.log('ç›‘æ§å¼€é”€æ­£å¸¸ï¼Œæ¢å¤æ­£å¸¸ç›‘æ§å¼ºåº¦');
	}

	private adjustMonitoringFrequency(factor: number) {
		// è°ƒæ•´å„ç§ç›‘æ§çš„é¢‘ç‡
		// è¿™é‡Œéœ€è¦è®¿é—®å„ä¸ªç›‘æ§æ¨¡å—çš„é…ç½®
	}

	private reduceMonitoringMetrics() {
		// å‡å°‘ç›‘æ§çš„æŒ‡æ ‡æ•°é‡
		// ä¼˜å…ˆä¿ç•™å…³é”®æŒ‡æ ‡ï¼Œå‡å°‘æ¬¡è¦æŒ‡æ ‡
	}
}
```

## æ•…éšœæ’é™¤

### 1. ç›‘æ§å¤±æ•ˆè¯Šæ–­

**é—®é¢˜**: ç›‘æ§ç³»ç»Ÿå®Œå…¨å¤±æ•ˆï¼Œæ— æ³•æ£€æµ‹åˆ°ä»»ä½•å¼‚å¸¸
**è§£å†³æ–¹æ¡ˆ**:

```typescript
class MonitorDiagnostics {
	static diagnose() {
		const issues = [];

		// æ£€æŸ¥Service Worker
		if (!('serviceWorker' in navigator)) {
			issues.push('Service Workerä¸æ”¯æŒ');
		} else if (!navigator.serviceWorker.controller) {
			issues.push('Service Workeræœªæ¿€æ´»');
		}

		// æ£€æŸ¥Performance API
		if (!performance.memory) {
			issues.push('Performance.memory APIä¸æ”¯æŒ');
		}

		// æ£€æŸ¥LocalStorage
		try {
			localStorage.setItem('test', 'test');
			localStorage.removeItem('test');
		} catch (e) {
			issues.push('LocalStorageä¸å¯ç”¨');
		}

		// æ£€æŸ¥ç½‘ç»œè¿æ¥
		if (!navigator.onLine) {
			issues.push('ç½‘ç»œç¦»çº¿');
		}

		return issues;
	}

	static fixIssues(issues: string[]) {
		issues.forEach(issue => {
			switch (issue) {
				case 'Service Workerä¸æ”¯æŒ':
					console.warn('ä½¿ç”¨LocalStorageé™çº§æ–¹æ¡ˆ');
					break;
				case 'Performance.memory APIä¸æ”¯æŒ':
					console.warn('ç¦ç”¨å†…å­˜ç›‘æ§');
					break;
				// å…¶ä»–ä¿®å¤é€»è¾‘
			}
		});
	}
}
```

### 2. è¯¯æŠ¥é—®é¢˜å¤„ç†

**é—®é¢˜**: ç›‘æ§ç³»ç»Ÿé¢‘ç¹æŠ¥å‘Šè¯¯æŠ¥
**è§£å†³æ–¹æ¡ˆ**:

```typescript
class FalsePositiveHandler {
	private falsePositiveThreshold = 3; // è¿ç»­è¯¯æŠ¥é˜ˆå€¼
	private recentReports: any[] = [];

	handleReport(report: any) {
		// æ£€æŸ¥æ˜¯å¦ä¸ºé‡å¤æŠ¥å‘Š
		const isDuplicate = this.checkDuplicate(report);
		if (isDuplicate) {
			this.handleDuplicateReport(report);
			return;
		}

		// æ£€æŸ¥æ˜¯å¦ä¸ºå·²çŸ¥è¯¯æŠ¥æ¨¡å¼
		if (this.isKnownFalsePositive(report)) {
			this.handleFalsePositive(report);
			return;
		}

		// æ­£å¸¸ä¸ŠæŠ¥
		this.reportToServer(report);
	}

	private checkDuplicate(report: any): boolean {
		const recent = this.recentReports.filter(
			r =>
				Date.now() - r.timestamp < 60000 && // 1åˆ†é’Ÿå†…
				r.type === report.type &&
				r.severity === report.severity
		);

		return recent.length > 0;
	}

	private isKnownFalsePositive(report: any): boolean {
		// æ£€æŸ¥å·²çŸ¥çš„è¯¯æŠ¥æ¨¡å¼
		const patterns = [/Chrome DevTools/i, /Firefox Developer Edition/i, /æµ‹è¯•ç¯å¢ƒ/i];

		return patterns.some(pattern => pattern.test(navigator.userAgent));
	}

	private handleFalsePositive(report: any) {
		console.warn('æ£€æµ‹åˆ°å¯èƒ½çš„è¯¯æŠ¥:', report);
		// è®°å½•ä½†ä¸ä¸ŠæŠ¥
	}
}
```

### 3. æ€§èƒ½å½±å“é—®é¢˜

**é—®é¢˜**: ç›‘æ§ç³»ç»Ÿå½±å“é¡µé¢æ€§èƒ½
**è§£å†³æ–¹æ¡ˆ**:

```typescript
class PerformanceImpactHandler {
	private performanceThreshold = 16; // 60fpså¯¹åº”çš„16ms

	constructor() {
		this.monitorPerformanceImpact();
	}

	private monitorPerformanceImpact() {
		let frameTime = 0;
		let frameCount = 0;

		const measureFrame = (timestamp: number) => {
			frameCount++;
			if (frameCount % 60 === 0) {
				const avgFrameTime = frameTime / 60;
				if (avgFrameTime > this.performanceThreshold) {
					this.handlePerformanceImpact(avgFrameTime);
				}
				frameTime = 0;
				frameCount = 0;
			}

			requestAnimationFrame(measureFrame);
		};

		requestAnimationFrame(measureFrame);
	}

	private handlePerformanceImpact(avgFrameTime: number) {
		console.warn(`ç›‘æ§ç³»ç»Ÿå½±å“æ€§èƒ½ï¼Œå¹³å‡å¸§æ—¶é—´: ${avgFrameTime}ms`);

		// é™ä½ç›‘æ§å¼ºåº¦
		this.reduceMonitoringIntensity();
	}

	private reduceMonitoringIntensity() {
		// å®ç°é™ä½ç›‘æ§å¼ºåº¦çš„é€»è¾‘
		// å¦‚å‡å°‘ç›‘æ§é¢‘ç‡ã€å…³é—­éå…³é”®ç›‘æ§ç­‰
	}
}
```

## æµç¨‹å›¾æè¿°

### ç›‘æ§ç³»ç»Ÿå·¥ä½œæµç¨‹

```mermaid
flowchart TD
    A[é¡µé¢åŠ è½½] --> B[åˆå§‹åŒ–ç›‘æ§ç³»ç»Ÿ]
    B --> C[å¯åŠ¨å¿ƒè·³ç›‘æµ‹]
    C --> D[å¯åŠ¨æ€§èƒ½ç›‘æ§]
    D --> E[å¯åŠ¨å¼‚å¸¸æ•è·]
    E --> F{é¡µé¢æ­£å¸¸è¿è¡Œ?}

    F -->|æ˜¯| G[å®šæœŸæ”¶é›†æŒ‡æ ‡]
    G --> H[åˆ†æå¥åº·çŠ¶æ€]
    H --> I{å‘ç°å¼‚å¸¸?}

    I -->|å¦| F
    I -->|æ˜¯| J[è®°å½•å¼‚å¸¸ä¿¡æ¯]
    J --> K[æ›´æ–°å´©æºƒåˆ†æ•°]
    K --> L{å´©æºƒåˆ†æ•°è¶…é˜ˆå€¼?}

    L -->|å¦| F
    L -->|æ˜¯| M[ç”Ÿæˆå´©æºƒæŠ¥å‘Š]
    M --> N[æ™ºèƒ½ä¸ŠæŠ¥]
    N --> O[æœåŠ¡ç«¯åˆ†æ]

    F -->|å¦| P[æ£€æµ‹åˆ°å´©æºƒ]
    P --> Q[æ”¶é›†ç°åœºè¯æ®]
    Q --> M
```

### å››å±‚ç›‘æ§ä½“ç³»è¯¦è§£

```mermaid
graph TB
    subgraph "ç¬¬ä¸€å±‚: å®æ—¶å¿ƒè·³ç›‘æµ‹"
        A1[Service Workerå¿ƒè·³] --> A2[LocalStorageå¤‡ä»½]
        A2 --> A3[å¿ƒè·³çŠ¶æ€åˆ¤æ–­]
    end

    subgraph "ç¬¬äºŒå±‚: å¤šç»´åº¦å¼‚å¸¸æ•æ‰"
        B1[å†…å­˜å‹åŠ›ç›‘æ§] --> B2[äº‹ä»¶å¾ªç¯ç›‘æ§]
        B2 --> B3[æ¸²æŸ“æ€§èƒ½ç›‘æ§]
        B3 --> B4[é•¿ä»»åŠ¡ç›‘æ§]
    end

    subgraph "ç¬¬ä¸‰å±‚: å´©æºƒç°åœºå¿«ç…§"
        C1[ç”¨æˆ·æ“ä½œè®°å½•] --> C2[DOMç»“æ„æ•è·]
        C2 --> C3[å†…å­˜å¿«ç…§]
        C3 --> C4[æ€§èƒ½æŒ‡æ ‡æ”¶é›†]
    end

    subgraph "ç¬¬å››å±‚: æ™ºèƒ½ä¸ŠæŠ¥åˆ†æ"
        D1[ç´§æ€¥ä¸ŠæŠ¥] --> D2[æ‰¹é‡ä¸ŠæŠ¥]
        D2 --> D3[æ•°æ®åŠ å¯†]
        D3 --> D4[æœåŠ¡ç«¯åˆ†æ]
    end

    A3 --> B1
    B4 --> C1
    C4 --> D1
```

## å‚æ•°è¯´æ˜

### æ ¸å¿ƒé…ç½®å‚æ•°

| å‚æ•°å                       | ç±»å‹    | é»˜è®¤å€¼ | è¯´æ˜                       | å–å€¼èŒƒå›´     |
| ---------------------------- | ------- | ------ | -------------------------- | ------------ |
| **heartbeatInterval**        | number  | 5000   | å¿ƒè·³æ£€æµ‹é—´éš”               | 1000-30000ms |
| **crashThreshold**           | number  | 15000  | å´©æºƒæ£€æµ‹é˜ˆå€¼               | 5000-60000ms |
| **memoryThreshold**          | number  | 90     | å†…å­˜ä½¿ç”¨ç‡é˜ˆå€¼             | 50-99%       |
| **eventLoopThreshold**       | number  | 100    | äº‹ä»¶å¾ªç¯å»¶è¿Ÿé˜ˆå€¼           | 10-1000ms    |
| **enableServiceWorker**      | boolean | true   | æ˜¯å¦å¯ç”¨ Service Worker    | true/false   |
| **enableLocalStorageBackup** | boolean | true   | æ˜¯å¦å¯ç”¨ LocalStorage å¤‡ä»½ | true/false   |
| **showDetails**              | boolean | true   | æ˜¯å¦æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯           | true/false   |

### é«˜çº§é…ç½®å‚æ•°

| å‚æ•°å                | ç±»å‹    | é»˜è®¤å€¼ | è¯´æ˜         | å–å€¼èŒƒå›´       |
| --------------------- | ------- | ------ | ------------ | -------------- |
| **batchSize**         | number  | 10     | æ‰¹é‡ä¸ŠæŠ¥å¤§å° | 1-100          |
| **flushInterval**     | number  | 30000  | æ‰¹é‡ä¸ŠæŠ¥é—´éš” | 10000-300000ms |
| **maxOverhead**       | number  | 5      | æœ€å¤§ç›‘æ§å¼€é”€ | 1-10%          |
| **sampleRate**        | number  | 1.0    | é‡‡æ ·ç‡       | 0.1-1.0        |
| **encryptionEnabled** | boolean | false  | æ˜¯å¦å¯ç”¨åŠ å¯† | true/false     |

### è‡ªå®šä¹‰å›è°ƒå‡½æ•°

```typescript
interface Callbacks {
	// å´©æºƒäº‹ä»¶å›è°ƒ
	onCrashDetected?: (crashInfo: CrashInfo) => void;

	// å¿ƒè·³äº‹ä»¶å›è°ƒ
	onHeartbeat?: (vitalSigns: VitalSigns) => void;

	// å¼‚å¸¸äº‹ä»¶å›è°ƒ
	onAnomalyDetected?: (anomaly: AnomalyInfo) => void;

	// æ€§èƒ½é—®é¢˜å›è°ƒ
	onPerformanceIssue?: (issue: PerformanceIssue) => void;
}
```

### ç§»åŠ¨ç«¯ä¼˜åŒ–å‚æ•°

| å‚æ•°å                        | ç±»å‹    | é»˜è®¤å€¼ | è¯´æ˜             |
| ----------------------------- | ------- | ------ | ---------------- |
| **mobileMemoryThreshold**     | number  | 70     | ç§»åŠ¨ç«¯å†…å­˜é˜ˆå€¼   |
| **mobileMonitoringInterval**  | number  | 15000  | ç§»åŠ¨ç«¯ç›‘æ§é—´éš”   |
| **enableBatteryOptimization** | boolean | true   | æ˜¯å¦å¯ç”¨ç”µæ± ä¼˜åŒ– |
| **enableNetworkOptimization** | boolean | true   | æ˜¯å¦å¯ç”¨ç½‘ç»œä¼˜åŒ– |

### å®‰å…¨é…ç½®å‚æ•°

| å‚æ•°å                 | ç±»å‹    | é»˜è®¤å€¼  | è¯´æ˜                  |
| ---------------------- | ------- | ------- | --------------------- |
| **sanitizeData**       | boolean | true    | æ˜¯å¦æ¸…ç†æ•æ„Ÿæ•°æ®      |
| **encryptReports**     | boolean | false   | æ˜¯å¦åŠ å¯†ä¸ŠæŠ¥æ•°æ®      |
| **anonymizeUserAgent** | boolean | true    | æ˜¯å¦åŒ¿ååŒ– User Agent |
| **limitReportSize**    | number  | 1048576 | æœ€å¤§æŠ¥å‘Šå¤§å°ï¼ˆå­—èŠ‚ï¼‰  |

```typescript
// Service Worker å®ç°
const heartbeatSW = `
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'HEARTBEAT') {
    // è®°å½•å¿ƒè·³
    self.clients.matchAll().then(clients => {
      clients.forEach(client => {
        // å¯ä»¥å‘ä¸»é¡µé¢å‘é€ç¡®è®¤æ¶ˆæ¯
        client.postMessage({
          type: 'HEARTBEAT_ACK',
          timestamp: Date.now()
        });
      });
    });
    
    // æ£€æŸ¥æ˜¯å¦é•¿æ—¶é—´æœªæ”¶åˆ°å¿ƒè·³
    checkForCrash(event.data);
  }
});

function checkForCrash(heartbeatData) {
  const lastHeartbeat = localStorage.getItem('last_heartbeat');
  if (lastHeartbeat) {
    const timeSinceLast = Date.now() - parseInt(lastHeartbeat);
    if (timeSinceLast > 15000) { // 15ç§’
      // å¯èƒ½å‘ç”Ÿå´©æºƒ
      reportCrash({
        type: 'POSSIBLE_CRASH',
        lastHeartbeat: parseInt(lastHeartbeat),
        currentHeartbeat: heartbeatData.timestamp,
        sessionId: heartbeatData.sessionId
      });
    }
  }
  
  // æ›´æ–°æœ€åå¿ƒè·³æ—¶é—´
  localStorage.setItem('last_heartbeat', heartbeatData.timestamp.toString());
}

function reportCrash(crashData) {
  // ä½¿ç”¨IndexedDBå­˜å‚¨å´©æºƒä¿¡æ¯
  // ç­‰å¾…é¡µé¢æ¢å¤åè¯»å–
}
`;

// æ³¨å†ŒService Worker
const registerServiceWorker = async () => {
	const blob = new Blob([heartbeatSW], { type: 'application/javascript' });
	const url = URL.createObjectURL(blob);

	try {
		const registration = await navigator.serviceWorker.register(url);
		console.log('Service Workeræ³¨å†ŒæˆåŠŸ');
		return registration;
	} catch (error) {
		console.error('Service Workeræ³¨å†Œå¤±è´¥:', error);
		throw error;
	}
};
```

### 2. é”™è¯¯è¾¹ç•Œå®ç°

```typescript
import React from 'react';

class ErrorBoundary extends React.Component<
	{
		children: React.ReactNode;
		fallback?: React.ComponentType<any>;
	},
	{
		hasError: boolean;
		error?: Error;
		errorInfo?: React.ErrorInfo;
	}
> {
	constructor(props: any) {
		super(props);
		this.state = { hasError: false };
	}

	static getDerivedStateFromError(error: Error) {
		// æ›´æ–°çŠ¶æ€ä»¥æ˜¾ç¤ºé™çº§UI
		return { hasError: true, error };
	}

	componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
		// è®°å½•é”™è¯¯ä¿¡æ¯
		this.setState({ errorInfo });

		// ä¸ŠæŠ¥é”™è¯¯
		this.reportError(error, errorInfo);
	}

	private reportError(error: Error, errorInfo: React.ErrorInfo) {
		const errorReport = {
			type: 'REACT_ERROR_BOUNDARY',
			error: {
				name: error.name,
				message: error.message,
				stack: error.stack
			},
			errorInfo: {
				componentStack: errorInfo.componentStack
			},
			timestamp: Date.now(),
			userAgent: navigator.userAgent,
			url: window.location.href
		};

		// ä¸ŠæŠ¥åˆ°ç›‘æ§ç³»ç»Ÿ
		this.sendToMonitoring(errorReport);
	}

	private sendToMonitoring(report: any) {
		// å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
		if (window.__CRASH_MONITOR__) {
			window.__CRASH_MONITOR__.report(report, 'EMERGENCY');
		}
	}

	render() {
		if (this.state.hasError) {
			const FallbackComponent = this.props.fallback || DefaultErrorFallback;
			return <FallbackComponent error={this.state.error} errorInfo={this.state.errorInfo} />;
		}

		return this.props.children;
	}
}

const DefaultErrorFallback: React.FC<{ error?: Error; errorInfo?: React.ErrorInfo }> = ({
	error,
	errorInfo
}) => (
	<div className="error-fallback">
		<h2>é¡µé¢å‡ºç°é”™è¯¯</h2>
		<p>è¯·åˆ·æ–°é¡µé¢é‡è¯•</p>
		{process.env.NODE_ENV === 'development' && (
			<details>
				<summary>é”™è¯¯è¯¦æƒ…</summary>
				<pre>{error?.stack}</pre>
			</details>
		)}
	</div>
);
```

### 3. æ€§èƒ½ç›‘æ§æœ€ä½³å®è·µ

```typescript
class PerformanceMonitor {
	private metrics: Map<string, number[]> = new Map();
	private thresholds = {
		firstContentfulPaint: 1500,
		largestContentfulPaint: 2500,
		cumulativeLayoutShift: 0.1,
		firstInputDelay: 100
	};

	constructor() {
		this.startPerformanceMonitoring();
	}

	private startPerformanceMonitoring() {
		// ç›‘æ§Core Web Vitals
		this.monitorFirstContentfulPaint();
		this.monitorLargestContentfulPaint();
		this.monitorCumulativeLayoutShift();
		this.monitorFirstInputDelay();

		// ç›‘æ§è‡ªå®šä¹‰æŒ‡æ ‡
		this.monitorCustomMetrics();
	}

	private monitorFirstContentfulPaint() {
		new PerformanceObserver(list => {
			list.getEntries().forEach(entry => {
				this.recordMetric('firstContentfulPaint', entry.startTime);

				if (entry.startTime > this.thresholds.firstContentfulPaint) {
					this.reportPerformanceIssue('firstContentfulPaint', entry.startTime);
				}
			});
		}).observe({ entryTypes: ['paint'] });
	}

	private monitorLargestContentfulPaint() {
		new PerformanceObserver(list => {
			const entries = list.getEntries();
			const lastEntry = entries[entries.length - 1];

			this.recordMetric('largestContentfulPaint', lastEntry.startTime);

			if (lastEntry.startTime > this.thresholds.largestContentfulPaint) {
				this.reportPerformanceIssue('largestContentfulPaint', lastEntry.startTime);
			}
		}).observe({ entryTypes: ['largest-contentful-paint'] });
	}

	private monitorCumulativeLayoutShift() {
		let clsValue = 0;

		new PerformanceObserver(list => {
			list.getEntries().forEach(entry => {
				if (!(entry as any).hadRecentInput) {
					clsValue += (entry as any).value;
					this.recordMetric('cumulativeLayoutShift', clsValue);

					if (clsValue > this.thresholds.cumulativeLayoutShift) {
						this.reportPerformanceIssue('cumulativeLayoutShift', clsValue);
					}
				}
			});
		}).observe({ entryTypes: ['layout-shift'] });
	}

	private monitorFirstInputDelay() {
		new PerformanceObserver(list => {
			list.getEntries().forEach(entry => {
				this.recordMetric('firstInputDelay', (entry as any).processingStart - entry.startTime);

				if ((entry as any).processingStart - entry.startTime > this.thresholds.firstInputDelay) {
					this.reportPerformanceIssue(
						'firstInputDelay',
						(entry as any).processingStart - entry.startTime
					);
				}
			});
		}).observe({ entryTypes: ['first-input'] });
	}

	private monitorCustomMetrics() {
		// ç›‘æ§è‡ªå®šä¹‰ä¸šåŠ¡æŒ‡æ ‡
		this.monitorPageLoadTime();
		this.monitorApiResponseTime();
		this.monitorUserInteractionTime();
	}

	private recordMetric(name: string, value: number) {
		if (!this.metrics.has(name)) {
			this.metrics.set(name, []);
		}

		const values = this.metrics.get(name)!;
		values.push(value);

		// åªä¿ç•™æœ€è¿‘100ä¸ªå€¼
		if (values.length > 100) {
			values.shift();
		}
	}

	private reportPerformanceIssue(metric: string, value: number) {
		const report = {
			type: 'PERFORMANCE_ISSUE',
			metric,
			value,
			threshold: this.thresholds[metric as keyof typeof this.thresholds],
			timestamp: Date.now(),
			url: window.location.href
		};

		// ä¸ŠæŠ¥æ€§èƒ½é—®é¢˜
		this.sendReport(report);
	}
}
```

## åº”ç”¨åœºæ™¯

### 1. ç”µå•†ç½‘ç«™ç›‘æ§

```typescript
// ç”µå•†ç½‘ç«™ä¸“ç”¨ç›‘æ§é…ç½®
const ecommerceMonitor = {
	// è´­ç‰©è½¦æ“ä½œç›‘æ§
	cartOperations: {
		addToCart: true,
		removeFromCart: true,
		updateQuantity: true
	},

	// æ”¯ä»˜æµç¨‹ç›‘æ§
	checkoutFlow: {
		startCheckout: true,
		paymentMethodSelected: true,
		paymentCompleted: true
	},

	// å•†å“é¡µé¢ç›‘æ§
	productPage: {
		imageLoadTime: true,
		reviewsLoadTime: true,
		recommendationsLoadTime: true
	},

	// è‡ªå®šä¹‰å¼‚å¸¸æ£€æµ‹
	customAnomalies: {
		cartAbandonment: {
			threshold: 300000, // 5åˆ†é’Ÿ
			action: 'report'
		},
		paymentFailure: {
			threshold: 3, // è¿ç»­3æ¬¡å¤±è´¥
			action: 'emergency'
		}
	}
};
```

### 2. é‡‘èäº¤æ˜“å¹³å°ç›‘æ§

```typescript
// é‡‘èäº¤æ˜“å¹³å°ç›‘æ§é…ç½®
const tradingPlatformMonitor = {
	// äº¤æ˜“æ“ä½œç›‘æ§
	tradingOperations: {
		orderPlacement: true,
		orderCancellation: true,
		positionUpdates: true
	},

	// è¡Œæƒ…æ•°æ®ç›‘æ§
	marketData: {
		priceUpdates: true,
		volumeUpdates: true,
		orderBookUpdates: true
	},

	// é£é™©æ§åˆ¶ç›‘æ§
	riskControl: {
		marginLevel: true,
		positionSize: true,
		stopLossTriggered: true
	},

	// é«˜ä¼˜å…ˆçº§å¼‚å¸¸
	highPriorityAnomalies: {
		priceDiscrepancy: {
			threshold: 0.01, // 1%ä»·æ ¼å·®å¼‚
			action: 'emergency'
		},
		orderFailure: {
			threshold: 1, // ä»»ä½•è®¢å•å¤±è´¥
			action: 'emergency'
		}
	}
};
```

### 3. åœ¨çº¿æ•™è‚²å¹³å°ç›‘æ§

```typescript
// åœ¨çº¿æ•™è‚²å¹³å°ç›‘æ§é…ç½®
const educationPlatformMonitor = {
	// è¯¾ç¨‹æ’­æ”¾ç›‘æ§
	videoPlayback: {
		videoLoadTime: true,
		playbackQuality: true,
		bufferingEvents: true
	},

	// äº’åŠ¨åŠŸèƒ½ç›‘æ§
	interactiveFeatures: {
		quizSubmission: true,
		liveChat: true,
		screenSharing: true
	},

	// å­¦ä¹ è¿›åº¦ç›‘æ§
	learningProgress: {
		lessonCompletion: true,
		quizResults: true,
		assignmentSubmission: true
	},

	// ç”¨æˆ·ä½“éªŒç›‘æ§
	userExperience: {
		pageLoadTime: true,
		navigationSmoothness: true,
		mobileResponsiveness: true
	}
};
```

## æ€§èƒ½åˆ†æ

### ç›‘æ§ç³»ç»Ÿæ€§èƒ½å¯¹æ¯”

```mermaid
graph LR
    A[ç›‘æ§æ–¹æ¡ˆ] --> B[ä¼ ç»Ÿé”™è¯¯ç›‘æ§]
    A --> C[Service Workerå¿ƒè·³]
    A --> D[å››å±‚ç›‘æ§ä½“ç³»]
    A --> E[AIæ™ºèƒ½ç›‘æ§]

    B --> B1[æ€§èƒ½å¼€é”€: <1%]
    B --> B2[æ£€æµ‹è¦†ç›–ç‡: 30%]
    B --> B3[å®ç°å¤æ‚åº¦: ä½]

    C --> C1[æ€§èƒ½å¼€é”€: 2%]
    C --> C2[æ£€æµ‹è¦†ç›–ç‡: 60%]
    C --> C3[å®ç°å¤æ‚åº¦: ä¸­]

    D --> D1[æ€§èƒ½å¼€é”€: 3%]
    D --> D2[æ£€æµ‹è¦†ç›–ç‡: 90%]
    D --> D3[å®ç°å¤æ‚åº¦: é«˜]

    E --> E1[æ€§èƒ½å¼€é”€: 5%]
    E --> E2[æ£€æµ‹è¦†ç›–ç‡: 95%]
    E --> E3[å®ç°å¤æ‚åº¦: å¾ˆé«˜]
```

### èµ„æºä½¿ç”¨ç»Ÿè®¡

| ç›‘æ§ç»„ä»¶     | CPU å ç”¨ | å†…å­˜å ç”¨ | ç½‘ç»œå¼€é”€ | å­˜å‚¨å ç”¨ |
| ------------ | -------- | -------- | -------- | -------- |
| **å¿ƒè·³ç›‘æµ‹** | 0.5%     | 1MB      | ä½       | ä½       |
| **æ€§èƒ½ç›‘æ§** | 1%       | 2MB      | ä¸­       | ä¸­       |
| **å¼‚å¸¸æ•è·** | 0.8%     | 1.5MB    | ä½       | ä½       |
| **æ™ºèƒ½ä¸ŠæŠ¥** | 0.3%     | 0.5MB    | é«˜       | ä¸­       |
| **æ€»è®¡**     | 2.6%     | 5MB      | ä¸­é«˜     | ä¸­       |

## å®‰å…¨è€ƒè™‘

### 1. æ•°æ®éšç§ä¿æŠ¤

```typescript
class DataPrivacyManager {
	private sensitiveDataPatterns = [/password/i, /credit.?card/i, /ssn/i, /email/i, /phone/i];

	sanitizeReport(report: any): any {
		const sanitized = JSON.parse(JSON.stringify(report));

		// ç§»é™¤æ•æ„Ÿä¿¡æ¯
		this.removeSensitiveData(sanitized);

		// åŒ¿ååŒ–ç”¨æˆ·æ ‡è¯†
		this.anonymizeUserIdentifier(sanitized);

		// é™åˆ¶æŠ¥å‘Šå¤§å°
		this.limitReportSize(sanitized);

		return sanitized;
	}

	private removeSensitiveData(obj: any) {
		if (typeof obj === 'string') {
			this.sensitiveDataPatterns.forEach(pattern => {
				if (pattern.test(obj)) {
					return '[REDACTED]';
				}
			});
		} else if (typeof obj === 'object' && obj !== null) {
			Object.keys(obj).forEach(key => {
				if (this.sensitiveDataPatterns.some(pattern => pattern.test(key))) {
					delete obj[key];
				} else {
					this.removeSensitiveData(obj[key]);
				}
			});
		}
		return obj;
	}

	private anonymizeUserIdentifier(report: any) {
		if (report.userAgent) {
			// ä¿ç•™æµè§ˆå™¨å’Œæ“ä½œç³»ç»Ÿä¿¡æ¯ï¼Œç§»é™¤è¯¦ç»†ç‰ˆæœ¬
			report.userAgent = this.sanitizeUserAgent(report.userAgent);
		}

		if (report.url) {
			// ç§»é™¤URLä¸­çš„æ•æ„Ÿå‚æ•°
			report.url = this.sanitizeUrl(report.url);
		}
	}

	private sanitizeUserAgent(userAgent: string): string {
		// ç®€åŒ–User Agentï¼Œç§»é™¤è¯¦ç»†ç‰ˆæœ¬ä¿¡æ¯
		return userAgent
			.replace(/Chrome\/[\d.]+/, 'Chrome')
			.replace(/Firefox\/[\d.]+/, 'Firefox')
			.replace(/Safari\/[\d.]+/, 'Safari');
	}

	private sanitizeUrl(url: string): string {
		try {
			const urlObj = new URL(url);
			// ç§»é™¤æ•æ„ŸæŸ¥è¯¢å‚æ•°
			['password', 'token', 'key', 'secret'].forEach(param => {
				if (urlObj.searchParams.has(param)) {
					urlObj.searchParams.delete(param);
				}
			});
			return urlObj.toString();
		} catch {
			return url;
		}
	}

	private limitReportSize(report: any) {
		const maxSize = 1024 * 1024; // 1MB
		const jsonString = JSON.stringify(report);

		if (jsonString.length > maxSize) {
			// æˆªæ–­è¿‡å¤§çš„æ•°æ®
			const truncated = JSON.parse(jsonString.substring(0, maxSize));
			truncated._truncated = true;
			return truncated;
		}

		return report;
	}
}
```

### 2. ä¸ŠæŠ¥å®‰å…¨æ§åˆ¶

```typescript
class SecureReporter {
	private encryptionKey: CryptoKey | null = null;
	private reportEndpoint = '/api/secure-reports';

	constructor() {
		this.initializeEncryption();
	}

	private async initializeEncryption() {
		try {
			this.encryptionKey = await crypto.subtle.generateKey({ name: 'AES-GCM', length: 256 }, true, [
				'encrypt',
				'decrypt'
			]);
		} catch (error) {
			console.warn('åŠ å¯†åˆå§‹åŒ–å¤±è´¥ï¼Œå°†ä½¿ç”¨æ˜æ–‡ä¸ŠæŠ¥');
		}
	}

	async reportSecurely(report: any) {
		try {
			// æ•°æ®éªŒè¯
			if (!this.validateReport(report)) {
				throw new Error('æŠ¥å‘Šæ•°æ®éªŒè¯å¤±è´¥');
			}

			// æ•°æ®åŠ å¯†
			const encryptedReport = await this.encryptReport(report);

			// å®‰å…¨ä¸ŠæŠ¥
			await this.sendEncryptedReport(encryptedReport);
		} catch (error) {
			console.error('å®‰å…¨ä¸ŠæŠ¥å¤±è´¥:', error);
			// é™çº§åˆ°æ™®é€šä¸ŠæŠ¥
			this.fallbackReport(report);
		}
	}

	private validateReport(report: any): boolean {
		// éªŒè¯æŠ¥å‘Šç»“æ„
		const requiredFields = ['type', 'timestamp', 'data'];
		return requiredFields.every(field => report[field] !== undefined);
	}

	private async encryptReport(report: any): Promise<string> {
		if (!this.encryptionKey) {
			return JSON.stringify(report);
		}

		const encoder = new TextEncoder();
		const data = encoder.encode(JSON.stringify(report));

		const iv = crypto.getRandomValues(new Uint8Array(12));
		const encrypted = await crypto.subtle.encrypt(
			{ name: 'AES-GCM', iv: iv },
			this.encryptionKey,
			data
		);

		return JSON.stringify({
			iv: Array.from(iv),
			data: Array.from(new Uint8Array(encrypted))
		});
	}

	private async sendEncryptedReport(encryptedData: string) {
		const response = await fetch(this.reportEndpoint, {
			method: 'POST',
			headers: {
				'Content-Type': 'application/json',
				'X-Encrypted': 'true'
			},
			body: encryptedData
		});

		if (!response.ok) {
			throw new Error(`ä¸ŠæŠ¥å¤±è´¥: ${response.status}`);
		}
	}

	private fallbackReport(report: any) {
		// é™çº§åˆ°æ™®é€šä¸ŠæŠ¥
		fetch('/api/reports', {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify(report)
		});
	}
}
```

## æ€»ç»“

å‰ç«¯å´©æºƒç›‘æ§æ˜¯ä¸€ä¸ªå¤æ‚çš„ç³»ç»Ÿå·¥ç¨‹ï¼Œéœ€è¦ä»å¤šä¸ªç»´åº¦æ¥ä¿éšœé¡µé¢çš„ç¨³å®šæ€§ã€‚é€šè¿‡æœ¬æ–‡ä»‹ç»çš„å››å±‚ç›‘æ§ä½“ç³»ï¼Œå¯ä»¥å®ç°ï¼š

1. **å…¨é¢è¦†ç›–**: ä» JavaScript é”™è¯¯åˆ°å†…å­˜æ³„æ¼ï¼Œä»æ­»å¾ªç¯åˆ°æ¸²æŸ“å´©æºƒ
2. **æ™ºèƒ½æ£€æµ‹**: åŸºäºå¤šç»´åº¦æŒ‡æ ‡çš„æ™ºèƒ½å´©æºƒåˆ¤æ–­
3. **æ— æ„Ÿç›‘æ§**: æœ€å°åŒ–å¯¹é¡µé¢æ€§èƒ½çš„å½±å“
4. **å®‰å…¨å¯é **: ç¡®ä¿ç›‘æ§æ•°æ®çš„å®‰å…¨æ€§å’Œéšç§ä¿æŠ¤

**å…³é”®è¦ç‚¹**ï¼š

- å¤šå±‚é˜²æŠ¤ç¡®ä¿ç›‘æ§å¯é æ€§
- æ™ºèƒ½ç®—æ³•å‡å°‘è¯¯æŠ¥ç‡
- æ€§èƒ½ä¼˜åŒ–ä¿è¯ç”¨æˆ·ä½“éªŒ
- å®‰å…¨æœºåˆ¶ä¿æŠ¤ç”¨æˆ·éšç§

**å®æ–½å»ºè®®**ï¼š

- æ ¹æ®ä¸šåŠ¡ç‰¹ç‚¹è°ƒæ•´ç›‘æ§ç­–ç•¥
- å®šæœŸåˆ†æç›‘æ§æ•°æ®ä¼˜åŒ–ç³»ç»Ÿ
- å»ºç«‹å®Œå–„çš„å‘Šè­¦å’Œå“åº”æœºåˆ¶
- æŒç»­ç›‘æ§å’Œæ”¹è¿›ç›‘æ§ç³»ç»Ÿ

é€šè¿‡è¿™å¥—å®Œæ•´çš„ç›‘æ§æ–¹æ¡ˆï¼Œå¯ä»¥æ˜¾è‘—æå‡ Web åº”ç”¨çš„ç¨³å®šæ€§å’Œç”¨æˆ·ä½“éªŒï¼Œå‡å°‘å› é¡µé¢å´©æºƒå¯¼è‡´çš„ç”¨æˆ·æµå¤±ã€‚

---

**æ€è€ƒé¢˜**ï¼šåœ¨ä½ çš„é¡¹ç›®ä¸­ï¼Œå¦‚ä½•å¹³è¡¡ç›‘æ§çš„å…¨é¢æ€§å’Œæ€§èƒ½å¼€é”€ï¼Ÿæ¬¢è¿åˆ†äº«ä½ çš„å®è·µç»éªŒï¼
