---
title: Canvas画布
date: 2025-09-03 11:33:00
permalink: /notes/canvas-draw-d
description: Canvas画布
categories:
  - 笔记
tags:
  - JS
  - Canvas
  - 绘制
---

# Canvas 画布基础知识

## 1. Canvas 画布尺寸概念

Canvas 有两种不同的尺寸概念，理解这两者的区别对于正确渲染图形至关重要：

### 1.1 画布尺寸（Canvas Dimensions）

- 通过 HTML 属性 `width` 和 `height` 或 JavaScript 属性 `canvas.width` 和 `canvas.height` 设置
- 定义了图形绘制的实际区域（绘制缓冲区大小）
- 默认值为 300px × 150px
- 单位是物理像素

```html
<!-- HTML 方式设置画布尺寸 -->
<canvas id="myCanvas" width="600" height="400"></canvas>

<!-- JavaScript 方式设置画布尺寸 -->
<script>
	const canvas = document.getElementById('myCanvas');
	canvas.width = 600;
	canvas.height = 400;
</script>
```

### 1.2 画板尺寸（Display Size）

- 通过 CSS 样式的 `width` 和 `height` 属性设置
- 定义了 Canvas 元素在屏幕上显示的大小
- 单位是 CSS 像素

```html
<!-- 内联样式方式设置画板尺寸 -->
<canvas id="myCanvas" style="width: 600px; height: 400px;"></canvas>

<!-- 外部样式表方式设置画板尺寸 -->
<style>
	#myCanvas {
		width: 600px;
		height: 400px;
	}
</style>
```

### 1.3 尺寸不一致导致的问题

当画布尺寸和画板尺寸不一致时，浏览器会对画布进行缩放以适应画板尺寸，这会导致以下问题：

- 图形变形失真
- 线条模糊不清
- 像素精度丢失

为避免这些问题，应保持画布尺寸和画板尺寸一致，或者按照设备像素比例进行适当调整。

## 2. 高清屏适配（devicePixelRatio）

### 2.1 设备像素比概念

`window.devicePixelRatio` 是设备物理像素和 CSS 像素之间的比率：

- 标准显示器：devicePixelRatio = 1（1 个 CSS 像素 = 1 个物理像素）
- 高清显示器（如 Retina 屏）：devicePixelRatio = 2（1 个 CSS 像素 = 4 个物理像素）
- 超高清显示器：devicePixelRatio = 3 或更高

### 2.2 高清屏适配方法

在高分辨率屏幕上，如果不进行适配，Canvas 绘制的图形会显得模糊，因为一个 Canvas 像素会被拉伸到多个物理像素上显示。解决方法如下：

```javascript
/**
 * 使Canvas在高清屏上显示清晰
 * @param {HTMLCanvasElement} canvas - Canvas元素
 * @param {CanvasRenderingContext2D} context - Canvas上下文
 */
function setupHiDPICanvas(canvas, context) {
	// 获取设备像素比
	const dpr = window.devicePixelRatio || 1;

	// 获取Canvas的CSS显示尺寸
	const rect = canvas.getBoundingClientRect();

	// 设置Canvas画布尺寸为CSS尺寸 * 设备像素比
	canvas.width = rect.width * dpr;
	canvas.height = rect.height * dpr;

	// 使用CSS将Canvas缩小回原来的尺寸
	canvas.style.width = `${rect.width}px`;
	canvas.style.height = `${rect.height}px`;

	// 按设备像素比例缩放绘图上下文
	context.scale(dpr, dpr);

	return dpr;
}

// 使用示例
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
setupHiDPICanvas(canvas, ctx);

// 现在可以正常绘制，所有内容都会自动适配高清屏
ctx.fillStyle = 'red';
ctx.fillRect(0, 0, 100, 100); // 这里使用的是CSS像素单位
```

### 2.3 适配方法的两种实现

#### 方法一：使用 scale 缩放坐标系

```javascript
// 设置画布尺寸为CSS尺寸的DPR倍
canvas.width = canvas.clientWidth * window.devicePixelRatio;
canvas.height = canvas.clientHeight * window.devicePixelRatio;

// 缩放坐标系
ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

// 之后正常绘制，使用CSS像素单位
ctx.fillRect(0, 0, 100, 100);
```

#### 方法二：手动缩放每个绘制操作

```javascript
// 设置画布尺寸为CSS尺寸的DPR倍
canvas.width = canvas.clientWidth * window.devicePixelRatio;
canvas.height = canvas.clientHeight * window.devicePixelRatio;

// 不缩放坐标系，而是手动缩放每个绘制操作
const dpr = window.devicePixelRatio;
ctx.fillRect(0, 0, 100 * dpr, 100 * dpr);
ctx.lineWidth = 2 * dpr;
// 其他绘制操作也需要乘以dpr
```

## 3. 小程序 Canvas 适配方案

### 3.1 小程序 Canvas 的特殊性

小程序环境下的 Canvas 有一些特殊的限制和注意事项：

- 微信小程序 Canvas 2D 存在 4096 像素的尺寸限制
- 小程序 Canvas API 不支持 `rpx` 单位，只能使用 `px`
- 不同设备屏幕尺寸差异大，需要动态计算适配比例

### 3.2 rpx 转 px 的适配方案

```javascript
/**
 * 小程序Canvas尺寸适配方案
 */
Page({
	data: {
		canvasWidth: 0,
		canvasHeight: 0,
		ratio: 1 // px与rpx的比例
	},

	onLoad() {
		// 获取设备信息
		const systemInfo = wx.getSystemInfo({
			success: res => {
				// 以iPhone6的屏幕宽度375px为基准
				// 计算当前设备的px与rpx比例
				const ratio = res.windowWidth / 750; // 750rpx = 375px

				this.setData({
					ratio,
					canvasWidth: 600 * ratio, // 假设设计稿上Canvas宽度为600rpx
					canvasHeight: 400 * ratio // 假设设计稿上Canvas高度为400rpx
				});
			}
		});
	},

	drawCanvas() {
		const { ratio } = this.data;
		const ctx = wx.createCanvasContext('myCanvas');

		// 绘制时所有尺寸都乘以比例
		ctx.fillStyle = 'red';
		ctx.fillRect(0, 0, 100 * ratio, 100 * ratio);

		// 文字大小也需要乘以比例
		ctx.setFontSize(16 * ratio);
		ctx.fillText('Hello Canvas', 10 * ratio, 130 * ratio);

		ctx.draw();
	}
});
```

### 3.3 淘宝小程序画布适配方案

淘宝小程序采用了更复杂的适配方案，包括：

1. 基于设计稿的等比例缩放
2. 分层渲染优化
3. 考虑不同设备的安全区域

```javascript
/**
 * 淘宝小程序Canvas适配核心代码示例
 */
class CanvasSizeCalculator {
	constructor(options) {
		this.designWidth = options.designWidth || 750; // 设计稿宽度，通常是750rpx
		this.designHeight = options.designHeight || 1334; // 设计稿高度
		this.deviceWidth = options.deviceWidth; // 设备实际宽度
		this.deviceHeight = options.deviceHeight; // 设备实际高度
		this.dpr = options.dpr || 1; // 设备像素比

		this.calculateRatio();
	}

	// 计算适配比例
	calculateRatio() {
		// 宽度适配比例
		this.widthRatio = this.deviceWidth / this.designWidth;
		// 高度适配比例
		this.heightRatio = this.deviceHeight / this.designHeight;
		// 取较小的比例，确保内容完全显示
		this.ratio = Math.min(this.widthRatio, this.heightRatio);
	}

	// 将设计稿上的尺寸转换为实际设备上的像素尺寸
	toPx(designSize) {
		return designSize * this.ratio;
	}

	// 获取画布实际尺寸
	getCanvasSize() {
		return {
			width: this.toPx(this.designWidth),
			height: this.toPx(this.designHeight),
			// 考虑高清屏
			physicalWidth: this.toPx(this.designWidth) * this.dpr,
			physicalHeight: this.toPx(this.designHeight) * this.dpr,
			ratio: this.ratio,
			dpr: this.dpr
		};
	}
}

// 使用示例
my.getSystemInfo({
	success: res => {
		const calculator = new CanvasSizeCalculator({
			deviceWidth: res.windowWidth,
			deviceHeight: res.windowHeight,
			dpr: res.pixelRatio
		});

		const canvasSize = calculator.getCanvasSize();

		// 设置Canvas尺寸
		this.setData({
			canvasWidth: canvasSize.width,
			canvasHeight: canvasSize.height,
			ratio: canvasSize.ratio
		});
	}
});
```

## 4. Canvas 性能优化

### 4.1 离屏渲染与缓存

对于复杂或重复的绘制，可以使用离屏 Canvas 进行缓存：

```javascript
// 创建离屏Canvas
const offscreenCanvas = document.createElement('canvas');
offscreenCanvas.width = 200;
offscreenCanvas.height = 200;
const offCtx = offscreenCanvas.getContext('2d');

// 在离屏Canvas上绘制复杂图形
function drawComplexShape(ctx) {
	// 绘制复杂图形...
	ctx.beginPath();
	for (let i = 0; i < 1000; i++) {
		ctx.lineTo(Math.cos(i / 50) * 95 + 100, Math.sin(i / 50) * 95 + 100);
	}
	ctx.stroke();
}

// 预先在离屏Canvas上绘制
drawComplexShape(offCtx);

// 主循环中直接使用离屏Canvas的结果
function render() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);

	// 直接绘制离屏Canvas的内容，而不是重新计算复杂图形
	ctx.drawImage(offscreenCanvas, 0, 0);

	requestAnimationFrame(render);
}

requestAnimationFrame(render);
```

### 4.2 批量绘制与对象池

```javascript
// 使用路径批量绘制多个图形
ctx.beginPath();
for (let i = 0; i < 100; i++) {
	ctx.rect(i * 10, i * 5, 8, 8);
}
// 一次性填充所有矩形
ctx.fill();

// 对象池示例 - 用于粒子系统等场景
class ParticlePool {
	constructor(size) {
		this.pool = [];
		this.size = size;
		this.createPool();
	}

	createPool() {
		for (let i = 0; i < this.size; i++) {
			this.pool.push({
				x: 0,
				y: 0,
				size: 0,
				color: '',
				active: false
			});
		}
	}

	getParticle() {
		for (let i = 0; i < this.size; i++) {
			if (!this.pool[i].active) {
				this.pool[i].active = true;
				return this.pool[i];
			}
		}
		return null; // 池已满
	}

	releaseParticle(particle) {
		particle.active = false;
	}
}
```

## 5. 响应式 Canvas 与窗口调整

```javascript
/**
 * 使Canvas响应窗口大小变化
 */
function setupResponsiveCanvas() {
	const canvas = document.getElementById('myCanvas');
	const ctx = canvas.getContext('2d');

	function resizeCanvas() {
		// 获取父容器尺寸或窗口尺寸
		const container = canvas.parentElement;
		const width = container.clientWidth;
		const height = container.clientHeight;

		// 获取设备像素比
		const dpr = window.devicePixelRatio || 1;

		// 设置Canvas尺寸
		canvas.width = width * dpr;
		canvas.height = height * dpr;
		canvas.style.width = `${width}px`;
		canvas.style.height = `${height}px`;

		// 缩放上下文
		ctx.scale(dpr, dpr);

		// 重新绘制内容
		drawContent();
	}

	function drawContent() {
		// 绘制内容...
		ctx.fillStyle = 'blue';
		ctx.fillRect(10, 10, 100, 100);
		ctx.font = '16px Arial';
		ctx.fillStyle = 'white';
		ctx.fillText('Responsive Canvas', 20, 50);
	}

	// 监听窗口大小变化
	window.addEventListener('resize', resizeCanvas);

	// 初始化
	resizeCanvas();
}

// 页面加载完成后设置响应式Canvas
window.addEventListener('load', setupResponsiveCanvas);
```

## 总结

Canvas 画布尺寸计算和适配是实现高质量 Canvas 应用的关键因素：

1. **理解两种尺寸**：画布尺寸（绘制缓冲区）和画板尺寸（显示尺寸）
2. **高清屏适配**：使用 `devicePixelRatio` 调整画布尺寸和绘制比例
3. **小程序适配**：处理 rpx 到 px 的转换，考虑设备差异和尺寸限制
4. **性能优化**：使用离屏渲染、批量绘制和对象池等技术提升性能
5. **响应式设计**：监听窗口变化，动态调整 Canvas 尺寸

正确的 Canvas 尺寸计算不仅能提升视觉质量，还能优化性能和用户体验，是 Canvas 应用开发中不可忽视的重要环节。

<demo react="react/Canvas/index.tsx" 
:reactFiles="[
	'react/Canvas/index.tsx',
'react/Canvas/index.scss',
'react/Canvas/HiDPICanvas.tsx',
'react/Canvas/BasicCanvas.tsx',
'react/Canvas/ResponsiveCanvas.tsx'
]" 
/>
