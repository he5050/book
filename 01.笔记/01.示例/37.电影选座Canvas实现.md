---
title: 电影选座Canvas实现
date: 2025-10-27 16:00:00
permalink: /example/movie-seat-selection
description: 使用Canvas实现协同电影选座功能，支持实时协作和座位状态管理
categories:
  - 示例
tags:
  - Canvas
  - React
  - 实时协作
  - 电影选座
---

# 电影选座 Canvas 实现

## 简介

使用 Canvas 技术实现一个协同电影选座系统，支持多用户实时协作选座。通过 Canvas 绘制座位图，结合 React 状态管理和事件处理，实现直观的座位选择体验。

## 效果特点

### 视觉特性

- **清晰显示**: 使用 Canvas 绘制高清座位图，支持设备像素比适配
- **状态区分**: 通过不同颜色区分座位状态（可选、已选、已售、他人已选）
- **交互反馈**: 提供鼠标悬停和点击反馈，增强用户体验
- **响应式设计**: 适配不同屏幕尺寸，保持良好显示效果

### 技术特性

- **Canvas 渲染**: 利用 Canvas 高性能绘制座位图
- **实时协作**: 支持多用户同时选座，状态实时同步
- **设备适配**: 自动适配高分辨率屏幕，确保清晰显示
- **组件化设计**: 提供完整的 React 组件实现，易于集成

## 工作原理

```
graph TD
    A[用户操作] --> B[Canvas事件处理]
    B --> C[座位状态检测]
    C --> D[状态更新]
    D --> E[Canvas重绘]
    E --> F[UI更新]
    D --> G[事件通知]
    G --> H[其他用户更新]
```

系统工作流程：

1. 用户在 Canvas 上进行点击或悬停操作
2. 系统通过像素级检测确定操作的座位
3. 更新座位状态并通知其他用户
4. 重新绘制 Canvas 以反映最新状态
5. 更新 UI 显示选中座位信息

## 效果演示

<demo react="react/effects/MovieSeatSelection/index.tsx" 
:reactFiles="['react/effects/MovieSeatSelection/index.tsx','react/effects/MovieSeatSelection/index.scss']" 
/>

## 核心实现原理

### 基础实现方案

**核心思路**：

- 使用 Canvas 绘制座位图，提高渲染性能
- 通过设备像素比适配确保高清显示
- 实现像素级点击检测，精确定位座位
- 采用状态管理模式，统一管理座位状态

**优点**：

- 性能优异，适合大量座位的渲染
- 显示清晰，支持高分辨率屏幕
- 交互流畅，提供即时反馈
- 易于扩展，支持多种座位布局

**适用场景**：

- 电影院在线选座系统
- 剧院座位管理系统
- 会议座位安排工具
- 体育场馆座位选择

### Canvas 渲染优化

Canvas 渲染是本组件的核心，通过以下优化确保高性能：

1. **设备像素比适配**：

   ```typescript
   const dpr = window.devicePixelRatio || 1;
   canvas.width = displayWidth * dpr;
   canvas.height = displayHeight * dpr;
   ctx.scale(dpr, dpr);
   ```

2. **座位布局设计**：

   ```typescript
   const SEAT_SIZE = 30; // 座位大小
   const SEAT_SPACING = 35; // 座位间距
   const ROW_SPACING = 40; // 行间距
   const CANVAS_PADDING = 50; // 画布边距
   const AISLE_WIDTH = 20; // 过道宽度
   ```

3. **状态颜色定义**：
   ```typescript
   const SEAT_COLORS = {
   	available: '#4CAF50', // 可选 - 绿色
   	selected: '#2196F3', // 已选 - 蓝色
   	occupied: '#F44336', // 已售 - 红色
   	selectedByOther: '#FF9800', // 他人已选 - 橙色
   	hover: '#81C784' // 悬停 - 浅绿色
   };
   ```

## 参数配置

### 基础参数

| 参数名        | 类型   | 默认值   | 说明            |
| ------------- | ------ | -------- | --------------- |
| **width**     | number | 600      | 组件宽度(px)    |
| **height**    | number | 400      | 组件高度(px)    |
| **userId**    | string | 随机生成 | 用户唯一标识    |
| **className** | string | ''       | 自定义 CSS 类名 |

### 事件回调

| 参数名           | 类型                    | 说明             |
| ---------------- | ----------------------- | ---------------- |
| **onSeatSelect** | (seats: Seat[]) => void | 座位选择变化回调 |

## 核心代码实现

```
import React, { useState, useEffect, useRef, useCallback } from 'react';
import './index.scss';

interface Seat {
	id: string;
	row: number;
	seat: number;
	status: 'available' | 'selected' | 'occupied' | 'selectedByOther';
	selectedBy?: string;
}

interface SeatData {
	rows: number;
	seatsPerRow: number;
	seats: Record<string, Seat>;
}

interface MovieSeatSelectionProps {
	width?: number;
	height?: number;
	onSeatSelect?: (seats: Seat[]) => void;
	userId?: string;
	className?: string;
}

// 座位颜色配置
const SEAT_COLORS = {
	available: '#4CAF50', // 可选 - 绿色
	selected: '#2196F3', // 已选 - 蓝色
	occupied: '#F44336', // 已售 - 红色
	selectedByOther: '#FF9800', // 他人已选 - 橙色
	hover: '#81C784' // 悬停 - 浅绿色
};

// 座位配置常量
const SEAT_SIZE = 30; // 座位大小
const SEAT_SPACING = 35; // 座位间距
const ROW_SPACING = 40; // 行间距
const CANVAS_PADDING = 50; // 画布边距
const AISLE_WIDTH = 20; // 过道宽度

const MovieSeatSelection: React.FC<MovieSeatSelectionProps> = ({
	width = 600,
	height = 400,
	onSeatSelect,
	userId = Math.random().toString(36).substr(2, 9),
	className = ''
}) => {
	const canvasRef = useRef<HTMLCanvasElement>(null);
	const [seatData, setSeatData] = useState<SeatData | null>(null);
	const [hoveredSeat, setHoveredSeat] = useState<string | null>(null);
	const [selectedSeats, setSelectedSeats] = useState<Seat[]>([]);
	const [confirmedSeats, setConfirmedSeats] = useState<Seat[]>([]);

	// 初始化座位数据
	useEffect(() => {
		const rows = 8;
		const seatsPerRow = 12;
		const seats: Record<string, Seat> = {};

		for (let row = 0; row < rows; row++) {
			for (let seat = 0; seat < seatsPerRow; seat++) {
				const seatId = `${row}-${seat}`;
				seats[seatId] = {
					id: seatId,
					row,
					seat,
					status: Math.random() > 0.7 ? 'occupied' : 'available'
				};
			}
		}

		setSeatData({
			rows,
			seatsPerRow,
			seats
		});
	}, []);

	// 设备像素比适配
	const drawSeatMap = useCallback(() => {
		if (!seatData || !canvasRef.current) return;

		const canvas = canvasRef.current;
		const ctx = canvas.getContext('2d');
		if (!ctx) return;

		// 获取设备像素比
		const dpr = window.devicePixelRatio || 1;

		// 获取Canvas的显示尺寸
		const rect = canvas.getBoundingClientRect();
		const displayWidth = rect.width;
		const displayHeight = rect.height;

		// 设置Canvas的实际像素尺寸
		canvas.width = displayWidth * dpr;
		canvas.height = displayHeight * dpr;

		// 缩放绘图上下文以匹配设备像素比
		ctx.scale(dpr, dpr);

		// 设置Canvas的CSS尺寸
		canvas.style.width = displayWidth + 'px';
		canvas.style.height = displayHeight + 'px';

		// 清除画布
		ctx.clearRect(0, 0, displayWidth, displayHeight);

		// 绘制屏幕
		ctx.fillStyle = '#333';
		ctx.fillRect(CANVAS_PADDING, CANVAS_PADDING, displayWidth - CANVAS_PADDING * 2, 40);
		ctx.fillStyle = '#fff';
		ctx.font = '16px Arial';
		ctx.textAlign = 'center';
		ctx.fillText('SCREEN', displayWidth / 2, CANVAS_PADDING + 25);

		// 绘制座位
		for (let row = 0; row < seatData.rows; row++) {
			for (let seat = 0; seat < seatData.seatsPerRow; seat++) {
				const seatId = `${row}-${seat}`;
				const seatInfo = seatData.seats[seatId];
				drawSeat(ctx, row, seat, seatInfo, seatId);
			}
		}

		// 绘制行号
		ctx.fillStyle = '#333';
		ctx.font = '14px Arial';
		ctx.textAlign = 'center';
		for (let row = 0; row < seatData.rows; row++) {
			const y = CANVAS_PADDING + 60 + row * ROW_SPACING + SEAT_SIZE / 2 + 5;
			ctx.fillText(`${row + 1}`, CANVAS_PADDING / 2, y);
		}
	}, [seatData, hoveredSeat]); // 移除了userId依赖，因为它不会改变

	// 绘制圆角矩形
	const drawRoundedRect = (
		ctx: CanvasRenderingContext2D,
		x: number,
		y: number,
		width: number,
		height: number,
		radius: number
	) => {
		ctx.beginPath();
		ctx.moveTo(x + radius, y);
		ctx.lineTo(x + width - radius, y);
		ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
		ctx.lineTo(x + width, y + height - radius);
		ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
		ctx.lineTo(x + radius, y + height);
		ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
		ctx.lineTo(x, y + radius);
		ctx.quadraticCurveTo(x, y, x + radius, y);
		ctx.closePath();
	};

	// 绘制单个座位
	const drawSeat = (
		ctx: CanvasRenderingContext2D,
		row: number,
		seat: number,
		seatInfo: Seat,
		seatId: string
	) => {
		// 计算座位位置，第6座后添加过道
		const x = CANVAS_PADDING + seat * SEAT_SPACING + (seat >= 6 ? AISLE_WIDTH : 0);
		const y = CANVAS_PADDING + 60 + row * ROW_SPACING;

		// 根据座位状态确定颜色
		let color = SEAT_COLORS.available;
		if (seatInfo.status === 'occupied') {
			color = SEAT_COLORS.occupied;
		} else if (seatInfo.status === 'selected') {
			color = seatInfo.selectedBy === userId ? SEAT_COLORS.selected : SEAT_COLORS.selectedByOther;
		} else if (hoveredSeat === seatId) {
			color = SEAT_COLORS.hover;
		}

		// 绘制圆角矩形座位
		ctx.fillStyle = color;
		drawRoundedRect(ctx, x, y, SEAT_SIZE, SEAT_SIZE, 5);
		ctx.fill();

		// 绘制座位编号
		if (seatInfo.status !== 'occupied') {
			ctx.fillStyle = '#fff';
			ctx.font = '12px Arial';
			ctx.textAlign = 'center';
			ctx.textBaseline = 'middle';
			ctx.fillText(`${seat + 1}`, x + SEAT_SIZE / 2, y + SEAT_SIZE / 2);
		}
	};

	// 重绘座位图
	useEffect(() => {
		drawSeatMap();
	}, [seatData, hoveredSeat, drawSeatMap]); // 确保依赖项正确

	// 窗口大小变化时重绘
	useEffect(() => {
		const handleResize = () => {
			drawSeatMap();
		};

		window.addEventListener('resize', handleResize);
		return () => window.removeEventListener('resize', handleResize);
	}, [drawSeatMap]);

	// 处理Canvas点击事件
	const handleCanvasClick = (event: React.MouseEvent<HTMLCanvasElement>) => {
		if (!seatData || !canvasRef.current) return;

		const canvas = canvasRef.current;
		const rect = canvas.getBoundingClientRect();
		const x = event.clientX - rect.left;
		const y = event.clientY - rect.top;

		// 遍历所有座位进行碰撞检测
		for (let row = 0; row < seatData.rows; row++) {
			for (let seat = 0; seat < seatData.seatsPerRow; seat++) {
				const seatX = CANVAS_PADDING + seat * SEAT_SPACING + (seat >= 6 ? AISLE_WIDTH : 0);
				const seatY = CANVAS_PADDING + 60 + row * ROW_SPACING;

				if (x >= seatX && x <= seatX + SEAT_SIZE && y >= seatY && y <= seatY + SEAT_SIZE) {
					const seatId = `${row}-${seat}`;
					const seatInfo = seatData.seats[seatId];

					if (seatInfo && seatInfo.status !== 'occupied') {
						// 切换选择状态
						const newSeatData = { ...seatData };
						if (seatInfo.status === 'selected' && seatInfo.selectedBy === userId) {
							newSeatData.seats[seatId] = {
								...seatInfo,
								status: 'available',
								selectedBy: undefined
							};
						} else {
							newSeatData.seats[seatId] = {
								...seatInfo,
								status: 'selected',
								selectedBy: userId
							};
						}
						setSeatData(newSeatData);

						// 更新选中座位列表
						const selected = Object.values(newSeatData.seats).filter(
							s => s.status === 'selected' && s.selectedBy === userId
						);
						setSelectedSeats(selected);
						onSeatSelect?.(selected);
					}
					return;
				}
			}
		}
	};

	// 处理鼠标移动事件
	const handleCanvasMouseMove = (event: React.MouseEvent<HTMLCanvasElement>) => {
		if (!seatData || !canvasRef.current) return;

		const canvas = canvasRef.current;
		const rect = canvas.getBoundingClientRect();
		const x = event.clientX - rect.left;
		const y = event.clientY - rect.top;

		let foundSeat = null;

		// 查找鼠标悬停的座位
		for (let row = 0; row < seatData.rows; row++) {
			for (let seat = 0; seat < seatData.seatsPerRow; seat++) {
				const seatX = CANVAS_PADDING + seat * SEAT_SPACING + (seat >= 6 ? AISLE_WIDTH : 0);
				const seatY = CANVAS_PADDING + 60 + row * ROW_SPACING;

				if (x >= seatX && x <= seatX + SEAT_SIZE && y >= seatY && y <= seatY + SEAT_SIZE) {
					foundSeat = `${row}-${seat}`;
					break;
				}
			}
			if (foundSeat) break;
		}

		if (foundSeat !== hoveredSeat) {
			setHoveredSeat(foundSeat);
		}
	};

	// 处理鼠标离开事件
	const handleCanvasMouseLeave = () => {
		setHoveredSeat(null);
	};

	// 处理确认选座
	const handleConfirmSeats = () => {
		if (selectedSeats.length === 0 || !seatData) return;

		// 更新座位状态为已售
		const newSeatData = { ...seatData };
		selectedSeats.forEach(seat => {
		  const seatId = `${seat.row}-${seat.seat}`;
		  if (newSeatData.seats && newSeatData.seats[seatId]) {
		    newSeatData.seats[seatId] = {
		      ...newSeatData.seats[seatId],
		      status: 'occupied',
		      selectedBy: undefined
		    };
		  }
		});

		setSeatData(newSeatData);
		setConfirmedSeats([...selectedSeats]);
		setSelectedSeats([]);
		alert(`已确认座位: ${selectedSeats.map(s => `${s.row + 1}排${s.seat + 1}座`).join(', ')}`);
	};

	// 重置选座
	const handleResetSeats = () => {
		if (!seatData) return;

		// 将已确认的座位恢复为可选状态
		const newSeatData = { ...seatData };
		confirmedSeats.forEach(seat => {
		  const seatId = `${seat.row}-${seat.seat}`;
		  if (newSeatData.seats && newSeatData.seats[seatId]) {
		    newSeatData.seats[seatId] = {
		      ...newSeatData.seats[seatId],
		      status: 'available',
		      selectedBy: undefined
		    };
		  }
		});

		setSeatData(newSeatData);
		setConfirmedSeats([]);
	};

	return (
		<div className={`movie-seat-selection ${className}`} style={{ width, height }}>
			<div className="seat-selection-header">
				<h3>电影选座</h3>
				<div className="legend">
					<div className="legend-item">
						<div className="legend-color available"></div>
						<span>可选</span>
					</div>
					<div className="legend-item">
						<div className="legend-color selected"></div>
						<span>已选</span>
					</div>
					<div className="legend-item">
						<div className="legend-color occupied"></div>
						<span>已售</span>
					</div>
					<div className="legend-item">
						<div className="legend-color selected-by-other"></div>
						<span>他人已选</span>
					</div>
				</div>
			</div>
			<div className="canvas-container">
				<canvas
					ref={canvasRef}
					onClick={handleCanvasClick}
					onMouseMove={handleCanvasMouseMove}
					onMouseLeave={handleCanvasMouseLeave}
					width={width}
					height={height - 80}
				/>
			</div>
			<div className="selection-info">
				<div className="selected-seats">
					已选座位: {selectedSeats.map(s => `${s.row + 1}排${s.seat + 1}座`).join(', ') || '无'}
				</div>
				<button
					className="confirm-button"
					disabled={selectedSeats.length === 0}
					onClick={handleConfirmSeats}
				>
					确认选座
				</button>
				{confirmedSeats.length > 0 && (
					<button
						className="reset-button"
						onClick={handleResetSeats}
					>
						重置选座
					</button>
				)}
			</div>
		</div>
	);
};

export default MovieSeatSelection;
```

## 样式实现

```
.movie-seat-selection {
	display: flex;
	flex-direction: column;
	height: 100%;
	background: #f5f5f5;
	border-radius: 8px;
	box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);

	.seat-selection-header {
		padding: 16px;
		background: #fff;
		border-bottom: 1px solid #eee;
		border-radius: 8px 8px 0 0;

		h3 {
			margin: 0 0 12px 0;
			color: #333;
			font-size: 18px;
		}

		.legend {
			display: flex;
			flex-wrap: wrap;
			gap: 16px;

			.legend-item {
				display: flex;
				align-items: center;
				gap: 4px;
				font-size: 12px;

				.legend-color {
					width: 16px;
					height: 16px;
					border-radius: 3px;

					&.available {
						background: #4caf50;
					}

					&.selected {
						background: #2196f3;
					}

					&.occupied {
						background: #f44336;
					}

					&.selected-by-other {
						background: #ff9800;
					}
				}
			}
		}
	}

	.canvas-container {
		flex: 1;
		overflow: auto;
		background: #fff;

		canvas {
			display: block;
			width: 100%;
			height: 100%;
		}
	}

	.selection-info {
		display: flex;
		justify-content: space-between;
		align-items: center;
		padding: 16px;
		background: #fff;
		border-top: 1px solid #eee;
		border-radius: 0 0 8px 8px;

		.selected-seats {
			flex: 1;
			font-size: 14px;
			color: #666;
			margin-right: 16px;
			white-space: nowrap;
			overflow: hidden;
			text-overflow: ellipsis;
		}

		.confirm-button {
			padding: 8px 16px;
			background: #2196f3;
			color: white;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;

			&:disabled {
				background: #ccc;
				cursor: not-allowed;
			}

			&:hover:not(:disabled) {
				background: #1976d2;
			}
		}

		.reset-button {
			padding: 8px 16px;
			background: #FF9800;
			color: white;
			border: none;
			border-radius: 4px;
			cursor: pointer;
			font-size: 14px;
			margin-left: 10px;

			&:hover {
				background: #F57C00;
			}
		}
	}
}

// Responsive design
@media (max-width: 768px) {
	.movie-seat-selection {
		.seat-selection-header {
			.legend {
				gap: 8px;

				.legend-item {
					font-size: 10px;

					.legend-color {
						width: 12px;
						height: 12px;
					}
				}
			}
		}

		.selection-info {
			flex-direction: column;
			gap: 12px;
			align-items: flex-start;

			.selected-seats {
				margin-right: 0;
				width: 100%;
			}

			.confirm-button {
				width: 100%;
			}
		}
	}
}
```

## 实现方案对比

| 方案            | 优点                 | 缺点             | 适用场景             |
| --------------- | -------------------- | ---------------- | -------------------- |
| **Canvas 绘制** | 性能好，适合大量数据 | 开发复杂度高     | 座位数量多的场景     |
| **DOM 元素**    | 开发简单，易于维护   | 性能较差         | 座位数量少的场景     |
| **SVG 实现**    | 矢量图形，可缩放     | 复杂交互实现困难 | 需要高质量图形的场景 |
| **第三方库**    | 功能完善，开箱即用   | 增加项目体积     | 快速开发需求         |

## 最佳实践

### 设计原则

1. **性能优化**: 使用 Canvas 渲染大量座位，确保流畅体验
2. **用户体验**: 提供清晰的状态标识和即时反馈
3. **响应式**: 适配不同屏幕尺寸，保持良好显示效果
4. **可访问性**: 考虑无障碍访问需求

### 实施建议

1. **座位布局**: 根据实际影院布局设计座位排列
2. **状态管理**: 合理管理座位状态，确保数据一致性
3. **交互设计**: 提供直观的交互反馈，增强用户操作体验
4. **性能监控**: 监控渲染性能，及时优化

## 应用场景

### 1. 在线电影票务系统

```
// 在在线电影票务系统中使用电影选座组件
import MovieSeatSelection from './components/MovieSeatSelection';

const MovieTicketBooking = () => {
	const handleSeatSelect = seats => {
		// 处理座位选择
		console.log('选中座位:', seats);
	};

	return (
		<div className="movie-booking">
			<h1>选择座位</h1>
			<MovieSeatSelection width={800} height={600} onSeatSelect={handleSeatSelect} />
		</div>
	);
};
```

### 2. 剧院座位管理系统

```
// 在剧院座位管理系统中使用
const TheaterSeatManager = () => {
	const [userId] = useState('admin');

	return (
		<div className="theater-manager">
			<MovieSeatSelection
				userId={userId}
				onSeatSelect={seats => {
					// 管理员可以管理所有座位状态
					console.log('座位状态更新:', seats);
				}}
			/>
		</div>
	);
};
```

### 3. 教学演示

```
// 用于教学演示的交互式示例
const DemoPage = () => {
	const [config, setConfig] = useState({
		width: 600,
		height: 500
	});

	return (
		<div className="demo-page">
			<MovieSeatSelection {...config} />
			<div className="controls">{/* 控制面板用于实时调整参数 */}</div>
		</div>
	);
};
```

## 故障排除

### 1. Canvas 渲染异常

**问题**: Canvas 无法正常渲染或显示模糊
**解决方案**:

- 检查设备像素比适配是否正确实现
- 确认 Canvas 尺寸设置是否正确
- 验证绘图上下文是否正常获取

### 2. 座位点击无响应

**问题**: 点击座位没有反应或响应错误
**解决方案**:

- 检查像素级碰撞检测算法是否正确
- 确认事件监听器是否正确绑定
- 验证座位状态更新逻辑是否正确

### 3. 性能问题

**问题**: 座位数量多时出现卡顿
**解决方案**:

- 优化 Canvas 重绘逻辑，避免不必要的重绘
- 使用 requestAnimationFrame 优化动画性能
- 考虑虚拟滚动等技术优化大量数据渲染

## 相关资源

### 推荐工具

- **Canvas API**: HTML5 Canvas 绘图接口
- **React Hooks**: 状态和副作用管理
- **CSS3**: 样式和动画实现
- **TypeScript**: 类型安全的 JavaScript 开发

### 参考文档

- [Canvas API](https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API)
- [React 官方文档](https://reactjs.org/)
- [TypeScript 官方文档](https://www.typescriptlang.org/)
- [devicePixelRatio](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/devicePixelRatio)
