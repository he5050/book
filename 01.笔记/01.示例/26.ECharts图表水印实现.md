---
title: ECharts图表水印实现
date: 2025-09-25
permalink: /notes/echarts-watermark
categories:
  - 笔记
  - 示例
---

# ECharts 图表水印实现

## 简介

在数据可视化项目中，保护图表数据的安全性和版权是非常重要的。ECharts 图表水印是一种专门为 ECharts 图表设计的水印解决方案，它将水印集成到图表的背景中，既能起到防护作用，又不会影响图表的正常交互。

但水印的应用不仅限于图表，我们还可以在整个页面或指定的 DOM 节点上实现水印效果。本文将详细介绍多种水印实现方案，包括 ECharts 图表水印、整个页面水印以及指定 DOM 节点水印。

## 方案特点

### ECharts 图表水印优势

1. **专门针对图表优化**：完美解决了图表场景下的水印需求，不会影响图表交互和美观
2. **导出图片自带水印**：省去了导出后手动加水印的麻烦，保证了导出内容的完整性
3. **不影响图表交互**：用户可以像往常一样操作图表，水印不会成为障碍
4. **视觉效果自然**：水印与图表背景融为一体，不会显得突兀，提升了整体的专业感

### 页面级水印优势

1. **覆盖范围广**：可以为整个页面添加水印保护
2. **实现简单**：通过 Canvas 绘制水印图案，应用到页面背景
3. **防篡改机制**：利用 MutationObserver 监听 DOM 变化，实现水印的自动恢复
4. **高度自定义**：可以完全控制水印的样式、位置、透明度等属性

### 指定 DOM 节点水印优势

1. **精准控制**：只为特定的 DOM 元素添加水印
2. **性能优化**：只在需要的区域渲染水印，减少性能开销
3. **灵活应用**：可以根据业务需求为不同的区域设置不同的水印

## 实现原理

### ECharts 图表水印实现原理

ECharts 图表水印的实现原理与自定义 Canvas 水印有异曲同工之妙，都是利用 Canvas 绘制水印图案。不同的是，这里我们将 Canvas 绘制出的图案作为 ECharts 图表的 backgroundColor，通过 `type: 'pattern'` 和 `image: canvas` 的方式，让水印图案在图表背景中重复平铺。

### 页面级水印实现原理

页面级水印通过以下步骤实现：

1. **Canvas 绘制水印图案**：创建 Canvas 元素并绘制水印内容
2. **生成背景图片**：将 Canvas 内容转换为 Data URL 作为背景图片
3. **创建水印容器**：创建一个覆盖整个页面的 div 元素作为水印容器
4. **应用背景图片**：将生成的背景图片应用到水印容器
5. **防篡改机制**：使用 MutationObserver 监听 DOM 变化，防止水印被删除或修改

### 指定 DOM 节点水印实现原理

指定 DOM 节点水印与页面级水印类似，但应用范围更精确：

1. **Canvas 绘制水印图案**：创建 Canvas 元素并绘制水印内容
2. **生成背景图片**：将 Canvas 内容转换为 Data URL 作为背景图片
3. **定位目标节点**：获取需要添加水印的 DOM 元素
4. **应用背景图片**：将生成的背景图片应用到目标节点
5. **防篡改机制**：使用 MutationObserver 监听目标节点变化

## 核心实现

### ECharts 图表水印核心代码

```javascript
// 创建水印 Canvas
const canvas = document.createElement('canvas');
const ctx = canvas.getContext('2d');

// 配置 Canvas 尺寸
canvas.width = canvas.height = 100;

// 配置文字样式
ctx.textAlign = 'center';
ctx.textBaseline = 'middle';
ctx.globalAlpha = 0.08; // 设置水印透明度
ctx.font = '20px Microsoft Yahei';

// 设置文字位置和角度
ctx.translate(50, 50);
ctx.rotate(-Math.PI / 4); // 逆时针旋转 45 度

// 绘制水印文字
ctx.fillText('WATERMARK', 0, 0);

// ECharts 配置
const option = {
	// 使用水印作为背景
	backgroundColor: {
		type: 'pattern', // 背景类型为图案
		image: canvas, // 使用我们绘制的 Canvas 作为图案来源
		repeat: 'repeat' // 图案重复平铺
	}
	// 其他图表配置...
};
```

### 页面级水印核心代码

```javascript
// utils/watermark.js
export const watermark = {
	set: function (text1, text2) {
		// 1. 创建 Canvas 元素
		const canvas = document.createElement('canvas');
		canvas.width = 150;
		canvas.height = 120;
		canvas.style.display = 'none'; // 隐藏 Canvas 元素

		// 2. 获取 2D 绘图上下文
		const ctx = canvas.getContext('2d');

		// 3. 设置文字样式和位置
		ctx.rotate((-20 * Math.PI) / 180); // 逆时针旋转 20 度，让水印倾斜
		ctx.translate(-50, 20); // 调整文字的起始绘制位置
		ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; // 设置文字颜色
		ctx.font = '16px Microsoft Yahei'; // 设置字体样式和大小

		// 4. 绘制水印文字
		ctx.fillText(text1, canvas.width / 3, canvas.height / 2);
		ctx.fillText(text2, canvas.width / 3, canvas.height / 2 + 20);

		// 5. 创建水印容器
		const watermarkDiv = document.createElement('div');
		// 构建水印容器的样式字符串
		const styleStr = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 99999;
      pointer-events: none;
      background-repeat: repeat;
      background-image: url('${canvas.toDataURL('image/png')}')
    `;

		watermarkDiv.setAttribute('style', styleStr);
		watermarkDiv.classList.add('watermark-container');
		document.body.appendChild(watermarkDiv);

		// 6. 防篡改监听机制
		const observer = new MutationObserver(() => {
			const wmInstance = document.body.querySelector('.watermark-container');

			// 检测水印是否被删除或修改
			if (!wmInstance || wmInstance.getAttribute('style') !== styleStr) {
				if (wmInstance) {
					// 样式被修改，重新设置
					wmInstance.setAttribute('style', styleStr);
				} else {
					// 元素被删除，重新添加
					document.body.appendChild(watermarkDiv);
				}
			}
		});

		// 7. 开始监听 DOM 变化
		observer.observe(document.body, {
			attributes: true,
			subtree: true,
			childList: true
		});
	},

	close: function () {
		// 移除水印
		let watermark = document.body.querySelector('.watermark-container');
		if (watermark) {
			document.body.removeChild(watermark);
		}
	}
};
```

### 指定 DOM 节点水印核心代码

```javascript
// 为指定 DOM 节点添加水印
function addWatermarkToElement(element, text) {
	if (!element) return;

	// 1. 创建 Canvas 元素
	const canvas = document.createElement('canvas');
	canvas.width = 150;
	canvas.height = 100;

	// 2. 获取 2D 绘图上下文
	const ctx = canvas.getContext('2d');

	// 3. 设置文字样式和位置
	ctx.rotate((-20 * Math.PI) / 180); // 逆时针旋转 20 度
	ctx.translate(-30, 20); // 调整文字位置
	ctx.fillStyle = 'rgba(0, 0, 0, 0.15)'; // 设置文字颜色和透明度
	ctx.font = '14px Microsoft Yahei'; // 设置字体

	// 4. 绘制水印文字
	ctx.fillText(text, canvas.width / 3, canvas.height / 2);

	// 5. 应用水印到指定元素
	element.style.position = 'relative';
	element.style.backgroundImage = `url('${canvas.toDataURL('image/png')}')`;
	element.style.backgroundRepeat = 'repeat';

	// 6. 创建防篡改监听器
	const observer = new MutationObserver(() => {
		// 检查背景是否被修改
		if (element.style.backgroundImage !== `url('${canvas.toDataURL('image/png')}')`) {
			element.style.backgroundImage = `url('${canvas.toDataURL('image/png')}')`;
		}
	});

	// 7. 开始监听元素变化
	observer.observe(element, {
		attributes: true,
		attributeFilter: ['style']
	});

	return observer; // 返回观察器，便于后续清理
}
```

## React 组件实现

### ECharts 图表水印组件

<demo react="react/Watermark/EchartsWatermark.tsx"
:reactFiles="['react/Watermark/EchartsWatermark.tsx']"
/>

<!-- ### 页面级水印 React 组件

<demo react="react/Watermark/PageWatermark.tsx"
:reactFiles="['react/Watermark/PageWatermark.tsx']"
/> -->

<!-- ### 指定 DOM 节点水印 React 组件

<demo react="react/Watermark/DomWatermark.tsx"
:reactFiles="['react/Watermark/DomWatermark.tsx']"
/> -->

### 完整示例

<demo react="react/Watermark/WatermarkDemo.tsx"
:reactFiles="['react/Watermark/WatermarkDemo.tsx', 'react/Watermark/EchartsWatermark.tsx', 'react/Watermark/PageWatermark.tsx', 'react/Watermark/DomWatermark.tsx']"
/>

## 方案对比

| 特性       | 自定义 Canvas | ECharts 图表 |
| ---------- | ------------- | ------------ |
| 实现难度   | ⭐⭐⭐⭐      | ⭐⭐         |
| 防篡改能力 | ⭐⭐⭐⭐⭐    | ⭐⭐⭐       |
| 定制化程度 | ⭐⭐⭐⭐⭐    | ⭐⭐⭐       |
| 性能表现   | ⭐⭐⭐        | ⭐⭐⭐⭐     |
| 通用性     | ⭐⭐⭐⭐⭐    | ⭐⭐         |
| 维护成本   | ⭐⭐          | ⭐⭐⭐⭐     |

## 最佳实践建议

### 选择合适的方案

1. **高安全性项目**：自定义 Canvas 方案

   - 适用于对水印安全性要求极高的项目，如金融、政府等敏感领域

2. **数据可视化项目**：ECharts 图表水印方案

   - 专门针对 ECharts 图表优化，适用于大量使用图表的数据可视化项目

3. **全页面保护**：页面级水印方案

   - 适用于需要为整个页面添加水印保护的场景

4. **局部保护**：指定 DOM 节点水印方案
   - 适用于只需要为页面特定区域添加水印的场景

### 使用建议

1. **合理设置透明度**：水印透明度应设置得较低（0.05-0.15），以免影响内容阅读
2. **选择合适的字体**：使用系统默认字体或确保字体在所有设备上都能正常显示
3. **控制水印密度**：通过调整 Canvas 尺寸控制水印的重复密度，避免过于密集
4. **考虑导出需求**：ECharts 图表水印在导出图片时会自动包含，这是其独特优势
5. **性能优化**：对于大页面或复杂 DOM 结构，考虑使用指定 DOM 节点水印以减少性能开销

## 防篡改机制详解

### MutationObserver 的使用

MutationObserver 是实现水印防篡改的核心技术，它能够监听 DOM 树的变化，包括：

1. **属性变化**：监听元素属性的修改
2. **子节点变化**：监听子节点的添加和删除
3. **子树变化**：监听整个子树的修改

### 防篡改实现要点

1. **监听范围**：根据水印应用范围确定监听的 DOM 节点
2. **检测机制**：通过比对水印元素的属性和内容判断是否被篡改
3. **恢复机制**：当检测到篡改时，自动恢复水印到原始状态
4. **性能考虑**：合理设置监听选项，避免不必要的性能开销

## 结语

通过本文的介绍，我们了解了多种水印实现方案：

1. **ECharts 图表水印**：专为数据可视化场景设计，水印与图表背景完美融合
2. **页面级水印**：为整个页面提供水印保护，具有强大的防篡改能力
3. **指定 DOM 节点水印**：为特定区域提供精准的水印保护，性能更优

在实际项目中，我们可以根据具体需求选择合适的水印方案，甚至可以结合多种方案实现更全面的保护。例如，在整个页面使用自定义 Canvas 水印作为基础保护，同时在重要的 ECharts 图表中使用图表水印以确保导出内容的安全性。
