---
title: è¯­éŸ³æŠ¥è­¦åŠŸèƒ½å®ç°
date: 2025-11-26 23:00:00
permalink: /notes/demo-voice-alert
description: åŸºäºWeb Speech APIå®ç°çš„è¯­éŸ³æŠ¥è­¦åŠŸèƒ½ï¼Œæ”¯æŒå¤šæµè§ˆå™¨ã€å¯é…ç½®å‚æ•°å’Œæ¶ˆæ¯ç®¡ç†
categories:
  - ç¬”è®°
  - ç¤ºä¾‹
tags:
  - è¯­éŸ³æŠ¥è­¦
  - Web Speech API
---

# è¯­éŸ³æŠ¥è­¦åŠŸèƒ½å®ç°

## ç®€ä»‹

æœ¬æ–‡æ¡£ä»‹ç»äº†ä¸€ä¸ªå®Œæ•´çš„ æ¶ˆæ¯è¯­éŸ³æŠ¥è­¦å®ç°æ–¹æ¡ˆï¼ŒåŸºäº Web Speech API å®ç°ï¼ŒåŒ…å«å¤šç§è¯­éŸ³æ’­æŠ¥æ–¹å¼å’Œè‡ªå®šä¹‰é…ç½®ã€‚è¯¥æ–¹æ¡ˆæä¾›äº†å®Œæ•´çš„è¯­éŸ³æŠ¥è­¦åŠŸèƒ½ï¼Œæ”¯æŒéŸ³é‡ã€è¯­é€Ÿã€éŸ³è°ƒè°ƒèŠ‚ï¼Œæ¶ˆæ¯å†å²è®°å½•ç®¡ç†ï¼Œä»¥åŠä¼˜å…ˆçº§å¤„ç†ç­‰åŠŸèƒ½ã€‚

## æ•ˆæœæ¼”ç¤º

<demo react="react/VoiceAlert/demo.tsx" 
:reactFiles="['react/VoiceAlert/demo.tsx','react/VoiceAlert/index.tsx','react/VoiceAlert/index.scss']" 
/>

## å·¥ä½œåŸç†

```mermaid
graph TD
    A[è¯­éŸ³æŠ¥è­¦ç³»ç»Ÿ] --> B[è¯­éŸ³æœåŠ¡æ ¸å¿ƒ]
    A --> C[ç»„ä»¶ç•Œé¢]
    A --> D[äº‹ä»¶æ€»çº¿]

    B --> B1[Web Speech API]
    B --> B2[å‚æ•°é…ç½®ç®¡ç†]
    B --> B3[æ¶ˆæ¯é˜Ÿåˆ—å¤„ç†]
    B --> B4[é™çº§æ–¹æ¡ˆ]

    C --> C1[æ§åˆ¶é¢æ¿]
    C --> C2[æ¶ˆæ¯åˆ—è¡¨]
    C --> C3[æ“ä½œæŒ‰é’®]

    D --> D1[å…¨å±€äº‹ä»¶ç›‘å¬]
    D --> D2[æ¶ˆæ¯åˆ†å‘]
```

## æ ¸å¿ƒå®ç°

### 1. è¯­éŸ³æœåŠ¡ç±»å®ç°

```typescript
// src/utils/voiceAlert.js (è½¬æ¢ä¸ºTypeScript)
class VoiceAlert {
	private synth: SpeechSynthesis | null = null;
	private isSupported: boolean = false;
	private isSpeaking: boolean = false;
	private utterance: SpeechSynthesisUtterance | null = null;
	private volume: number = 1;
	private rate: number = 1;
	private pitch: number = 1;
	private voice: SpeechSynthesisVoice | null = null;
	private voices: SpeechSynthesisVoice[] = [];

	constructor() {
		this.synth = window.speechSynthesis;
		this.isSupported = !!this.synth;
		this.init();
	}

	private init() {
		if (!this.isSupported) {
			console.warn('æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆAPI');
			return;
		}

		// åŠ è½½å¯ç”¨è¯­éŸ³åˆ—è¡¨
		this.loadVoices();

		// è¯­éŸ³åˆ—è¡¨åŠ è½½äº‹ä»¶
		this.synth.addEventListener('voiceschanged', () => {
			this.loadVoices();
		});
	}

	private loadVoices() {
		this.voices = this.synth.getVoices();
		// ä¼˜å…ˆé€‰æ‹©ä¸­æ–‡è¯­éŸ³
		const chineseVoice = this.voices.find(
			voice => voice.lang.includes('zh') || voice.lang.includes('CN')
		);
		this.voice = chineseVoice || this.voices[0];
	}

	// æ’­æŠ¥è­¦æŠ¥æ¶ˆæ¯
	alert(message: string, options: any = {}) {
		if (!this.isSupported) return false;

		// åœæ­¢å½“å‰æ’­æŠ¥
		this.stop();

		this.utterance = new SpeechSynthesisUtterance(message);

		// è®¾ç½®å‚æ•°
		this.utterance.volume = options.volume || this.volume;
		this.utterance.rate = options.rate || this.rate;
		this.utterance.pitch = options.pitch || this.pitch;
		this.utterance.voice = options.voice || this.voice;
		this.utterance.lang = options.lang || 'zh-CN';

		// äº‹ä»¶ç›‘å¬
		this.utterance.onstart = () => {
			this.isSpeaking = true;
			options.onStart && options.onStart();
		};

		this.utterance.onend = () => {
			this.isSpeaking = false;
			options.onEnd && options.onEnd();
		};

		this.utterance.onerror = error => {
			this.isSpeaking = false;
			console.error('è¯­éŸ³æ’­æŠ¥é”™è¯¯:', error);
			options.onError && options.onError(error);

			// é™çº§æ–¹æ¡ˆï¼šå°è¯•ä½¿ç”¨éŸ³é¢‘æ–‡ä»¶
			if (options.fallbackAudio) {
				this.playAudioFallback(options.fallbackAudio);
			}
		};

		this.synth.speak(this.utterance);
		return true;
	}

	// æ’­æ”¾éŸ³é¢‘æ–‡ä»¶é™çº§æ–¹æ¡ˆ
	private playAudioFallback(audioUrl: string) {
		const audio = new Audio(audioUrl);
		audio.play().catch(error => {
			console.error('éŸ³é¢‘æ’­æ”¾å¤±è´¥:', error);
		});
	}

	// åœæ­¢æ’­æŠ¥
	stop() {
		if (this.isSpeaking) {
			this.synth.cancel();
			this.isSpeaking = false;
		}
	}

	// æš‚åœæ’­æŠ¥
	pause() {
		if (this.isSpeaking) {
			this.synth.pause();
		}
	}

	// æ¢å¤æ’­æŠ¥
	resume() {
		if (this.synth.paused) {
			this.synth.resume();
		}
	}

	// è®¾ç½®è¯­éŸ³å‚æ•°
	setVoiceParams(params: any) {
		if (params.volume !== undefined) this.volume = params.volume;
		if (params.rate !== undefined) this.rate = params.rate;
		if (params.pitch !== undefined) this.pitch = params.pitch;
		if (params.voice !== undefined) this.voice = params.voice;
	}

	// è·å–å¯ç”¨è¯­éŸ³åˆ—è¡¨
	getVoices() {
		return this.voices || [];
	}

	// æ£€æŸ¥æµè§ˆå™¨æ”¯æŒæƒ…å†µ
	checkSupport() {
		return this.isSupported;
	}
}
```

### 2. React ç»„ä»¶å®ç°

```typescript
// VoiceAlertç»„ä»¶æ ¸å¿ƒé€»è¾‘
interface VoiceAlertProps {
	maxAlerts?: number; // æœ€å¤§ä¿å­˜æ¶ˆæ¯æ•°é‡
	autoSpeak?: boolean; // è‡ªåŠ¨æ’­æŠ¥æ–°æ¶ˆæ¯
	showControlPanel?: boolean; // æ˜¾ç¤ºæ§åˆ¶é¢æ¿
}

interface AlertMessage {
	id: number;
	message: string;
	type: 'info' | 'warning' | 'error' | 'success';
	timestamp: Date;
	priority: number;
}

const VoiceAlert: React.FC<VoiceAlertProps> = ({
	maxAlerts = 50,
	autoSpeak = true,
	showControlPanel = false
}) => {
	// çŠ¶æ€ç®¡ç†
	const [isSupported, setIsSupported] = useState(false);
	const [isSpeaking, setIsSpeaking] = useState(false);
	const [showControl, setShowControl] = useState(showControlPanel);
	const [volume, setVolume] = useState(1);
	const [rate, setRate] = useState(1);
	const [pitch, setPitch] = useState(1);
	const [selectedVoice, setSelectedVoice] = useState<SpeechSynthesisVoice | null>(null);
	const [availableVoices, setAvailableVoices] = useState<SpeechSynthesisVoice[]>([]);
	const [recentAlerts, setRecentAlerts] = useState<AlertMessage[]>([]);
	const [alertCounter, setAlertCounter] = useState(0);

	// å¼•ç”¨
	const voiceAlertRef = useRef<any>(null);
	const synthRef = useRef<SpeechSynthesis | null>(null);

	// åˆå§‹åŒ–
	useEffect(() => {
		// æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
		const isSupported = 'speechSynthesis' in window;
		setIsSupported(isSupported);

		if (isSupported) {
			synthRef.current = window.speechSynthesis;
			const voices = synthRef.current.getVoices();
			setAvailableVoices(voices);
			setSelectedVoice(voices[0] || null);

			// è¯­éŸ³åˆ—è¡¨å¯èƒ½å¼‚æ­¥åŠ è½½
			if (voices.length === 0) {
				const handleVoicesChanged = () => {
					const newVoices = synthRef.current!.getVoices();
					setAvailableVoices(newVoices);
					setSelectedVoice(newVoices[0] || null);
				};

				synthRef.current.addEventListener('voiceschanged', handleVoicesChanged);

				// æ¸…ç†äº‹ä»¶ç›‘å¬å™¨
				return () => {
					synthRef.current!.removeEventListener('voiceschanged', handleVoicesChanged);
				};
			}
		}

		// åˆ›å»ºè¯­éŸ³æœåŠ¡å®ä¾‹
		voiceAlertRef.current = {
			synth: synthRef.current,
			isSupported,
			isSpeaking: false,
			utterance: null,
			volume: 1,
			rate: 1,
			pitch: 1,
			voice: null,

			alert(message: string, options: any = {}) {
				if (!this.isSupported) return false;

				// åœæ­¢å½“å‰æ’­æŠ¥
				this.stop();

				this.utterance = new SpeechSynthesisUtterance(message);
				this.utterance.volume = options.volume || this.volume;
				this.utterance.rate = options.rate || this.rate;
				this.utterance.pitch = options.pitch || this.pitch;
				this.utterance.voice = options.voice || this.voice;
				this.utterance.lang = options.lang || 'zh-CN';

				this.utterance.onstart = () => {
					this.isSpeaking = true;
					setIsSpeaking(true);
					options.onStart && options.onStart();
				};

				this.utterance.onend = () => {
					this.isSpeaking = false;
					setIsSpeaking(false);
					options.onEnd && options.onEnd();
				};

				this.utterance.onerror = (error: any) => {
					this.isSpeaking = false;
					setIsSpeaking(false);
					console.error('è¯­éŸ³æ’­æŠ¥é”™è¯¯:', error);
					options.onError && options.onError(error);
				};

				this.synth!.speak(this.utterance);
				return true;
			},

			stop() {
				if (this.isSpeaking && this.synth) {
					this.synth.cancel();
					this.isSpeaking = false;
					setIsSpeaking(false);
				}
			},

			setVoiceParams(params: any) {
				if (params.volume !== undefined) this.volume = params.volume;
				if (params.rate !== undefined) this.rate = params.rate;
				if (params.pitch !== undefined) this.pitch = params.pitch;
				if (params.voice !== undefined) this.voice = params.voice;
			}
		};

		return () => {
			if (voiceAlertRef.current) {
				voiceAlertRef.current.stop();
			}
		};
	}, []);

	// å¤„ç†æ–°æŠ¥è­¦æ¶ˆæ¯
	const handleNewAlert = (alertData: Omit<AlertMessage, 'id' | 'timestamp'>) => {
		const alert: AlertMessage = {
			id: alertCounter + 1,
			message: alertData.message,
			type: alertData.type || 'info',
			timestamp: new Date(),
			priority: alertData.priority || 1
		};

		setAlertCounter(prev => prev + 1);

		// æ·»åŠ åˆ°æ¶ˆæ¯åˆ—è¡¨
		setRecentAlerts(prev => {
			const newAlerts = [alert, ...prev];
			// é™åˆ¶æ¶ˆæ¯æ•°é‡
			return newAlerts.slice(0, maxAlerts);
		});

		// è‡ªåŠ¨æ’­æŠ¥
		if (autoSpeak && isSupported) {
			speakAlert(alert);
		}
	};

	// æ’­æŠ¥è­¦æŠ¥æ¶ˆæ¯
	const speakAlert = (alert: AlertMessage) => {
		const message = formatAlertMessage(alert);

		if (voiceAlertRef.current) {
			voiceAlertRef.current.alert(message, {
				volume,
				rate,
				pitch,
				voice: selectedVoice,
				onStart: () => {
					setIsSpeaking(true);
				},
				onEnd: () => {
					setIsSpeaking(false);
				},
				onError: (error: any) => {
					setIsSpeaking(false);
					console.error('è¯­éŸ³æ’­æŠ¥å¤±è´¥:', error);
				}
			});
		}
	};

	// æ ¼å¼åŒ–æŠ¥è­¦æ¶ˆæ¯
	const formatAlertMessage = (alert: AlertMessage) => {
		const prefixes = {
			error: 'ç´§æ€¥æŠ¥è­¦ï¼š',
			warning: 'è­¦å‘Šï¼š',
			info: 'é€šçŸ¥ï¼š',
			success: 'æ­£å¸¸ï¼š'
		};

		const prefix = prefixes[alert.type] || '';
		return prefix + alert.message;
	};

	// åœæ­¢æ’­æŠ¥
	const stopSpeaking = () => {
		if (voiceAlertRef.current) {
			voiceAlertRef.current.stop();
		}
	};

	// æ›´æ–°è¯­éŸ³å‚æ•°
	const updateVoiceParams = () => {
		if (voiceAlertRef.current) {
			voiceAlertRef.current.setVoiceParams({
				volume,
				rate,
				pitch,
				voice: selectedVoice
			});
		}
	};

	// ç§»é™¤æŠ¥è­¦æ¶ˆæ¯
	const removeAlert = (alertId: number) => {
		setRecentAlerts(prev => prev.filter(alert => alert.id !== alertId));
	};

	// æ¸…ç©ºæ‰€æœ‰æ¶ˆæ¯
	const clearAlerts = () => {
		setRecentAlerts([]);
	};

	// åˆ‡æ¢æ§åˆ¶é¢æ¿æ˜¾ç¤º
	const toggleControl = () => {
		setShowControl(!showControl);
	};

	// æµ‹è¯•è¯­éŸ³
	const testVoice = () => {
		handleNewAlert({
			message: 'è¿™æ˜¯ä¸€æ¡æµ‹è¯•è¯­éŸ³æ¶ˆæ¯ï¼Œå½“å‰è¯­éŸ³è®¾ç½®æ­£å¸¸ã€‚',
			type: 'info'
		});
	};

	// æ ¼å¼åŒ–æ—¶é—´
	const formatTime = (timestamp: Date) => {
		return timestamp.toLocaleTimeString('zh-CN', {
			hour12: false,
			hour: '2-digit',
			minute: '2-digit',
			second: '2-digit'
		});
	};

	return (
		<div className="voice-alert">
			{/* è¯­éŸ³æ§åˆ¶é¢æ¿ */}
			{showControl && (
				<div className="voice-control-panel">
					<div className="control-item">
						<label>éŸ³é‡:</label>
						<input
							type="range"
							min="0"
							max="1"
							step="0.1"
							value={volume}
							onChange={e => setVolume(parseFloat(e.target.value))}
						/>
						<span>{(volume * 100).toFixed(0)}%</span>
					</div>

					<div className="control-item">
						<label>è¯­é€Ÿ:</label>
						<input
							type="range"
							min="0.1"
							max="2"
							step="0.1"
							value={rate}
							onChange={e => setRate(parseFloat(e.target.value))}
						/>
						<span>{rate}</span>
					</div>

					<div className="control-item">
						<label>éŸ³è°ƒ:</label>
						<input
							type="range"
							min="0.1"
							max="2"
							step="0.1"
							value={pitch}
							onChange={e => setPitch(parseFloat(e.target.value))}
						/>
						<span>{pitch}</span>
					</div>

					<div className="control-item">
						<label>è¯­éŸ³:</label>
						<select
							value={selectedVoice?.name || ''}
							onChange={e => {
								const voice = availableVoices.find(v => v.name === e.target.value);
								setSelectedVoice(voice || null);
							}}
						>
							{availableVoices.map(voice => (
								<option key={voice.name} value={voice.name}>
									{voice.name} ({voice.lang})
								</option>
							))}
						</select>
					</div>
				</div>
			)}

			{/* æŠ¥è­¦æ¶ˆæ¯åˆ—è¡¨ */}
			<div className="alert-list">
				{recentAlerts.map(alert => (
					<div key={alert.id} className={`alert-item ${alert.type}`}>
						<div className="alert-content">
							<span className="alert-time">{formatTime(alert.timestamp)}</span>
							<span className="alert-message">{alert.message}</span>
						</div>
						<div className="alert-actions">
							<button onClick={() => speakAlert(alert)}>ğŸ”Š</button>
							<button onClick={() => removeAlert(alert.id)}>Ã—</button>
						</div>
					</div>
				))}
			</div>

			{/* æ§åˆ¶æŒ‰é’® */}
			<div className="control-buttons">
				<button onClick={toggleControl}>{showControl ? 'éšè—è®¾ç½®' : 'è¯­éŸ³è®¾ç½®'}</button>
				<button onClick={stopSpeaking} disabled={!isSpeaking}>
					åœæ­¢æ’­æŠ¥
				</button>
				<button onClick={clearAlerts}>æ¸…ç©ºæ¶ˆæ¯</button>
				<button onClick={testVoice}>æµ‹è¯•è¯­éŸ³</button>
			</div>

			{/* æµè§ˆå™¨æ”¯æŒæç¤º */}
			{!isSupported && (
				<div className="browser-warning">
					âš ï¸ æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³åˆæˆåŠŸèƒ½ï¼Œè¯·ä½¿ç”¨Chromeã€Edgeç­‰ç°ä»£æµè§ˆå™¨
				</div>
			)}
		</div>
	);
};
```

## å‚æ•°é…ç½®è¯´æ˜

### 1. ç»„ä»¶å±æ€§é…ç½®

| å‚æ•°             | ç±»å‹    | é»˜è®¤å€¼ | è¯´æ˜                 |
| ---------------- | ------- | ------ | -------------------- |
| maxAlerts        | number  | 50     | æœ€å¤§ä¿å­˜æ¶ˆæ¯æ•°é‡     |
| autoSpeak        | boolean | true   | æ˜¯å¦è‡ªåŠ¨æ’­æŠ¥æ–°æ¶ˆæ¯   |
| showControlPanel | boolean | false  | æ˜¯å¦é»˜è®¤æ˜¾ç¤ºæ§åˆ¶é¢æ¿ |

### 2. è¯­éŸ³å‚æ•°é…ç½®

| å‚æ•°   | ç±»å‹                 | é»˜è®¤å€¼ | è¯´æ˜         |
| ------ | -------------------- | ------ | ------------ |
| volume | number               | 1      | éŸ³é‡ (0-1)   |
| rate   | number               | 1      | è¯­é€Ÿ (0.1-2) |
| pitch  | number               | 1      | éŸ³è°ƒ (0.1-2) |
| voice  | SpeechSynthesisVoice | null   | è¯­éŸ³ç±»å‹     |

### 3. æ¶ˆæ¯ç±»å‹é…ç½®

| ç±»å‹    | å‰ç¼€       | é¢œè‰² |
| ------- | ---------- | ---- |
| error   | ç´§æ€¥æŠ¥è­¦ï¼š | çº¢è‰² |
| warning | è­¦å‘Šï¼š     | æ©™è‰² |
| info    | é€šçŸ¥ï¼š     | è“è‰² |
| success | æ­£å¸¸ï¼š     | ç»¿è‰² |

## å®ç°æ–¹æ¡ˆå¯¹æ¯”

| æ–¹æ¡ˆ               | ä¼˜ç‚¹                   | ç¼ºç‚¹             | é€‚ç”¨åœºæ™¯       |
| ------------------ | ---------------------- | ---------------- | -------------- |
| **Web Speech API** | åŸç”Ÿæ”¯æŒï¼Œæ— éœ€é¢å¤–ä¾èµ– | æµè§ˆå™¨å…¼å®¹æ€§é™åˆ¶ | ç°ä»£æµè§ˆå™¨ç¯å¢ƒ |
| **ç¬¬ä¸‰æ–¹ TTS åº“**  | åŠŸèƒ½ä¸°å¯Œï¼Œå…¼å®¹æ€§å¥½     | å¢åŠ é¡¹ç›®ä½“ç§¯     | å¤æ‚è¯­éŸ³éœ€æ±‚   |
| **éŸ³é¢‘æ–‡ä»¶æ’­æ”¾**   | å…¼å®¹æ€§æœ€å¥½             | éœ€è¦é¢„å½•åˆ¶éŸ³é¢‘   | ç®€å•æç¤ºéŸ³åœºæ™¯ |

## åº”ç”¨åœºæ™¯

1. **ç³»ç»Ÿç›‘æ§æŠ¥è­¦**ï¼šæœåŠ¡å™¨çŠ¶æ€ç›‘æ§ã€æ€§èƒ½æŒ‡æ ‡å¼‚å¸¸æé†’
2. **IoT è®¾å¤‡æŠ¥è­¦**ï¼šä¼ æ„Ÿå™¨æ•°æ®è¶…é™ã€è®¾å¤‡æ•…éšœæé†’
3. **ä¸šåŠ¡ç³»ç»Ÿé€šçŸ¥**ï¼šè®¢å•çŠ¶æ€å˜æ›´ã€ä»»åŠ¡å®Œæˆæé†’
4. **å®‰å…¨ç³»ç»ŸæŠ¥è­¦**ï¼šå…¥ä¾µæ£€æµ‹ã€å¼‚å¸¸è¡Œä¸ºæé†’
5. **åŒ»ç–—ç›‘æŠ¤ç³»ç»Ÿ**ï¼šç”Ÿå‘½ä½“å¾å¼‚å¸¸ã€ç´§æ€¥æƒ…å†µæé†’

## æœ€ä½³å®è·µ

### 1. æ€§èƒ½ä¼˜åŒ–å»ºè®®

- åˆç†æ§åˆ¶æ¶ˆæ¯é˜Ÿåˆ—é•¿åº¦ï¼Œé¿å…å†…å­˜å ç”¨è¿‡é«˜
- å¯¹äºé«˜é¢‘æŠ¥è­¦ï¼Œå¢åŠ é˜²æŠ–å¤„ç†é¿å…è¯­éŸ³æ’­æ”¾å†²çª
- æä¾›æ‰¹é‡å¤„ç†åŠŸèƒ½ï¼Œæ”¯æŒä¸€æ¬¡æ’­æŠ¥å¤šæ¡æ¶ˆæ¯

### 2. ç”¨æˆ·ä½“éªŒä¼˜åŒ–

- æä¾›è¯­éŸ³å‚æ•°è°ƒèŠ‚ç•Œé¢ï¼Œæ»¡è¶³ä¸åŒç”¨æˆ·éœ€æ±‚
- æ”¯æŒæ¶ˆæ¯åˆ†ç±»æ˜¾ç¤ºå’Œè¿‡æ»¤
- æ·»åŠ æ¶ˆæ¯ä¼˜å…ˆçº§å¤„ç†ï¼Œé‡è¦æ¶ˆæ¯ä¼˜å…ˆæ’­æŠ¥

### 3. å…¼å®¹æ€§å¤„ç†

- æ£€æµ‹æµè§ˆå™¨æ”¯æŒæƒ…å†µï¼Œæä¾›é™çº§æ–¹æ¡ˆ
- å¯¹äºä¸æ”¯æŒè¯­éŸ³çš„ç¯å¢ƒï¼Œä½¿ç”¨ç³»ç»Ÿé€šçŸ¥æ›¿ä»£
- æä¾›éŸ³é¢‘æ–‡ä»¶ä½œä¸ºå¤‡ç”¨æ’­æŠ¥æ–¹å¼

## æ•…éšœæ’é™¤

### 1. è¯­éŸ³æ— æ³•æ’­æ”¾

**é—®é¢˜**: ç‚¹å‡»æ’­æŠ¥æŒ‰é’®æ— å£°éŸ³è¾“å‡º
**è§£å†³æ–¹æ¡ˆ**:

- æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒ Web Speech API
- ç¡®è®¤ç³»ç»ŸéŸ³é‡å’Œæµè§ˆå™¨éŸ³é‡è®¾ç½®
- éªŒè¯è¯­éŸ³å‚æ•°æ˜¯å¦æ­£ç¡®é…ç½®

### 2. è¯­éŸ³æ’­æ”¾å¡é¡¿

**é—®é¢˜**: è¯­éŸ³æ’­æ”¾ä¸æµç•…æˆ–ä¸­æ–­
**è§£å†³æ–¹æ¡ˆ**:

- é™ä½è¯­é€Ÿå‚æ•°å€¼
- æ£€æŸ¥ç½‘ç»œè¿æ¥çŠ¶æ€
- å‡å°‘åŒæ—¶æ’­æ”¾çš„è¯­éŸ³æ•°é‡

### 3. è¯­éŸ³è¯†åˆ«é”™è¯¯

**é—®é¢˜**: è¯­éŸ³æ’­æŠ¥å†…å®¹ä¸é¢„æœŸä¸ç¬¦
**è§£å†³æ–¹æ¡ˆ**:

- æ£€æŸ¥æ–‡æœ¬ç¼–ç æ ¼å¼
- éªŒè¯è¯­éŸ³åº“é€‰æ‹©æ˜¯å¦æ­£ç¡®
- ç¡®è®¤è¯­è¨€è®¾ç½®æ˜¯å¦åŒ¹é…

## æ€»ç»“

æœ¬æ–‡å®ç°çš„ è¯­éŸ³æŠ¥è­¦åŠŸèƒ½æä¾›äº†å®Œæ•´çš„è¯­éŸ³æ’­æŠ¥è§£å†³æ–¹æ¡ˆï¼Œå…·æœ‰ä»¥ä¸‹ç‰¹ç‚¹ï¼š

1. **å¤šæµè§ˆå™¨æ”¯æŒ**: åŸºäº Web Speech APIï¼Œæ”¯æŒç°ä»£æµè§ˆå™¨
2. **å¯é…ç½®å‚æ•°**: éŸ³é‡ã€è¯­é€Ÿã€éŸ³è°ƒã€è¯­éŸ³é€‰æ‹©
3. **æ¶ˆæ¯ç®¡ç†**: å†å²æ¶ˆæ¯è®°å½•å’Œæ¸…ç†
4. **ä¼˜å…ˆçº§å¤„ç†**: æ”¯æŒä¸åŒçº§åˆ«çš„æŠ¥è­¦æ¶ˆæ¯
5. **é™çº§æ–¹æ¡ˆ**: è¯­éŸ³åˆæˆå¤±è´¥æ—¶å¯ä½¿ç”¨éŸ³é¢‘æ–‡ä»¶
6. **æ˜“äºé›†æˆ**: å¯ä¸ MQTTã€WebSocket ç­‰å®æ—¶æ¶ˆæ¯ç³»ç»Ÿç»“åˆ

è¯¥å®ç°æ–¹æ¡ˆå¯æ ¹æ®å®é™…éœ€æ±‚è¿›è¡Œè°ƒæ•´å’Œæ‰©å±•ï¼Œé€‚ç”¨äºå„ç§éœ€è¦è¯­éŸ³æŠ¥è­¦åŠŸèƒ½çš„åœºæ™¯ã€‚
