---
title: å›¾ç‰‡æ”¾å¤§ç¼©å°åŠæ‹–æ‹½
date: 2025-07-20 21:56:30
permalink: /notes/image-view-size
categories:
  - å›¾ç‰‡
  - æ‹–æ‹½
  - æ”¾å¤§ç¼©å°
tags:
  - å›¾ç‰‡
  - æ‹–æ‹½
  - æ”¾å¤§ç¼©å°
  - å›¾ç‰‡æŸ¥çœ‹å™¨
---

# å›¾ç‰‡æ”¾å¤§ç¼©å°åŠæ‹–æ‹½å®ç°

å›¾ç‰‡æŸ¥çœ‹å™¨æ˜¯ç°ä»£ Web åº”ç”¨ä¸­çš„é‡è¦ç»„ä»¶ï¼Œæä¾›äº†ä¸°å¯Œçš„å›¾ç‰‡äº¤äº’åŠŸèƒ½ã€‚æœ¬æ–‡å°†è¯¦ç»†ä»‹ç»å¦‚ä½•å®ç°ä¸€ä¸ªåŠŸèƒ½å®Œå–„çš„å›¾ç‰‡æŸ¥çœ‹å™¨ï¼ŒåŒ…æ‹¬ç¼©æ”¾ã€æ‹–æ‹½ã€æ—‹è½¬ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚

## åŠŸèƒ½ç‰¹æ€§

### æ ¸å¿ƒäº¤äº’åŠŸèƒ½

- **ç¼©æ”¾æ§åˆ¶**: é¼ æ ‡æ»šè½®ã€åŒå‡»ã€æŒ‰é’®ç¼©æ”¾
- **æ‹–æ‹½ç§»åŠ¨**: é¼ æ ‡æ‹–æ‹½ã€è§¦æ‘¸æ»‘åŠ¨
- **æ—‹è½¬åŠŸèƒ½**: 90 åº¦æ—‹è½¬ã€ä»»æ„è§’åº¦æ—‹è½¬
- **é€‚åº”çª—å£**: è‡ªåŠ¨é€‚åº”å®¹å™¨å¤§å°
- **é‡ç½®è§†å›¾**: ä¸€é”®æ¢å¤åˆå§‹çŠ¶æ€

### é«˜çº§ç‰¹æ€§

- **è¾¹ç•Œé™åˆ¶**: é˜²æ­¢å›¾ç‰‡æ‹–æ‹½å‡ºå¯è§†åŒºåŸŸ
- **æƒ¯æ€§æ»‘åŠ¨**: æ‹–æ‹½é‡Šæ”¾åçš„æƒ¯æ€§æ•ˆæœ
- **æ‰‹åŠ¿æ”¯æŒ**: åŒæŒ‡ç¼©æ”¾ã€æ—‹è½¬æ‰‹åŠ¿
- **é”®ç›˜æ“ä½œ**: æ–¹å‘é”®ç§»åŠ¨ã€å¿«æ·é”®ç¼©æ”¾
- **å…¨å±æ¨¡å¼**: å…¨å±æŸ¥çœ‹å›¾ç‰‡

## ğŸ’» å®ç°æ¼”ç¤º

<demo react="react/Animate/ImageViewer/index.tsx"
:reactFiles="['react/Animate/ImageViewer/index.tsx','react/Animate/ImageViewer/index.scss']"
/>

## ğŸ› ï¸ æ ¸å¿ƒå®ç°åŸç†

### 1. åŸºç¡€å›¾ç‰‡æŸ¥çœ‹å™¨

```typescript
interface ImageViewerState {
	scale: number;
	translateX: number;
	translateY: number;
	rotation: number;
	isDragging: boolean;
	dragStart: { x: number; y: number };
}

interface ImageViewerProps {
	src: string;
	alt?: string;
	maxScale?: number;
	minScale?: number;
	scaleStep?: number;
	enableRotation?: boolean;
	enableDrag?: boolean;
	fitToContainer?: boolean;
}

const ImageViewer: React.FC<ImageViewerProps> = ({
	src,
	alt = '',
	maxScale = 5,
	minScale = 0.1,
	scaleStep = 0.2,
	enableRotation = true,
	enableDrag = true,
	fitToContainer = true
}) => {
	const containerRef = useRef<HTMLDivElement>(null);
	const imageRef = useRef<HTMLImageElement>(null);

	const [state, setState] = useState<ImageViewerState>({
		scale: 1,
		translateX: 0,
		translateY: 0,
		rotation: 0,
		isDragging: false,
		dragStart: { x: 0, y: 0 }
	});

	// ç¼©æ”¾åŠŸèƒ½
	const handleZoom = useCallback(
		(delta: number, centerX?: number, centerY?: number) => {
			setState(prev => {
				const newScale = Math.max(minScale, Math.min(maxScale, prev.scale + delta));

				if (centerX !== undefined && centerY !== undefined && containerRef.current) {
					// ä»¥æŒ‡å®šç‚¹ä¸ºä¸­å¿ƒç¼©æ”¾
					const rect = containerRef.current.getBoundingClientRect();
					const offsetX = centerX - rect.left - rect.width / 2;
					const offsetY = centerY - rect.top - rect.height / 2;

					const scaleRatio = newScale / prev.scale;
					const newTranslateX = prev.translateX - offsetX * (scaleRatio - 1);
					const newTranslateY = prev.translateY - offsetY * (scaleRatio - 1);

					return {
						...prev,
						scale: newScale,
						translateX: newTranslateX,
						translateY: newTranslateY
					};
				}

				return { ...prev, scale: newScale };
			});
		},
		[minScale, maxScale]
	);

	// é¼ æ ‡æ»šè½®ç¼©æ”¾
	const handleWheel = useCallback(
		(e: React.WheelEvent) => {
			e.preventDefault();
			const delta = e.deltaY > 0 ? -scaleStep : scaleStep;
			handleZoom(delta, e.clientX, e.clientY);
		},
		[handleZoom, scaleStep]
	);

	// åŒå‡»ç¼©æ”¾
	const handleDoubleClick = useCallback(
		(e: React.MouseEvent) => {
			const isZoomedIn = state.scale > 1;
			if (isZoomedIn) {
				// é‡ç½®åˆ°åŸå§‹å¤§å°
				setState(prev => ({
					...prev,
					scale: 1,
					translateX: 0,
					translateY: 0
				}));
			} else {
				// æ”¾å¤§åˆ°2å€
				handleZoom(1, e.clientX, e.clientY);
			}
		},
		[state.scale, handleZoom]
	);

	// æ‹–æ‹½å¼€å§‹
	const handleMouseDown = useCallback(
		(e: React.MouseEvent) => {
			if (!enableDrag) return;

			e.preventDefault();
			setState(prev => ({
				...prev,
				isDragging: true,
				dragStart: { x: e.clientX, y: e.clientY }
			}));
		},
		[enableDrag]
	);

	// æ‹–æ‹½ç§»åŠ¨
	const handleMouseMove = useCallback(
		(e: MouseEvent) => {
			if (!state.isDragging) return;

			const deltaX = e.clientX - state.dragStart.x;
			const deltaY = e.clientY - state.dragStart.y;

			setState(prev => ({
				...prev,
				translateX: prev.translateX + deltaX,
				translateY: prev.translateY + deltaY,
				dragStart: { x: e.clientX, y: e.clientY }
			}));
		},
		[state.isDragging, state.dragStart]
	);

	// æ‹–æ‹½ç»“æŸ
	const handleMouseUp = useCallback(() => {
		setState(prev => ({ ...prev, isDragging: false }));
	}, []);

	// æ—‹è½¬åŠŸèƒ½
	const handleRotate = useCallback(
		(angle: number) => {
			if (!enableRotation) return;

			setState(prev => ({
				...prev,
				rotation: (prev.rotation + angle) % 360
			}));
		},
		[enableRotation]
	);

	// é‡ç½®è§†å›¾
	const resetView = useCallback(() => {
		setState({
			scale: 1,
			translateX: 0,
			translateY: 0,
			rotation: 0,
			isDragging: false,
			dragStart: { x: 0, y: 0 }
		});
	}, []);

	// é€‚åº”å®¹å™¨
	const fitToView = useCallback(() => {
		if (!containerRef.current || !imageRef.current) return;

		const container = containerRef.current.getBoundingClientRect();
		const image = imageRef.current;

		const scaleX = container.width / image.naturalWidth;
		const scaleY = container.height / image.naturalHeight;
		const scale = Math.min(scaleX, scaleY, 1);

		setState(prev => ({
			...prev,
			scale,
			translateX: 0,
			translateY: 0
		}));
	}, []);

	// ç»‘å®šå…¨å±€äº‹ä»¶
	useEffect(() => {
		if (state.isDragging) {
			document.addEventListener('mousemove', handleMouseMove);
			document.addEventListener('mouseup', handleMouseUp);

			return () => {
				document.removeEventListener('mousemove', handleMouseMove);
				document.removeEventListener('mouseup', handleMouseUp);
			};
		}
	}, [state.isDragging, handleMouseMove, handleMouseUp]);

	// é”®ç›˜äº‹ä»¶
	useEffect(() => {
		const handleKeyDown = (e: KeyboardEvent) => {
			switch (e.key) {
				case 'ArrowLeft':
					setState(prev => ({ ...prev, translateX: prev.translateX - 20 }));
					break;
				case 'ArrowRight':
					setState(prev => ({ ...prev, translateX: prev.translateX + 20 }));
					break;
				case 'ArrowUp':
					setState(prev => ({ ...prev, translateY: prev.translateY - 20 }));
					break;
				case 'ArrowDown':
					setState(prev => ({ ...prev, translateY: prev.translateY + 20 }));
					break;
				case '+':
				case '=':
					handleZoom(scaleStep);
					break;
				case '-':
					handleZoom(-scaleStep);
					break;
				case '0':
					resetView();
					break;
				case 'r':
					handleRotate(90);
					break;
			}
		};

		document.addEventListener('keydown', handleKeyDown);
		return () => document.removeEventListener('keydown', handleKeyDown);
	}, [handleZoom, scaleStep, handleRotate, resetView]);

	const imageStyle: React.CSSProperties = {
		transform: `
      translate(${state.translateX}px, ${state.translateY}px) 
      scale(${state.scale}) 
      rotate(${state.rotation}deg)
    `,
		cursor: state.isDragging ? 'grabbing' : 'grab',
		transition: state.isDragging ? 'none' : 'transform 0.3s ease',
		userSelect: 'none',
		pointerEvents: 'auto'
	};

	return (
		<div className="image-viewer-container" ref={containerRef}>
			{/* å·¥å…·æ  */}
			<div className="image-viewer-toolbar">
				<button onClick={() => handleZoom(scaleStep)} title="æ”¾å¤§">
					ğŸ”+
				</button>
				<button onClick={() => handleZoom(-scaleStep)} title="ç¼©å°">
					ğŸ”-
				</button>
				<button onClick={() => handleRotate(90)} title="æ—‹è½¬">
					ğŸ”„
				</button>
				<button onClick={fitToView} title="é€‚åº”çª—å£">
					ğŸ“
				</button>
				<button onClick={resetView} title="é‡ç½®">
					ğŸ 
				</button>
				<span className="scale-info">{Math.round(state.scale * 100)}%</span>
			</div>

			{/* å›¾ç‰‡å®¹å™¨ */}
			<div
				className="image-container"
				onWheel={handleWheel}
				onDoubleClick={handleDoubleClick}
				onMouseDown={handleMouseDown}
			>
				<img
					ref={imageRef}
					src={src}
					alt={alt}
					style={imageStyle}
					draggable={false}
					onLoad={fitToContainer ? fitToView : undefined}
				/>
			</div>
		</div>
	);
};
```

### 2. ç§»åŠ¨ç«¯è§¦æ‘¸æ”¯æŒ

```typescript
interface TouchState {
	touches: Touch[];
	initialDistance: number;
	initialScale: number;
	initialRotation: number;
	lastTouchTime: number;
}

const useTouchGestures = (
	onZoom: (scale: number, centerX: number, centerY: number) => void,
	onRotate: (angle: number) => void,
	onPan: (deltaX: number, deltaY: number) => void
) => {
	const touchState = useRef<TouchState>({
		touches: [],
		initialDistance: 0,
		initialScale: 1,
		initialRotation: 0,
		lastTouchTime: 0
	});

	const getDistance = (touch1: Touch, touch2: Touch): number => {
		const dx = touch1.clientX - touch2.clientX;
		const dy = touch1.clientY - touch2.clientY;
		return Math.sqrt(dx * dx + dy * dy);
	};

	const getAngle = (touch1: Touch, touch2: Touch): number => {
		const dx = touch1.clientX - touch2.clientX;
		const dy = touch1.clientY - touch2.clientY;
		return (Math.atan2(dy, dx) * 180) / Math.PI;
	};

	const getCenter = (touch1: Touch, touch2: Touch) => ({
		x: (touch1.clientX + touch2.clientX) / 2,
		y: (touch1.clientY + touch2.clientY) / 2
	});

	const handleTouchStart = (e: React.TouchEvent) => {
		e.preventDefault();

		const touches = Array.from(e.touches);
		touchState.current.touches = touches;
		touchState.current.lastTouchTime = Date.now();

		if (touches.length === 2) {
			touchState.current.initialDistance = getDistance(touches[0], touches[1]);
			touchState.current.initialRotation = getAngle(touches[0], touches[1]);
		}
	};

	const handleTouchMove = (e: React.TouchEvent) => {
		e.preventDefault();

		const touches = Array.from(e.touches);

		if (touches.length === 1 && touchState.current.touches.length === 1) {
			// å•æŒ‡æ‹–æ‹½
			const deltaX = touches[0].clientX - touchState.current.touches[0].clientX;
			const deltaY = touches[0].clientY - touchState.current.touches[0].clientY;
			onPan(deltaX, deltaY);
		} else if (touches.length === 2 && touchState.current.touches.length === 2) {
			// åŒæŒ‡ç¼©æ”¾å’Œæ—‹è½¬
			const currentDistance = getDistance(touches[0], touches[1]);
			const currentAngle = getAngle(touches[0], touches[1]);
			const center = getCenter(touches[0], touches[1]);

			// ç¼©æ”¾
			const scaleRatio = currentDistance / touchState.current.initialDistance;
			onZoom(scaleRatio, center.x, center.y);

			// æ—‹è½¬
			const rotationDelta = currentAngle - touchState.current.initialRotation;
			onRotate(rotationDelta);
		}

		touchState.current.touches = touches;
	};

	const handleTouchEnd = (e: React.TouchEvent) => {
		const currentTime = Date.now();
		const timeDiff = currentTime - touchState.current.lastTouchTime;

		// æ£€æµ‹åŒå‡»
		if (e.touches.length === 0 && timeDiff < 300) {
			// å¯èƒ½æ˜¯åŒå‡»ï¼Œéœ€è¦è¿›ä¸€æ­¥æ£€æµ‹
			setTimeout(() => {
				if (Date.now() - currentTime < 300) {
					// ç¡®å®æ˜¯åŒå‡»
					const touch = touchState.current.touches[0];
					if (touch) {
						onZoom(2, touch.clientX, touch.clientY);
					}
				}
			}, 300);
		}

		touchState.current.touches = Array.from(e.touches);
	};

	return {
		onTouchStart: handleTouchStart,
		onTouchMove: handleTouchMove,
		onTouchEnd: handleTouchEnd
	};
};
```

### 3. è¾¹ç•Œé™åˆ¶åŠŸèƒ½

```typescript
const useBoundaryConstraint = (
	containerRef: React.RefObject<HTMLElement>,
	imageRef: React.RefObject<HTMLImageElement>,
	scale: number
) => {
	const constrainPosition = useCallback(
		(x: number, y: number) => {
			if (!containerRef.current || !imageRef.current) {
				return { x, y };
			}

			const container = containerRef.current.getBoundingClientRect();
			const image = imageRef.current;

			const scaledWidth = image.naturalWidth * scale;
			const scaledHeight = image.naturalHeight * scale;

			// è®¡ç®—è¾¹ç•Œ
			const maxX = Math.max(0, (scaledWidth - container.width) / 2);
			const maxY = Math.max(0, (scaledHeight - container.height) / 2);

			// çº¦æŸä½ç½®
			const constrainedX = Math.max(-maxX, Math.min(maxX, x));
			const constrainedY = Math.max(-maxY, Math.min(maxY, y));

			return { x: constrainedX, y: constrainedY };
		},
		[scale]
	);

	return constrainPosition;
};
```

### 4. æƒ¯æ€§æ»‘åŠ¨æ•ˆæœ

```typescript
class InertialScroll {
	private velocity = { x: 0, y: 0 };
	private lastPosition = { x: 0, y: 0 };
	private lastTime = 0;
	private friction = 0.95;
	private animationId: number = 0;

	updateVelocity(x: number, y: number) {
		const currentTime = Date.now();
		const deltaTime = currentTime - this.lastTime;

		if (deltaTime > 0) {
			this.velocity.x = ((x - this.lastPosition.x) / deltaTime) * 16;
			this.velocity.y = ((y - this.lastPosition.y) / deltaTime) * 16;
		}

		this.lastPosition = { x, y };
		this.lastTime = currentTime;
	}

	startInertia(
		currentPosition: { x: number; y: number },
		onUpdate: (position: { x: number; y: number }) => void,
		constrainFn?: (x: number, y: number) => { x: number; y: number }
	) {
		const animate = () => {
			// åº”ç”¨æ‘©æ“¦åŠ›
			this.velocity.x *= this.friction;
			this.velocity.y *= this.friction;

			// æ›´æ–°ä½ç½®
			let newX = currentPosition.x + this.velocity.x;
			let newY = currentPosition.y + this.velocity.y;

			// åº”ç”¨è¾¹ç•Œçº¦æŸ
			if (constrainFn) {
				const constrained = constrainFn(newX, newY);
				newX = constrained.x;
				newY = constrained.y;

				// å¦‚æœç¢°åˆ°è¾¹ç•Œï¼Œå‡å°‘å¯¹åº”æ–¹å‘çš„é€Ÿåº¦
				if (newX !== currentPosition.x + this.velocity.x) {
					this.velocity.x *= 0.3;
				}
				if (newY !== currentPosition.y + this.velocity.y) {
					this.velocity.y *= 0.3;
				}
			}

			currentPosition.x = newX;
			currentPosition.y = newY;

			onUpdate(currentPosition);

			// ç»§ç»­åŠ¨ç”»æˆ–åœæ­¢
			if (Math.abs(this.velocity.x) > 0.1 || Math.abs(this.velocity.y) > 0.1) {
				this.animationId = requestAnimationFrame(animate);
			}
		};

		animate();
	}

	stop() {
		if (this.animationId) {
			cancelAnimationFrame(this.animationId);
		}
	}
}
```

## ğŸ¨ é«˜çº§åŠŸèƒ½

### 1. ç¼©ç•¥å›¾å¯¼èˆª

```typescript
const ThumbnailNavigator: React.FC<{
	images: string[];
	currentIndex: number;
	onImageSelect: (index: number) => void;
}> = ({ images, currentIndex, onImageSelect }) => {
	const thumbnailsRef = useRef<HTMLDivElement>(null);

	// è‡ªåŠ¨æ»šåŠ¨åˆ°å½“å‰å›¾ç‰‡
	useEffect(() => {
		if (thumbnailsRef.current) {
			const currentThumbnail = thumbnailsRef.current.children[currentIndex] as HTMLElement;
			if (currentThumbnail) {
				currentThumbnail.scrollIntoView({
					behavior: 'smooth',
					block: 'nearest',
					inline: 'center'
				});
			}
		}
	}, [currentIndex]);

	return (
		<div className="thumbnail-navigator" ref={thumbnailsRef}>
			{images.map((src, index) => (
				<div
					key={index}
					className={`thumbnail ${index === currentIndex ? 'active' : ''}`}
					onClick={() => onImageSelect(index)}
				>
					<img src={src} alt={`ç¼©ç•¥å›¾ ${index + 1}`} />
				</div>
			))}
		</div>
	);
};
```

### 2. å…¨å±æ¨¡å¼

```typescript
const useFullscreen = () => {
	const [isFullscreen, setIsFullscreen] = useState(false);

	const enterFullscreen = (element: HTMLElement) => {
		if (element.requestFullscreen) {
			element.requestFullscreen();
		}
		setIsFullscreen(true);
	};

	const exitFullscreen = () => {
		if (document.exitFullscreen) {
			document.exitFullscreen();
		}
		setIsFullscreen(false);
	};

	useEffect(() => {
		const handleFullscreenChange = () => {
			setIsFullscreen(!!document.fullscreenElement);
		};

		document.addEventListener('fullscreenchange', handleFullscreenChange);
		return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
	}, []);

	return { isFullscreen, enterFullscreen, exitFullscreen };
};
```

### 3. å›¾ç‰‡é¢„åŠ è½½

```typescript
const useImagePreloader = (images: string[], currentIndex: number) => {
	const [loadedImages, setLoadedImages] = useState<Set<number>>(new Set());

	useEffect(() => {
		// é¢„åŠ è½½å½“å‰å›¾ç‰‡å’Œç›¸é‚»å›¾ç‰‡
		const indicesToLoad = [currentIndex - 1, currentIndex, currentIndex + 1].filter(
			index => index >= 0 && index < images.length
		);

		indicesToLoad.forEach(index => {
			if (!loadedImages.has(index)) {
				const img = new Image();
				img.onload = () => {
					setLoadedImages(prev => new Set(prev).add(index));
				};
				img.src = images[index];
			}
		});
	}, [currentIndex, images, loadedImages]);

	return loadedImages;
};
```

### 4. å›¾ç‰‡ä¿¡æ¯æ˜¾ç¤º

```typescript
interface ImageInfo {
	name: string;
	size: string;
	dimensions: string;
	format: string;
}

const ImageInfoPanel: React.FC<{
	imageRef: React.RefObject<HTMLImageElement>;
	src: string;
	visible: boolean;
}> = ({ imageRef, src, visible }) => {
	const [info, setInfo] = useState<ImageInfo | null>(null);

	useEffect(() => {
		if (imageRef.current && visible) {
			const img = imageRef.current;

			// è·å–å›¾ç‰‡ä¿¡æ¯
			fetch(src, { method: 'HEAD' })
				.then(response => {
					const contentLength = response.headers.get('content-length');
					const contentType = response.headers.get('content-type');

					setInfo({
						name: src.split('/').pop() || 'æœªçŸ¥',
						size: contentLength ? formatFileSize(parseInt(contentLength)) : 'æœªçŸ¥',
						dimensions: `${img.naturalWidth} Ã— ${img.naturalHeight}`,
						format: contentType?.split('/')[1]?.toUpperCase() || 'æœªçŸ¥'
					});
				})
				.catch(() => {
					setInfo({
						name: src.split('/').pop() || 'æœªçŸ¥',
						size: 'æœªçŸ¥',
						dimensions: `${img.naturalWidth} Ã— ${img.naturalHeight}`,
						format: 'æœªçŸ¥'
					});
				});
		}
	}, [src, visible, imageRef]);

	const formatFileSize = (bytes: number): string => {
		if (bytes === 0) return '0 Bytes';
		const k = 1024;
		const sizes = ['Bytes', 'KB', 'MB', 'GB'];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
	};

	if (!visible || !info) return null;

	return (
		<div className="image-info-panel">
			<div className="info-item">
				<span className="label">æ–‡ä»¶å:</span>
				<span className="value">{info.name}</span>
			</div>
			<div className="info-item">
				<span className="label">å°ºå¯¸:</span>
				<span className="value">{info.dimensions}</span>
			</div>
			<div className="info-item">
				<span className="label">å¤§å°:</span>
				<span className="value">{info.size}</span>
			</div>
			<div className="info-item">
				<span className="label">æ ¼å¼:</span>
				<span className="value">{info.format}</span>
			</div>
		</div>
	);
};
```

## âš¡ æ€§èƒ½ä¼˜åŒ–

### 1. è™šæ‹ŸåŒ–æ¸²æŸ“

```typescript
const VirtualizedImageGallery: React.FC<{
	images: string[];
	itemHeight: number;
	containerHeight: number;
}> = ({ images, itemHeight, containerHeight }) => {
	const [scrollTop, setScrollTop] = useState(0);

	const visibleStart = Math.floor(scrollTop / itemHeight);
	const visibleEnd = Math.min(
		visibleStart + Math.ceil(containerHeight / itemHeight) + 1,
		images.length
	);

	const visibleImages = images.slice(visibleStart, visibleEnd);

	return (
		<div
			className="virtual-gallery"
			style={{ height: containerHeight }}
			onScroll={e => setScrollTop(e.currentTarget.scrollTop)}
		>
			<div style={{ height: images.length * itemHeight, position: 'relative' }}>
				{visibleImages.map((src, index) => (
					<div
						key={visibleStart + index}
						style={{
							position: 'absolute',
							top: (visibleStart + index) * itemHeight,
							height: itemHeight
						}}
					>
						<img src={src} alt={`å›¾ç‰‡ ${visibleStart + index + 1}`} />
					</div>
				))}
			</div>
		</div>
	);
};
```

### 2. å›¾ç‰‡æ‡’åŠ è½½

```typescript
const LazyImage: React.FC<{
	src: string;
	alt: string;
	placeholder?: string;
}> = ({ src, alt, placeholder }) => {
	const [isLoaded, setIsLoaded] = useState(false);
	const [isInView, setIsInView] = useState(false);
	const imgRef = useRef<HTMLImageElement>(null);

	useEffect(() => {
		const observer = new IntersectionObserver(
			([entry]) => {
				if (entry.isIntersecting) {
					setIsInView(true);
					observer.disconnect();
				}
			},
			{ threshold: 0.1 }
		);

		if (imgRef.current) {
			observer.observe(imgRef.current);
		}

		return () => observer.disconnect();
	}, []);

	return (
		<div ref={imgRef} className="lazy-image-container">
			{isInView && (
				<img
					src={src}
					alt={alt}
					onLoad={() => setIsLoaded(true)}
					style={{
						opacity: isLoaded ? 1 : 0,
						transition: 'opacity 0.3s ease'
					}}
				/>
			)}
			{!isLoaded && placeholder && (
				<img src={placeholder} alt="åŠ è½½ä¸­..." className="placeholder" />
			)}
		</div>
	);
};
```

## åº”ç”¨åœºæ™¯

### 1. äº§å“å±•ç¤º

```typescript
const ProductGallery = ({ product }) => (
	<div className="product-gallery">
		<ImageViewer src={product.mainImage} maxScale={3} enableRotation={false} />
		<ThumbnailNavigator
			images={product.images}
			currentIndex={0}
			onImageSelect={index => {
				// åˆ‡æ¢ä¸»å›¾
			}}
		/>
	</div>
);
```

### 2. ç…§ç‰‡ç›¸å†Œ

```typescript
const PhotoAlbum = ({ photos }) => {
	const [currentPhoto, setCurrentPhoto] = useState(0);

	return (
		<div className="photo-album">
			<ImageViewer
				src={photos[currentPhoto].src}
				alt={photos[currentPhoto].title}
				fitToContainer={true}
			/>
			<div className="photo-navigation">
				<button onClick={() => setCurrentPhoto(prev => Math.max(0, prev - 1))}>ä¸Šä¸€å¼ </button>
				<span>
					{currentPhoto + 1} / {photos.length}
				</span>
				<button onClick={() => setCurrentPhoto(prev => Math.min(photos.length - 1, prev + 1))}>
					ä¸‹ä¸€å¼ 
				</button>
			</div>
		</div>
	);
};
```

### 3. å›¾ç‰‡ç¼–è¾‘å™¨

```typescript
const ImageEditor = ({ imageSrc }) => {
	const [editState, setEditState] = useState({
		brightness: 100,
		contrast: 100,
		saturation: 100
	});

	return (
		<div className="image-editor">
			<ImageViewer
				src={imageSrc}
				style={{
					filter: `
            brightness(${editState.brightness}%)
            contrast(${editState.contrast}%)
            saturate(${editState.saturation}%)
          `
				}}
			/>
			<div className="edit-controls">{/* ç¼–è¾‘æ§ä»¶ */}</div>
		</div>
	);
};
```

## æœ€ä½³å®è·µ

### è®¾è®¡åŸåˆ™

1. **ç›´è§‚æ“ä½œ**: æä¾›ç¬¦åˆç”¨æˆ·ä¹ æƒ¯çš„äº¤äº’æ–¹å¼
2. **æ€§èƒ½ä¼˜å…ˆ**: ç¡®ä¿æµç•…çš„ç¼©æ”¾å’Œæ‹–æ‹½ä½“éªŒ
3. **å“åº”å¼è®¾è®¡**: é€‚é…ä¸åŒè®¾å¤‡å’Œå±å¹•å°ºå¯¸
4. **å¯è®¿é—®æ€§**: æ”¯æŒé”®ç›˜æ“ä½œå’Œå±å¹•é˜…è¯»å™¨

### å®æ–½å»ºè®®

1. **æ¸è¿›å¢å¼º**: ä»åŸºç¡€åŠŸèƒ½å¼€å§‹ï¼Œé€æ­¥æ·»åŠ é«˜çº§ç‰¹æ€§
2. **é”™è¯¯å¤„ç†**: ä¼˜é›…å¤„ç†å›¾ç‰‡åŠ è½½å¤±è´¥çš„æƒ…å†µ
3. **ç”¨æˆ·åé¦ˆ**: æä¾›æ¸…æ™°çš„æ“ä½œåé¦ˆå’ŒçŠ¶æ€æç¤º
4. **æ€§èƒ½ç›‘æ§**: ç›‘æ§å¤§å›¾ç‰‡å¯¹å†…å­˜å’Œæ€§èƒ½çš„å½±å“

---

_å›¾ç‰‡æŸ¥çœ‹å™¨æ˜¯ç”¨æˆ·ä½“éªŒçš„é‡è¦ç»„æˆéƒ¨åˆ†ï¼Œè‰¯å¥½çš„å®ç°èƒ½å¤Ÿæ˜¾è‘—æå‡åº”ç”¨çš„ä¸“ä¸šåº¦å’Œæ˜“ç”¨æ€§ã€‚_ ğŸ–¼ï¸
