---
title: 图片放大缩小及拖拽
date: 2025-07-20 21:56:30
permalink: /notes/image-view-size
categories:
  - 图片
  - 拖拽
  - 放大缩小
tags:
  - 图片
  - 拖拽
  - 放大缩小
  - 图片查看器
---

# 图片放大缩小及拖拽实现

图片查看器是现代 Web 应用中的重要组件，提供了丰富的图片交互功能。本文将详细介绍如何实现一个功能完善的图片查看器，包括缩放、拖拽、旋转等核心功能。

## 功能特性

### 核心交互功能

- **缩放控制**: 鼠标滚轮、双击、按钮缩放
- **拖拽移动**: 鼠标拖拽、触摸滑动
- **旋转功能**: 90 度旋转、任意角度旋转
- **适应窗口**: 自动适应容器大小
- **重置视图**: 一键恢复初始状态

### 高级特性

- **边界限制**: 防止图片拖拽出可视区域
- **惯性滑动**: 拖拽释放后的惯性效果
- **手势支持**: 双指缩放、旋转手势
- **键盘操作**: 方向键移动、快捷键缩放
- **全屏模式**: 全屏查看图片

## 💻 实现演示

<demo react="react/Animate/ImageViewer/index.tsx"
:reactFiles="['react/Animate/ImageViewer/index.tsx','react/Animate/ImageViewer/index.scss']"
/>

## 🛠️ 核心实现原理

### 1. 基础图片查看器

```typescript
interface ImageViewerState {
	scale: number;
	translateX: number;
	translateY: number;
	rotation: number;
	isDragging: boolean;
	dragStart: { x: number; y: number };
}

interface ImageViewerProps {
	src: string;
	alt?: string;
	maxScale?: number;
	minScale?: number;
	scaleStep?: number;
	enableRotation?: boolean;
	enableDrag?: boolean;
	fitToContainer?: boolean;
}

const ImageViewer: React.FC<ImageViewerProps> = ({
	src,
	alt = '',
	maxScale = 5,
	minScale = 0.1,
	scaleStep = 0.2,
	enableRotation = true,
	enableDrag = true,
	fitToContainer = true
}) => {
	const containerRef = useRef<HTMLDivElement>(null);
	const imageRef = useRef<HTMLImageElement>(null);

	const [state, setState] = useState<ImageViewerState>({
		scale: 1,
		translateX: 0,
		translateY: 0,
		rotation: 0,
		isDragging: false,
		dragStart: { x: 0, y: 0 }
	});

	// 缩放功能
	const handleZoom = useCallback(
		(delta: number, centerX?: number, centerY?: number) => {
			setState(prev => {
				const newScale = Math.max(minScale, Math.min(maxScale, prev.scale + delta));

				if (centerX !== undefined && centerY !== undefined && containerRef.current) {
					// 以指定点为中心缩放
					const rect = containerRef.current.getBoundingClientRect();
					const offsetX = centerX - rect.left - rect.width / 2;
					const offsetY = centerY - rect.top - rect.height / 2;

					const scaleRatio = newScale / prev.scale;
					const newTranslateX = prev.translateX - offsetX * (scaleRatio - 1);
					const newTranslateY = prev.translateY - offsetY * (scaleRatio - 1);

					return {
						...prev,
						scale: newScale,
						translateX: newTranslateX,
						translateY: newTranslateY
					};
				}

				return { ...prev, scale: newScale };
			});
		},
		[minScale, maxScale]
	);

	// 鼠标滚轮缩放
	const handleWheel = useCallback(
		(e: React.WheelEvent) => {
			e.preventDefault();
			const delta = e.deltaY > 0 ? -scaleStep : scaleStep;
			handleZoom(delta, e.clientX, e.clientY);
		},
		[handleZoom, scaleStep]
	);

	// 双击缩放
	const handleDoubleClick = useCallback(
		(e: React.MouseEvent) => {
			const isZoomedIn = state.scale > 1;
			if (isZoomedIn) {
				// 重置到原始大小
				setState(prev => ({
					...prev,
					scale: 1,
					translateX: 0,
					translateY: 0
				}));
			} else {
				// 放大到2倍
				handleZoom(1, e.clientX, e.clientY);
			}
		},
		[state.scale, handleZoom]
	);

	// 拖拽开始
	const handleMouseDown = useCallback(
		(e: React.MouseEvent) => {
			if (!enableDrag) return;

			e.preventDefault();
			setState(prev => ({
				...prev,
				isDragging: true,
				dragStart: { x: e.clientX, y: e.clientY }
			}));
		},
		[enableDrag]
	);

	// 拖拽移动
	const handleMouseMove = useCallback(
		(e: MouseEvent) => {
			if (!state.isDragging) return;

			const deltaX = e.clientX - state.dragStart.x;
			const deltaY = e.clientY - state.dragStart.y;

			setState(prev => ({
				...prev,
				translateX: prev.translateX + deltaX,
				translateY: prev.translateY + deltaY,
				dragStart: { x: e.clientX, y: e.clientY }
			}));
		},
		[state.isDragging, state.dragStart]
	);

	// 拖拽结束
	const handleMouseUp = useCallback(() => {
		setState(prev => ({ ...prev, isDragging: false }));
	}, []);

	// 旋转功能
	const handleRotate = useCallback(
		(angle: number) => {
			if (!enableRotation) return;

			setState(prev => ({
				...prev,
				rotation: (prev.rotation + angle) % 360
			}));
		},
		[enableRotation]
	);

	// 重置视图
	const resetView = useCallback(() => {
		setState({
			scale: 1,
			translateX: 0,
			translateY: 0,
			rotation: 0,
			isDragging: false,
			dragStart: { x: 0, y: 0 }
		});
	}, []);

	// 适应容器
	const fitToView = useCallback(() => {
		if (!containerRef.current || !imageRef.current) return;

		const container = containerRef.current.getBoundingClientRect();
		const image = imageRef.current;

		const scaleX = container.width / image.naturalWidth;
		const scaleY = container.height / image.naturalHeight;
		const scale = Math.min(scaleX, scaleY, 1);

		setState(prev => ({
			...prev,
			scale,
			translateX: 0,
			translateY: 0
		}));
	}, []);

	// 绑定全局事件
	useEffect(() => {
		if (state.isDragging) {
			document.addEventListener('mousemove', handleMouseMove);
			document.addEventListener('mouseup', handleMouseUp);

			return () => {
				document.removeEventListener('mousemove', handleMouseMove);
				document.removeEventListener('mouseup', handleMouseUp);
			};
		}
	}, [state.isDragging, handleMouseMove, handleMouseUp]);

	// 键盘事件
	useEffect(() => {
		const handleKeyDown = (e: KeyboardEvent) => {
			switch (e.key) {
				case 'ArrowLeft':
					setState(prev => ({ ...prev, translateX: prev.translateX - 20 }));
					break;
				case 'ArrowRight':
					setState(prev => ({ ...prev, translateX: prev.translateX + 20 }));
					break;
				case 'ArrowUp':
					setState(prev => ({ ...prev, translateY: prev.translateY - 20 }));
					break;
				case 'ArrowDown':
					setState(prev => ({ ...prev, translateY: prev.translateY + 20 }));
					break;
				case '+':
				case '=':
					handleZoom(scaleStep);
					break;
				case '-':
					handleZoom(-scaleStep);
					break;
				case '0':
					resetView();
					break;
				case 'r':
					handleRotate(90);
					break;
			}
		};

		document.addEventListener('keydown', handleKeyDown);
		return () => document.removeEventListener('keydown', handleKeyDown);
	}, [handleZoom, scaleStep, handleRotate, resetView]);

	const imageStyle: React.CSSProperties = {
		transform: `
      translate(${state.translateX}px, ${state.translateY}px) 
      scale(${state.scale}) 
      rotate(${state.rotation}deg)
    `,
		cursor: state.isDragging ? 'grabbing' : 'grab',
		transition: state.isDragging ? 'none' : 'transform 0.3s ease',
		userSelect: 'none',
		pointerEvents: 'auto'
	};

	return (
		<div className="image-viewer-container" ref={containerRef}>
			{/* 工具栏 */}
			<div className="image-viewer-toolbar">
				<button onClick={() => handleZoom(scaleStep)} title="放大">
					🔍+
				</button>
				<button onClick={() => handleZoom(-scaleStep)} title="缩小">
					🔍-
				</button>
				<button onClick={() => handleRotate(90)} title="旋转">
					🔄
				</button>
				<button onClick={fitToView} title="适应窗口">
					📐
				</button>
				<button onClick={resetView} title="重置">
					🏠
				</button>
				<span className="scale-info">{Math.round(state.scale * 100)}%</span>
			</div>

			{/* 图片容器 */}
			<div
				className="image-container"
				onWheel={handleWheel}
				onDoubleClick={handleDoubleClick}
				onMouseDown={handleMouseDown}
			>
				<img
					ref={imageRef}
					src={src}
					alt={alt}
					style={imageStyle}
					draggable={false}
					onLoad={fitToContainer ? fitToView : undefined}
				/>
			</div>
		</div>
	);
};
```

### 2. 移动端触摸支持

```typescript
interface TouchState {
	touches: Touch[];
	initialDistance: number;
	initialScale: number;
	initialRotation: number;
	lastTouchTime: number;
}

const useTouchGestures = (
	onZoom: (scale: number, centerX: number, centerY: number) => void,
	onRotate: (angle: number) => void,
	onPan: (deltaX: number, deltaY: number) => void
) => {
	const touchState = useRef<TouchState>({
		touches: [],
		initialDistance: 0,
		initialScale: 1,
		initialRotation: 0,
		lastTouchTime: 0
	});

	const getDistance = (touch1: Touch, touch2: Touch): number => {
		const dx = touch1.clientX - touch2.clientX;
		const dy = touch1.clientY - touch2.clientY;
		return Math.sqrt(dx * dx + dy * dy);
	};

	const getAngle = (touch1: Touch, touch2: Touch): number => {
		const dx = touch1.clientX - touch2.clientX;
		const dy = touch1.clientY - touch2.clientY;
		return (Math.atan2(dy, dx) * 180) / Math.PI;
	};

	const getCenter = (touch1: Touch, touch2: Touch) => ({
		x: (touch1.clientX + touch2.clientX) / 2,
		y: (touch1.clientY + touch2.clientY) / 2
	});

	const handleTouchStart = (e: React.TouchEvent) => {
		e.preventDefault();

		const touches = Array.from(e.touches);
		touchState.current.touches = touches;
		touchState.current.lastTouchTime = Date.now();

		if (touches.length === 2) {
			touchState.current.initialDistance = getDistance(touches[0], touches[1]);
			touchState.current.initialRotation = getAngle(touches[0], touches[1]);
		}
	};

	const handleTouchMove = (e: React.TouchEvent) => {
		e.preventDefault();

		const touches = Array.from(e.touches);

		if (touches.length === 1 && touchState.current.touches.length === 1) {
			// 单指拖拽
			const deltaX = touches[0].clientX - touchState.current.touches[0].clientX;
			const deltaY = touches[0].clientY - touchState.current.touches[0].clientY;
			onPan(deltaX, deltaY);
		} else if (touches.length === 2 && touchState.current.touches.length === 2) {
			// 双指缩放和旋转
			const currentDistance = getDistance(touches[0], touches[1]);
			const currentAngle = getAngle(touches[0], touches[1]);
			const center = getCenter(touches[0], touches[1]);

			// 缩放
			const scaleRatio = currentDistance / touchState.current.initialDistance;
			onZoom(scaleRatio, center.x, center.y);

			// 旋转
			const rotationDelta = currentAngle - touchState.current.initialRotation;
			onRotate(rotationDelta);
		}

		touchState.current.touches = touches;
	};

	const handleTouchEnd = (e: React.TouchEvent) => {
		const currentTime = Date.now();
		const timeDiff = currentTime - touchState.current.lastTouchTime;

		// 检测双击
		if (e.touches.length === 0 && timeDiff < 300) {
			// 可能是双击，需要进一步检测
			setTimeout(() => {
				if (Date.now() - currentTime < 300) {
					// 确实是双击
					const touch = touchState.current.touches[0];
					if (touch) {
						onZoom(2, touch.clientX, touch.clientY);
					}
				}
			}, 300);
		}

		touchState.current.touches = Array.from(e.touches);
	};

	return {
		onTouchStart: handleTouchStart,
		onTouchMove: handleTouchMove,
		onTouchEnd: handleTouchEnd
	};
};
```

### 3. 边界限制功能

```typescript
const useBoundaryConstraint = (
	containerRef: React.RefObject<HTMLElement>,
	imageRef: React.RefObject<HTMLImageElement>,
	scale: number
) => {
	const constrainPosition = useCallback(
		(x: number, y: number) => {
			if (!containerRef.current || !imageRef.current) {
				return { x, y };
			}

			const container = containerRef.current.getBoundingClientRect();
			const image = imageRef.current;

			const scaledWidth = image.naturalWidth * scale;
			const scaledHeight = image.naturalHeight * scale;

			// 计算边界
			const maxX = Math.max(0, (scaledWidth - container.width) / 2);
			const maxY = Math.max(0, (scaledHeight - container.height) / 2);

			// 约束位置
			const constrainedX = Math.max(-maxX, Math.min(maxX, x));
			const constrainedY = Math.max(-maxY, Math.min(maxY, y));

			return { x: constrainedX, y: constrainedY };
		},
		[scale]
	);

	return constrainPosition;
};
```

### 4. 惯性滑动效果

```typescript
class InertialScroll {
	private velocity = { x: 0, y: 0 };
	private lastPosition = { x: 0, y: 0 };
	private lastTime = 0;
	private friction = 0.95;
	private animationId: number = 0;

	updateVelocity(x: number, y: number) {
		const currentTime = Date.now();
		const deltaTime = currentTime - this.lastTime;

		if (deltaTime > 0) {
			this.velocity.x = ((x - this.lastPosition.x) / deltaTime) * 16;
			this.velocity.y = ((y - this.lastPosition.y) / deltaTime) * 16;
		}

		this.lastPosition = { x, y };
		this.lastTime = currentTime;
	}

	startInertia(
		currentPosition: { x: number; y: number },
		onUpdate: (position: { x: number; y: number }) => void,
		constrainFn?: (x: number, y: number) => { x: number; y: number }
	) {
		const animate = () => {
			// 应用摩擦力
			this.velocity.x *= this.friction;
			this.velocity.y *= this.friction;

			// 更新位置
			let newX = currentPosition.x + this.velocity.x;
			let newY = currentPosition.y + this.velocity.y;

			// 应用边界约束
			if (constrainFn) {
				const constrained = constrainFn(newX, newY);
				newX = constrained.x;
				newY = constrained.y;

				// 如果碰到边界，减少对应方向的速度
				if (newX !== currentPosition.x + this.velocity.x) {
					this.velocity.x *= 0.3;
				}
				if (newY !== currentPosition.y + this.velocity.y) {
					this.velocity.y *= 0.3;
				}
			}

			currentPosition.x = newX;
			currentPosition.y = newY;

			onUpdate(currentPosition);

			// 继续动画或停止
			if (Math.abs(this.velocity.x) > 0.1 || Math.abs(this.velocity.y) > 0.1) {
				this.animationId = requestAnimationFrame(animate);
			}
		};

		animate();
	}

	stop() {
		if (this.animationId) {
			cancelAnimationFrame(this.animationId);
		}
	}
}
```

## 🎨 高级功能

### 1. 缩略图导航

```typescript
const ThumbnailNavigator: React.FC<{
	images: string[];
	currentIndex: number;
	onImageSelect: (index: number) => void;
}> = ({ images, currentIndex, onImageSelect }) => {
	const thumbnailsRef = useRef<HTMLDivElement>(null);

	// 自动滚动到当前图片
	useEffect(() => {
		if (thumbnailsRef.current) {
			const currentThumbnail = thumbnailsRef.current.children[currentIndex] as HTMLElement;
			if (currentThumbnail) {
				currentThumbnail.scrollIntoView({
					behavior: 'smooth',
					block: 'nearest',
					inline: 'center'
				});
			}
		}
	}, [currentIndex]);

	return (
		<div className="thumbnail-navigator" ref={thumbnailsRef}>
			{images.map((src, index) => (
				<div
					key={index}
					className={`thumbnail ${index === currentIndex ? 'active' : ''}`}
					onClick={() => onImageSelect(index)}
				>
					<img src={src} alt={`缩略图 ${index + 1}`} />
				</div>
			))}
		</div>
	);
};
```

### 2. 全屏模式

```typescript
const useFullscreen = () => {
	const [isFullscreen, setIsFullscreen] = useState(false);

	const enterFullscreen = (element: HTMLElement) => {
		if (element.requestFullscreen) {
			element.requestFullscreen();
		}
		setIsFullscreen(true);
	};

	const exitFullscreen = () => {
		if (document.exitFullscreen) {
			document.exitFullscreen();
		}
		setIsFullscreen(false);
	};

	useEffect(() => {
		const handleFullscreenChange = () => {
			setIsFullscreen(!!document.fullscreenElement);
		};

		document.addEventListener('fullscreenchange', handleFullscreenChange);
		return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
	}, []);

	return { isFullscreen, enterFullscreen, exitFullscreen };
};
```

### 3. 图片预加载

```typescript
const useImagePreloader = (images: string[], currentIndex: number) => {
	const [loadedImages, setLoadedImages] = useState<Set<number>>(new Set());

	useEffect(() => {
		// 预加载当前图片和相邻图片
		const indicesToLoad = [currentIndex - 1, currentIndex, currentIndex + 1].filter(
			index => index >= 0 && index < images.length
		);

		indicesToLoad.forEach(index => {
			if (!loadedImages.has(index)) {
				const img = new Image();
				img.onload = () => {
					setLoadedImages(prev => new Set(prev).add(index));
				};
				img.src = images[index];
			}
		});
	}, [currentIndex, images, loadedImages]);

	return loadedImages;
};
```

### 4. 图片信息显示

```typescript
interface ImageInfo {
	name: string;
	size: string;
	dimensions: string;
	format: string;
}

const ImageInfoPanel: React.FC<{
	imageRef: React.RefObject<HTMLImageElement>;
	src: string;
	visible: boolean;
}> = ({ imageRef, src, visible }) => {
	const [info, setInfo] = useState<ImageInfo | null>(null);

	useEffect(() => {
		if (imageRef.current && visible) {
			const img = imageRef.current;

			// 获取图片信息
			fetch(src, { method: 'HEAD' })
				.then(response => {
					const contentLength = response.headers.get('content-length');
					const contentType = response.headers.get('content-type');

					setInfo({
						name: src.split('/').pop() || '未知',
						size: contentLength ? formatFileSize(parseInt(contentLength)) : '未知',
						dimensions: `${img.naturalWidth} × ${img.naturalHeight}`,
						format: contentType?.split('/')[1]?.toUpperCase() || '未知'
					});
				})
				.catch(() => {
					setInfo({
						name: src.split('/').pop() || '未知',
						size: '未知',
						dimensions: `${img.naturalWidth} × ${img.naturalHeight}`,
						format: '未知'
					});
				});
		}
	}, [src, visible, imageRef]);

	const formatFileSize = (bytes: number): string => {
		if (bytes === 0) return '0 Bytes';
		const k = 1024;
		const sizes = ['Bytes', 'KB', 'MB', 'GB'];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
	};

	if (!visible || !info) return null;

	return (
		<div className="image-info-panel">
			<div className="info-item">
				<span className="label">文件名:</span>
				<span className="value">{info.name}</span>
			</div>
			<div className="info-item">
				<span className="label">尺寸:</span>
				<span className="value">{info.dimensions}</span>
			</div>
			<div className="info-item">
				<span className="label">大小:</span>
				<span className="value">{info.size}</span>
			</div>
			<div className="info-item">
				<span className="label">格式:</span>
				<span className="value">{info.format}</span>
			</div>
		</div>
	);
};
```

## ⚡ 性能优化

### 1. 虚拟化渲染

```typescript
const VirtualizedImageGallery: React.FC<{
	images: string[];
	itemHeight: number;
	containerHeight: number;
}> = ({ images, itemHeight, containerHeight }) => {
	const [scrollTop, setScrollTop] = useState(0);

	const visibleStart = Math.floor(scrollTop / itemHeight);
	const visibleEnd = Math.min(
		visibleStart + Math.ceil(containerHeight / itemHeight) + 1,
		images.length
	);

	const visibleImages = images.slice(visibleStart, visibleEnd);

	return (
		<div
			className="virtual-gallery"
			style={{ height: containerHeight }}
			onScroll={e => setScrollTop(e.currentTarget.scrollTop)}
		>
			<div style={{ height: images.length * itemHeight, position: 'relative' }}>
				{visibleImages.map((src, index) => (
					<div
						key={visibleStart + index}
						style={{
							position: 'absolute',
							top: (visibleStart + index) * itemHeight,
							height: itemHeight
						}}
					>
						<img src={src} alt={`图片 ${visibleStart + index + 1}`} />
					</div>
				))}
			</div>
		</div>
	);
};
```

### 2. 图片懒加载

```typescript
const LazyImage: React.FC<{
	src: string;
	alt: string;
	placeholder?: string;
}> = ({ src, alt, placeholder }) => {
	const [isLoaded, setIsLoaded] = useState(false);
	const [isInView, setIsInView] = useState(false);
	const imgRef = useRef<HTMLImageElement>(null);

	useEffect(() => {
		const observer = new IntersectionObserver(
			([entry]) => {
				if (entry.isIntersecting) {
					setIsInView(true);
					observer.disconnect();
				}
			},
			{ threshold: 0.1 }
		);

		if (imgRef.current) {
			observer.observe(imgRef.current);
		}

		return () => observer.disconnect();
	}, []);

	return (
		<div ref={imgRef} className="lazy-image-container">
			{isInView && (
				<img
					src={src}
					alt={alt}
					onLoad={() => setIsLoaded(true)}
					style={{
						opacity: isLoaded ? 1 : 0,
						transition: 'opacity 0.3s ease'
					}}
				/>
			)}
			{!isLoaded && placeholder && (
				<img src={placeholder} alt="加载中..." className="placeholder" />
			)}
		</div>
	);
};
```

## 应用场景

### 1. 产品展示

```typescript
const ProductGallery = ({ product }) => (
	<div className="product-gallery">
		<ImageViewer src={product.mainImage} maxScale={3} enableRotation={false} />
		<ThumbnailNavigator
			images={product.images}
			currentIndex={0}
			onImageSelect={index => {
				// 切换主图
			}}
		/>
	</div>
);
```

### 2. 照片相册

```typescript
const PhotoAlbum = ({ photos }) => {
	const [currentPhoto, setCurrentPhoto] = useState(0);

	return (
		<div className="photo-album">
			<ImageViewer
				src={photos[currentPhoto].src}
				alt={photos[currentPhoto].title}
				fitToContainer={true}
			/>
			<div className="photo-navigation">
				<button onClick={() => setCurrentPhoto(prev => Math.max(0, prev - 1))}>上一张</button>
				<span>
					{currentPhoto + 1} / {photos.length}
				</span>
				<button onClick={() => setCurrentPhoto(prev => Math.min(photos.length - 1, prev + 1))}>
					下一张
				</button>
			</div>
		</div>
	);
};
```

### 3. 图片编辑器

```typescript
const ImageEditor = ({ imageSrc }) => {
	const [editState, setEditState] = useState({
		brightness: 100,
		contrast: 100,
		saturation: 100
	});

	return (
		<div className="image-editor">
			<ImageViewer
				src={imageSrc}
				style={{
					filter: `
            brightness(${editState.brightness}%)
            contrast(${editState.contrast}%)
            saturate(${editState.saturation}%)
          `
				}}
			/>
			<div className="edit-controls">{/* 编辑控件 */}</div>
		</div>
	);
};
```

## 最佳实践

### 设计原则

1. **直观操作**: 提供符合用户习惯的交互方式
2. **性能优先**: 确保流畅的缩放和拖拽体验
3. **响应式设计**: 适配不同设备和屏幕尺寸
4. **可访问性**: 支持键盘操作和屏幕阅读器

### 实施建议

1. **渐进增强**: 从基础功能开始，逐步添加高级特性
2. **错误处理**: 优雅处理图片加载失败的情况
3. **用户反馈**: 提供清晰的操作反馈和状态提示
4. **性能监控**: 监控大图片对内存和性能的影响

---

_图片查看器是用户体验的重要组成部分，良好的实现能够显著提升应用的专业度和易用性。_ 🖼️
