# 不固定高度 div 过渡效果实现

这篇文章主要讲解如何给不固定高度的 div 添加过渡动画效果。

## 技术背景

熟悉前端开发的同学都知道，想要给一个 div 增加过渡效果（transition），就必须给这个 div 设置一个高度值，如果高度值没有设置，那么 transition 属性就会失效。

## 设计思路

### 1. 使用 ResizeObserver API

ResizeObserver 是一个现代的浏览器 API，用于监听元素尺寸的变化。相比于在 window.resize 上绑定事件然后循环检查所有元素的古老方法，ResizeObserver 只在特定元素尺寸变化时才会触发回调，大大提升了性能。

### 2. 实现原理

1. 使用插槽（slot）来放置内容
2. 在插槽外部包装一个 div 并添加 ref 属性
3. 使用 ResizeObserver 监听这个 div 的高度变化
4. 在外部再包装一层 div，用于应用过渡效果

## 核心实现

### Vue 版本核心代码

```vue
<template>
	<div class="size-transition" :style="{ height }">
		<div :id="id" ref="contentRef">
			<slot></slot>
		</div>
	</div>
</template>

<script setup lang="ts">
// @ts-nocheck
import { ref, onMounted, onBeforeUnmount, watch } from 'vue';

// 生成 UUID 的函数
const generateUUID = () => {
	return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
		const r = (Math.random() * 16) | 0;
		const v = c === 'x' ? r : (r & 0x3) | 0x8;
		return v.toString(16);
	});
};

const props = defineProps({
	minHeight: {
		type: Number,
		default: 0
	},
	initState: {
		type: Boolean,
		default: true
	}
});

const id = ref<string>(generateUUID());
const contentRef = ref<HTMLElement | null>(null);
const state = ref<boolean>(props.initState);
const height = ref<undefined | string>(undefined);
let observer: ResizeObserver | null = null;

// 初始化尺寸观察
const initResizeObserver = (): void => {
	if (!contentRef.value) return;

	observer = new ResizeObserver(entries => {
		for (const entry of entries) {
			const newHeight = entry.contentRect.height;
			// 当处于展开状态时同步高度
			if (state.value) {
				height.value = `${newHeight + 3}px`;
			}
		}
	});

	observer.observe(contentRef.value);
};

// 折叠方法
const contract = (): void => {
	if (!contentRef.value) return;
	height.value = `${contentRef.value.offsetHeight}px`;
	requestAnimationFrame(() => {
		height.value = `${props.minHeight}px`;
		state.value = false;
	});
};

// 展开方法
const expand = (): void => {
	if (!contentRef.value) return;
	height.value = '0px';
	requestAnimationFrame(() => {
		height.value = `${contentRef.value!.offsetHeight + 3}px`;
		state.value = true;
	});
};

// 切换方法
const toggle = (): void => {
	state.value ? contract() : expand();
};

// 监听 initState 变化
watch(
	() => props.initState,
	newValue => {
		if (newValue) {
			expand();
		} else {
			contract();
		}
	}
);

// 生命周期
onMounted(() => {
	props.initState ? expand() : contract();
	initResizeObserver();
});

onBeforeUnmount(() => {
	observer?.disconnect();
});

// 暴露方法给父组件
defineExpose({
	contract,
	expand,
	toggle
});
</script>

<style scoped lang="scss">
.size-transition {
	width: 100%;
	overflow: hidden;
	transition: height 0.3s ease-in-out;
	will-change: height; // 启用硬件加速
}
</style>
```

### React 版本核心代码

```jsx
import React, {
	useState,
	useEffect,
	useRef,
	ReactNode,
	useImperativeHandle,
	forwardRef
} from 'react';
import './size-transition.scss';

interface SizeTransitionProps {
	children: ReactNode;
	minHeight?: number;
	initState?: boolean;
}

export interface SizeTransitionHandles {
	expand: () => void;
	contract: () => void;
	toggle: () => void;
}

const SizeTransition = forwardRef<SizeTransitionHandles, SizeTransitionProps>(
	({ children, minHeight = 0, initState = true }, ref) => {
		const id = `size-transition-${Math.random().toString(36).substr(2, 9)}`;
		const contentRef = useRef<HTMLDivElement>(null);
		const [state, setState] = useState<boolean>(initState);
		const [height, setHeight] = useState<string | undefined>(undefined);
		const observerRef = useRef<ResizeObserver | null>(null);

		// 初始化尺寸观察
		const initResizeObserver = (): void => {
			if (!contentRef.current) return;

			observerRef.current = new ResizeObserver(entries => {
				for (const entry of entries) {
					const newHeight = entry.contentRect.height;
					// 当处于展开状态时同步高度
					if (state) {
						setHeight(`${newHeight + 3}px`);
					}
				}
			});

			observerRef.current.observe(contentRef.current);
		};

		// 折叠方法
		const contract = (): void => {
			if (!contentRef.current) return;
			setHeight(`${contentRef.current.offsetHeight}px`);
			requestAnimationFrame(() => {
				setHeight(`${minHeight}px`);
				setState(false);
			});
		};

		// 展开方法
		const expand = (): void => {
			if (!contentRef.current) return;
			setHeight('0px');
			requestAnimationFrame(() => {
				setHeight(`${contentRef.current!.offsetHeight + 3}px`);
				setState(true);
			});
		};

		// 切换方法
		const toggle = (): void => {
			state ? contract() : expand();
		};

		// 通过 ref 暴露方法
		useImperativeHandle(ref, () => ({
			expand,
			contract,
			toggle
		}));

		// 生命周期
		useEffect(() => {
			initState ? expand() : contract();
			initResizeObserver();

			return () => {
				observerRef.current?.disconnect();
			};
		}, []);

		return (
			<div className="size-transition" style={{ height }}>
				<div id={id} ref={contentRef}>
					{children}
				</div>
			</div>
		);
	}
);

export default SizeTransition;
```

## 实际应用

### Vue 版本使用示例

```vue
<template>
	<SizeTransition>
		<div>可变高度的内容</div>
	</SizeTransition>
</template>

<script setup>
import SizeTransition from './SizeTransition/index.vue';
</script>
```

### React 版本使用示例

```jsx
import React from 'react';
import SizeTransition from './SizeTransition';

const MyComponent = () => {
	return (
		<SizeTransition>
			<div>可变高度的内容</div>
		</SizeTransition>
	);
};
```

## 效果展示

通过这种方式，我们可以实现平滑的高度过渡动画，提升用户体验。

## 注意事项

1. 该组件依赖 ResizeObserver API，对于较老的浏览器可能需要添加 polyfill
2. 组件会自动监听内容区域的高度变化并更新过渡效果
3. 可以通过 ref 调用组件的 expand、contract、toggle 方法来控制展开/收起状态

### 浏览器兼容性

ResizeObserver API 在以下浏览器版本中得到支持：

- Chrome 64+
- Firefox 69+
- Safari 13.1+
- Edge 79+

对于不支持的浏览器，可以安装并使用 polyfill：

```bash
npm install @juggle/resize-observer
```

然后在项目的入口文件中添加：

```javascript
// 在 ResizeObserver 使用之前添加
if (!window.ResizeObserver) {
	window.ResizeObserver = require('@juggle/resize-observer').ResizeObserver;
}
```

或者使用动态导入：

```javascript
if (!window.ResizeObserver) {
	const { ResizeObserver } = await import('@juggle/resize-observer');
	window.ResizeObserver = ResizeObserver;
}
```
